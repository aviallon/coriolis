{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\info 
{\title {\comment Katabatic - Routing Toolbox  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0 \par
}}Katabatic - Routing Toolbox}
{\comment Generated byDoxgyen. }
{\creatim \yr2021\mo11\dy21\hr22\min10\sec20}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt Katabatic - Routing Toolbox}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 1.0\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Sun Nov 21 2021 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Katabatic Documentation\par \pard\plain 
{\tc \v Katabatic Documentation}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Additionnal documents:{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Synthetic Class Hierarchy} \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Module Index\par \pard\plain 
{\tc \v Module Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Modules\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all modules:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Synthetic Class Hierarchy\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Global Routing Loading\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Generalities
{\f2  [external]}\par
\par
JSON Support
{\f2  [external]}\par
\par
DbU/Unit description
{\f2  [external]}\par
\par
Graphics
{\f2  [external]}\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Index\par \pard\plain 
{\tc \v Namespace Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Namespace List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all documented namespaces with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b anonymous_namespace\{AutoSegment.cpp\}} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b anonymous_namespace\{ChipTools.cpp\}} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b anonymous_namespace\{GCell.cpp\}} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b anonymous_namespace\{KatabaticEngine.cpp\}} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b anonymous_namespace\{LoadGrByNet.cpp\}} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b anonymous_namespace\{Session.cpp\}} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Katabatic} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace dedicated to {\b Katabatic} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
AutoContact\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEA \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
AutoContactHTee\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
AutoContactTerminal\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
AutoContactTurn\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
AutoContactVTee\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
AutoSegment\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKH \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
AutoHorizontal\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
AutoVertical\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
BaseGrid::Axis\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
BaseGrid\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQR \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Grid< GCell >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWF \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
GCellGrid\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Grid< GCellT >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
BaseObserver\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARJ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Observer< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
ChipTools\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Collection< Type >
{\f2  [external]}{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
AutoSegments_Aligneds\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
AutoSegments_AnchorOnGCell\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
AutoSegments_OnContact\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
AutoSegments_Perpandiculars\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
GCell::CompareByDensity\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
GCell::CompareByIndex\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DBo
{\f2  [external]}{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
ToolEngine
{\f2  [external]}{
\par
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
KatabaticEngine\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
Filter< Type >
{\f2  [external]}{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
AutoSegments_InDirection\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
AutoSegments_IsAccountable\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
GCell\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
GCellDensitySet\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
GCellTopology\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
GCell::Key\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
LocatorHelper\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Observable\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Session\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b AutoContact} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract base class for {\b AutoContact} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AutoContactHTee} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AutoContact} H-Tee (two H, one V) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AutoContactTerminal} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AutoContact} Terminal (S/T is a Terminal) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AutoContactTurn} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AutoContact} Turn (one H, one V) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AutoContactVTee} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AutoContact} V-Tee (one H, two V) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AutoHorizontal} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Concrete Horizontal {\b AutoSegment} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AutoSegment} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract base class for {\b AutoSegment} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AutoSegments_Aligneds} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All aligned {\b AutoSegment} of a set })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AutoSegments_AnchorOnGCell} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All {\b AutoSegment} Beginning and/or Stopping in a {\b GCell} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AutoSegments_InDirection} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Filter to select {\b AutoSegment} in a given direction })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AutoSegments_IsAccountable} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Filter to select accoutable {\b AutoSegment} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AutoSegments_OnContact} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All {\b AutoSegment} anchored on a Contact })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AutoSegments_Perpandiculars} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All perpandicular {\b AutoSegment} to a set of aligneds })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AutoVertical} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Concrete Vertical {\b AutoSegment} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b BaseGrid::Axis} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Graduations on a {\b BaseGrid} {\b Axis} (H or V) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b BaseGrid} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract Base Class for Irregular {\b Grid} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b BaseObserver} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Observer} Design Pattern, {\b Observer} part })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ChipTools} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Utilities for Chip Level Design })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b GCell::CompareByDensity} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} Density Comparison Functor })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b GCell::CompareByIndex} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} Index Comparison Functor })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b GCell} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Routing Global Cell })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b GCellDensitySet} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} Set, sorted by density })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b GCellGrid} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} {\b Grid} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b GCellTopology} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Build the wiring for a Net inside a GCell ({\b internal} ) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Grid< GCellT >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template Class for Regular {\b Grid} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b KatabaticEngine} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Katabatic} Tool })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b GCell::Key} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} {\b Key} - Density Cache })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b LocatorHelper} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Locator Helper Collection's Locators })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Observable} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Observer} Design Pattern, Subject part })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Observer< T >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Observer} Design Pattern, {\b Observer} part })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Session} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Modification {\b Session} for {\b Katabatic} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Module Documentation{\tc \v Module Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Synthetic Class Hierarchy\par \pard\plain 
{\tc\tcl2 \v Synthetic Class Hierarchy}
{\xe \v Synthetic Class Hierarchy}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simplificated class hierarchy. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simplificated class hierarchy. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
 \par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Global Routing Loading\par \pard\plain 
{\tc\tcl2 \v Global Routing Loading}
{\xe \v Global Routing Loading}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Translation rules to build detailed routing from global. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GCellTopology}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Build the wiring for a Net inside a GCell ({\b internal} ). }\par}}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b LocalFunctionFlag} \{ {\b NoFlags} = 0x00000000
, {\b HAccess} = 0x00000002, 
{\b VSmall} = 0x00000004, 
{\b HSmall} = 0x00000008, 
{\b Punctual} = 0x00000010
, {\b DoSourceContact} = 0x00000100, 
{\b DoTargetContact} = 0x00000200
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b checkRoutingPadSize} ({\b Component} *anchor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b doRp_AutoContacts} ({\b GCell} *, {\b Component} *, {\b AutoContact} *&source, {\b AutoContact} *&target, unsigned int flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b AutoContact} * {\b doRp_Access} ({\b GCell} *, {\b Component} *, unsigned int flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b AutoContact} * {\b doRp_AccessPad} ({\b RoutingPad} *, unsigned int flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b doRp_StairCaseH} ({\b GCell} *, {\b Component} *rp1, {\b Component} *rp2)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b doRp_StairCaseV} ({\b GCell} *, {\b Component} *rp1, {\b Component} *rp2)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _do_xG_1Pad} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _do_xG} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _do_1G_1M1} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _do_1G_xM1} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _do_xG_1M1_1M2} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _do_xG_xM1_xM3} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _do_xG_xM2} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _do_1G_1M3} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _do_xG_xM3} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b singleGCell} ({\b KatabaticEngine} *ktbt, {\b Net} *net)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Translation rules to build detailed routing from global. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This module documents how the global routing built by {\f2 Knik}  is loaded into the {\f2 {\b Katabatic}}  data-base. It is intented for developpers only. \par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v LocalFunctionFlag\:Global Routing Loading}
{\xe \v Global Routing Loading\:LocalFunctionFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b LocalFunctionFlag}}}
\par
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A set of flags for all functions of the LoadGrByNet module. They can be combined to form the {\i flags}  argument of functions. the functions will ignore flags that are not intended to them.\par
For {\f2 HSmall} , {\f2 VSmall}  & {\f2 Punctual}  see {\b checkRoutingPadSize()}. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v NoFlags\:Global Routing Loading}
{\xe \v Global Routing Loading\:NoFlags}
{\qr NoFlags{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A simple alias over zero to explicitly tell that no flag at all is passed to the function. \par
}\cell }{\row }
{\xe \v HAccess\:Global Routing Loading}
{\xe \v Global Routing Loading\:HAccess}
{\qr HAccess{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The constructed topology will be accessed through an horizontal segment. The absence of this flag tell that the access will be done trough a vertical. \par
}\cell }{\row }
{\xe \v VSmall\:Global Routing Loading}
{\xe \v Global Routing Loading\:VSmall}
{\qr VSmall{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The RoutingPad vertically covers a very small number of access points, so it is likely overconstrained for direct horizontal connexion. \par
}\cell }{\row }
{\xe \v HSmall\:Global Routing Loading}
{\xe \v Global Routing Loading\:HSmall}
{\qr HSmall{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The RoutingPad horizontally covers a very small number of access points, so it is likely overconstrained for direct vertical connexion. \par
}\cell }{\row }
{\xe \v Punctual\:Global Routing Loading}
{\xe \v Global Routing Loading\:Punctual}
{\qr Punctual{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The RoutingPad covers only an access point in either direction. \par
}\cell }{\row }
{\xe \v DoSourceContact\:Global Routing Loading}
{\xe \v Global Routing Loading\:DoSourceContact}
{\qr DoSourceContact{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When creating {\b Katabatic::AutoContactTerminal} on non-punctual RoutingPad, this flag request the creation of a contact {\i on the source point} . \par
}\cell }{\row }
{\xe \v DoTargetContact\:Global Routing Loading}
{\xe \v Global Routing Loading\:DoTargetContact}
{\qr DoTargetContact{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When creating {\b Katabatic::AutoContactTerminal} on non-punctual RoutingPad, this flag request the creation of a contact {\i on the target point} . \par
}\cell }{\row }
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v checkRoutingPadSize\:Global Routing Loading}
{\xe \v Global Routing Loading\:checkRoutingPadSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int checkRoutingPadSize ({\b Component} *  {\i rp})}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Look at the geometrical size of the Component and assess if it's span is too narrow either horizontally or vertically. Return a combination of flags indicating it's state:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
HSmall : less than 3 pitches in horizontal direction.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
VSmall : less than 3 pitches in vertical direction.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Punctual : one pitch in either directions.\par}
The component can be a RoutingPad, a Vertical or an Horizontal.\par
 \par
}{
References Component::getLayer(), anonymous_namespace\{LoadGrByNet.cpp\}::HSmall, anonymous_namespace\{LoadGrByNet.cpp\}::Punctual, toLambda(), and anonymous_namespace\{LoadGrByNet.cpp\}::VSmall.}\par
{
Referenced by GCellTopology::doRp_Access().}\par
}
{\xe \v doRp_AutoContacts\:Global Routing Loading}
{\xe \v Global Routing Loading\:doRp_AutoContacts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void doRp_AutoContacts ({\b GCell} *  {\i gcell}, {\b Component} *  {\i rp}, {\b AutoContact} *&  {\i source}, {\b AutoContact} *&  {\i target}, unsigned int  {\i flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i gcell} \cell }{The GCell into which create the AutoContact. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rp} \cell }{The Component we want to access. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i source} \cell }{The AutoContact created on the {\f2 source}  ({\i returned} ). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i target} \cell }{The AutoContact created on the {\f2 target}  ({\i returned} ). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i flags} \cell }{Managed by this function:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
LocalFunctionFlag::DoSourceContact\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
LocalFunctionFlag::DoTargetContact\par}
\cell }
{\row }
}
Create the AutoContact directly anchored on the Component (terminal). Three cases are manageds:{
\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab {\b Ordinary (non-punctual) {\f2 METAL1}  terminal} : an AutoContactTerminal is anchored on the RoutingPad.\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab {\b Punctual {\f2 METAL1}  terminal} , the access must never be blocked by other routing. To ensure it, we create a fixed AutoSegment (anchored on two AutoContactTerminal) to cover it. The {\i normal}  AutoContactTerminal is also created.\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
3.\tab {\b non {\f2 METAL1}  terminal} , as for the punctual {\f2 METAL1} , a fixed protection is added over the RoutingPad. If we access horizontally a vertical RoutingPad or vertically an horizontal one, an extra AutoContactTerminal is added (to allow is displacement along the RoutingPad).\par}
To avoid creating a fixed protection over a RoutingPad multiple times, the RoutingPad and it's associated protection is stored in a static {\f2 map}  : {\f2 __routingPadAutoSegments} .\par
Conversely, because an AutoContactTerminal can only be connected to one segment, each time this function is called a new terminal will be created (or maybe two in case of non-punctual terminals). If only one AutoContact is requested, it is created centered on the RoutingPad. The initial position of AutoContact {\i do not prevent them to move afterwards} , even those created on source/target on a non-punctual RoutingPad.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: For clarity we describe the layer management of this function in term\par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid of {\f2 METAL} , but it is the RoutingGauge depth which is actually used.\par
} \par
}{
References Katabatic::CntFixed, AutoContactTerminal::create(), AutoSegment::create(), anonymous_namespace\{LoadGrByNet.cpp\}::DoSourceContact, anonymous_namespace\{LoadGrByNet.cpp\}::DoTargetContact, Session::getContactLayer(), Grid< GCellT >::getGCell(), KatabaticEngine::getGCellGrid(), Session::getKatabatic(), Component::getLayer(), Katabatic::KbHorizontal, Katabatic::SegFixed, and AutoSegment::setFlags().}\par
{
Referenced by GCellTopology::_do_1G_1M3(), GCellTopology::_do_xG_1M1_1M2(), GCellTopology::_do_xG_xM1_xM3(), GCellTopology::_do_xG_xM2(), GCellTopology::_do_xG_xM3(), GCellTopology::doRp_Access(), GCellTopology::doRp_StairCaseH(), GCellTopology::doRp_StairCaseV(), and anonymous_namespace\{LoadGrByNet.cpp\}::singleGCell().}\par
}
{\xe \v doRp_Access\:Global Routing Loading}
{\xe \v Global Routing Loading\:doRp_Access}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoContact} * doRp_Access ({\b GCell} *  {\i gcell}, {\b Component} *  {\i rp}, unsigned int  {\i flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i gcell} \cell }{The GCell into which create the AutoContact. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rp} \cell }{The Component onto which anchor the access contact. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i flags} \cell }{Relevant flags are:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
HAccess, the terminal is to be accessed through an horizontal segment.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
VSmall, force the terminal to be considered as small in the vertical direction.\par}
\cell }
{\row }
}
If {\f2 HAccess}  is set, the Component is to be accessed trough an horizontal segment. If unset, the access is done vertically.\par
Create an AutoContact to access a Component (terminal). If the Component is not to be accessed through an horizontal segment, and do not cover a large span in the horizontal direction (flag {\f2 VSmall} ), a local horizontal AutoSegment is added to slacken the vertical constraints.\par
 \par
}{
References anonymous_namespace\{LoadGrByNet.cpp\}::checkRoutingPadSize(), AutoContactTurn::create(), AutoSegment::create(), GCellTopology::doRp_AutoContacts(), Session::getContactLayer(), Component::getNet(), anonymous_namespace\{LoadGrByNet.cpp\}::HAccess, anonymous_namespace\{LoadGrByNet.cpp\}::HSmall, Katabatic::KbHorizontal, Katabatic::KbVertical, and anonymous_namespace\{LoadGrByNet.cpp\}::VSmall.}\par
{
Referenced by GCellTopology::_do_1G_1M1(), GCellTopology::_do_1G_xM1(), GCellTopology::_do_xG_xM1_xM3(), GCellTopology::_do_xG_xM2(), and GCellTopology::_do_xG_xM3().}\par
}
{\xe \v doRp_AccessPad\:Global Routing Loading}
{\xe \v Global Routing Loading\:doRp_AccessPad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoContact} * doRp_AccessPad ({\b RoutingPad} *  {\i rp}, unsigned int  {\i flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rp} \cell }{The Component onto which anchor the access contact. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i flags} \cell }{Relevant flags are:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
HAccess, the terminal is to be accessed through an horizontal segment.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
VSmall, force the terminal to be considered as small in the vertical direction. \par}
\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A {\b Katabatic::AutoContactTerminal} .\par
}The Component {\f2 rp}  is a RoutingPad which belongs to a pad cell. This case occurs when we are routing a complete chip. This method build, from the {\f2 rp}  a stack of articulated punctual segments and contacts to reach the default H/V routing layers (usually {\f2 METAL2}  & {\f2 METAL3} ). This may be needed when the pad terminal is in {\f2 METAL5} , for instance.\par
The returned AutoContactTerminal is anchored on the last punctual segment build.\par
The GCell into which the AutoContactTerminal is created may be under the pads area. However, it will be right on the border of the GCell. The global router vertexes of GCell under the pad area are marked as blocked so will never be used for routing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: The segments and contacts added to ensure the layer connexity are not\par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid put into the {\b Katabatic} database. They are plain Hurricane objects, invisibles from it. \par
}}{
References Contact::create(), Horizontal::create(), Vertical::create(), AutoContactTerminal::create(), Hook::detach(), Component::getBodyHook(), RoutingPad::getBoundingBox(), RoutingPad::getCenter(), Session::getContactLayer(), Grid< GCellT >::getGCell(), KatabaticEngine::getGCellGrid(), Box::getHeight(), Session::getKatabatic(), RoutingPad::getLayer(), Component::getNet(), RoutingPad::getOccurrence(), Transformation::getOrientation(), Occurrence::getPath(), Session::getRoutingLayer(), Path::getTransformation(), Box::getWidth(), Box::getXMax(), Box::getXMin(), Box::getYMax(), Box::getYMin(), anonymous_namespace\{LoadGrByNet.cpp\}::HAccess, Katabatic::KbHorizontal, Point::setX(), and Point::setY().}\par
{
Referenced by GCellTopology::_do_xG_1Pad().}\par
}
{\xe \v doRp_StairCaseH\:Global Routing Loading}
{\xe \v Global Routing Loading\:doRp_StairCaseH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void doRp_StairCaseH ({\b GCell} *  {\i gcell}, {\b Component} *  {\i rp1}, {\b Component} *  {\i rp2}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Build the wiring to connect to horizontal Component. Two cases:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The Component are aligneds, then only a straight wire is created.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
They are {\i not}  aligned, then a complete dogleg is created.\par}
 \par
}{
References AutoContactTurn::create(), AutoSegment::create(), GCellTopology::doRp_AutoContacts(), anonymous_namespace\{LoadGrByNet.cpp\}::DoSourceContact, anonymous_namespace\{LoadGrByNet.cpp\}::DoTargetContact, Session::getContactLayer(), Component::getLayer(), Component::getNet(), Component::getX(), AutoContact::getY(), Katabatic::KbHorizontal, and Katabatic::KbVertical.}\par
{
Referenced by GCellTopology::_do_xG_xM2().}\par
}
{\xe \v doRp_StairCaseV\:Global Routing Loading}
{\xe \v Global Routing Loading\:doRp_StairCaseV}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void doRp_StairCaseV ({\b GCell} *  {\i gcell}, {\b Component} *  {\i rp1}, {\b Component} *  {\i rp2}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Build the wiring to connect to vertical Components. Two cases:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The Components are aligneds, then only a straight wire is created.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
They are {\i not}  aligned, then a complete dogleg is created.\par}
 \par
}{
References AutoContactTurn::create(), AutoSegment::create(), GCellTopology::doRp_AutoContacts(), anonymous_namespace\{LoadGrByNet.cpp\}::DoSourceContact, anonymous_namespace\{LoadGrByNet.cpp\}::DoTargetContact, Session::getContactLayer(), Component::getLayer(), Component::getNet(), AutoContact::getX(), Component::getY(), Katabatic::KbHorizontal, and Katabatic::KbVertical.}\par
{
Referenced by GCellTopology::_do_xG_xM3().}\par
}
{\xe \v _do_xG_1Pad\:Global Routing Loading}
{\xe \v Global Routing Loading\:_do_xG_1Pad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _do_xG_1Pad (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct the topology, when there is only global wires and one local terminal, but coming from a Pad. As thoses connectors will always be on one border of the GCell they can be considered as a kind of global.\par
So this method mostly calls {\b GCellTopology::doRp_AccessPad()} to create the AutoContactTerminal, then calls {\b GCellTopology::_do_xG()}, except for straight lines which are managed directly. \par
}{
References GCellTopology::_do_xG(), AutoContactTurn::create(), AutoSegment::create(), GCellTopology::doRp_AccessPad(), AutoContact::getBodyHook(), Session::getContactLayer(), anonymous_namespace\{LoadGrByNet.cpp\}::HAccess, Katabatic::KbHorizontal, Katabatic::KbVertical, and anonymous_namespace\{LoadGrByNet.cpp\}::NoFlags.}\par
}
{\xe \v _do_xG\:Global Routing Loading}
{\xe \v Global Routing Loading\:_do_xG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _do_xG (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct the topology, when there is only global wires (no local terminals).\par
Some topology are not handled because they must not be managed by this function: {
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
One global: nonsensical because there also must be a terminal. \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Two aligned globals: in that case we do a straight wire without any AutoContact (handled by the source/target of the wire). \par}
 \par
}{
References AutoContactVTee::create(), AutoContactTurn::create(), AutoContactHTee::create(), AutoSegment::create(), Session::getContactLayer(), Katabatic::KbHorizontal, and Katabatic::KbVertical.}\par
{
Referenced by GCellTopology::_do_xG_1Pad().}\par
}
{\xe \v _do_1G_1M1\:Global Routing Loading}
{\xe \v Global Routing Loading\:_do_1G_1M1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _do_1G_1M1 (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a topology where there is {\i one}  global and one RoutingPad in {\f2 METAL1} . The {\f2 METAL1}  is assumed to be vertical.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: When accessing the RoutingPad through an horizontal global segment\par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid and the vertical extension of the segment is small, the global is still directly attached to the terminal, inducing a high constraint on it. We left to job of slackening it to the router.\par
} \par
}{
References GCellTopology::doRp_Access(), anonymous_namespace\{LoadGrByNet.cpp\}::HAccess, anonymous_namespace\{LoadGrByNet.cpp\}::NoFlags, and anonymous_namespace\{LoadGrByNet.cpp\}::VSmall.}\par
}
{\xe \v _do_1G_xM1\:Global Routing Loading}
{\xe \v Global Routing Loading\:_do_1G_xM1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _do_1G_xM1 (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a topology where there is {\i one}  global and any number of RoutingPad in {\f2 METAL1} . The {\f2 METAL1}  is assumed to be vertical.\par
The RoutingPads are linked together two by two. If the horizontal segments are not aligned by the router, part of the routage will be done through the RoutingPad itself. The global incoming segment will connected to the leftmost, rightmost or centermost RoutingPad according from wich side it comes from.\par
 \par
}{
References AutoContactTurn::create(), AutoSegment::create(), GCellTopology::doRp_Access(), Component::getBoundingBox(), Session::getContactLayer(), Box::getHeight(), anonymous_namespace\{LoadGrByNet.cpp\}::HAccess, Katabatic::KbHorizontal, and anonymous_namespace\{LoadGrByNet.cpp\}::NoFlags.}\par
}
{\xe \v _do_xG_1M1_1M2\:Global Routing Loading}
{\xe \v Global Routing Loading\:_do_xG_1M1_1M2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _do_xG_1M1_1M2 (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a topology where there is at least one global (and up to 4), one {\f2 METAL1}  RoutingPad (assumed V) and one {\f2 METAL2}  RoutingPad (assumed H).\par
In this topology, we want to try to reuse the {\f2 METAL2}  RoutingPad as a feedtrough in the horizontal routage. Thus:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The {\f2 METAL1}  and {\f2 METAL2}  RoutingPad are connected through a separate wiring.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The south & west global wiring is attached to the leftmost contact of the {\f2 METAL2} .\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The north & east global wiring is attached to the rightmost contact of the {\f2 METAL2} .\par}
South/west and north/south can be build independantly. Depending on the number of globals, they can consist of:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Nothing (no south nor west).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
An AutoContact (west present).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
An horizontal plus a turn (south present).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
An horizontal plus a HTee (south & west present).\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: Not all configurations are represented below.\par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
} \par
}{
References AutoContactTurn::create(), AutoContactHTee::create(), AutoSegment::create(), GCellTopology::doRp_AutoContacts(), anonymous_namespace\{LoadGrByNet.cpp\}::DoSourceContact, anonymous_namespace\{LoadGrByNet.cpp\}::DoTargetContact, Session::getContactLayer(), Session::getRoutingLayer(), Katabatic::KbHorizontal, Katabatic::KbVertical, and anonymous_namespace\{LoadGrByNet.cpp\}::NoFlags.}\par
}
{\xe \v _do_xG_xM1_xM3\:Global Routing Loading}
{\xe \v Global Routing Loading\:_do_xG_xM1_xM3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _do_xG_xM1_xM3 (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a topology where there is at least one global (and up to 4), at least one {\f2 METAL1}  RoutingPad (assumed V) and at least one {\f2 METAL3}  RoutingPad (assumed V).\par
In this topology, we want to try to reuse the {\f2 METAL3}  RoutingPad as a feedtrough in the vertical routage. Thus:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The {\f2 METAL1}  and {\f2 METAL3}  RoutingPad are connected through a separate wiring made of separate horizontals.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The south-west global wiring is attached to the leftmost RoutingPad if there isn't south or to the first {\f2 METAL3}  otherwise.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The north-east global wiring is attached to the rightmost RoutingPad if there isn't north or to the first {\f2 METAL3}  otherwise.\par}
South/west and north/south can be build independantly. Depending on the number of globals, they can consist of:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Nothing (no south nor west).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
An AutoContact on the leftmost RoutingPad (west present).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
An AutoContact on the first {\f2 METAL3}  (only south present).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
An AutoContact plus a vertical plus a VTee (south & west present).\par}
 \par
}{
References AutoContactVTee::create(), AutoContactTurn::create(), AutoContactHTee::create(), AutoSegment::create(), GCellTopology::doRp_Access(), GCellTopology::doRp_AutoContacts(), anonymous_namespace\{LoadGrByNet.cpp\}::DoSourceContact, anonymous_namespace\{LoadGrByNet.cpp\}::DoTargetContact, Component::getBoundingBox(), Session::getContactLayer(), Box::getHeight(), Session::getRoutingLayer(), anonymous_namespace\{LoadGrByNet.cpp\}::HAccess, Katabatic::KbHorizontal, Katabatic::KbVertical, and anonymous_namespace\{LoadGrByNet.cpp\}::NoFlags.}\par
}
{\xe \v _do_xG_xM2\:Global Routing Loading}
{\xe \v Global Routing Loading\:_do_xG_xM2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _do_xG_xM2 (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a topology where there is at least one global (and up to 4), and any number of {\f2 METAL2}  RoutingPads (assumeds H).\par
In this topology, we want to try to reuse the {\f2 METAL2}  RoutingPad as a feedtrough in the horizontal routage. Thus:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The RoutingPad are connecteds trough a separate staircase (or straight wire if aligneds).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The south-west global wiring is attached to the leftmost RoutingPad if there isn't south or to the biggest horizontal RoutingPad otherwise.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The north-east global wiring is attached to the rightmost RoutingPad if there isn't south or to the biggest horizontal RoutingPad otherwise.\par}
 \par
}{
References AutoContactVTee::create(), AutoSegment::create(), GCellTopology::doRp_Access(), GCellTopology::doRp_AutoContacts(), GCellTopology::doRp_StairCaseH(), anonymous_namespace\{LoadGrByNet.cpp\}::DoSourceContact, Component::getBoundingBox(), Session::getContactLayer(), Box::getWidth(), Katabatic::KbVertical, and anonymous_namespace\{LoadGrByNet.cpp\}::NoFlags.}\par
}
{\xe \v _do_1G_1M3\:Global Routing Loading}
{\xe \v Global Routing Loading\:_do_1G_1M3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _do_1G_1M3 (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a topology where there is one global and one {\f2 METAL3}  RoutingPad (assumeds V).\par
In this topology, we reuse the {\f2 METAL3}  RoutingPad as a feedtrough in the vertical routage. Thus:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
If the global is either north or south, we directly connect to the north end or south end of the RoutingPad. The vertical global will have no slack at all we assume that METAL3 terminals are only from blocks and are aligneds vertically.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
If the global is east or west {\i and}  the RoutingPad is sufficiently extended in the vertical direction, we connect an horizontal in the normal way.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
If the global is not sufficiently extended, we add a turn to give some slack to the global.\par}
 \par
}{
References AutoContactTurn::create(), AutoSegment::create(), GCellTopology::doRp_AutoContacts(), anonymous_namespace\{LoadGrByNet.cpp\}::DoSourceContact, anonymous_namespace\{LoadGrByNet.cpp\}::DoTargetContact, Session::getContactLayer(), AutoContact::getX(), anonymous_namespace\{LoadGrByNet.cpp\}::HAccess, Katabatic::KbHorizontal, Katabatic::KbVertical, and anonymous_namespace\{LoadGrByNet.cpp\}::NoFlags.}\par
}
{\xe \v _do_xG_xM3\:Global Routing Loading}
{\xe \v Global Routing Loading\:_do_xG_xM3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _do_xG_xM3 (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a topology where there at least one global and two {\f2 METAL3}  RoutingPad (assumed V).\par
In this topology, we reuse the {\f2 METAL3}  RoutingPad as a feedtrough in the vertical routage. We assume that the most likely relative position of the RoutingPads is to be aligned vertically. Thus:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
All RoutingPads are linked two by two trough vertical staircases.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The south-west global wiring is attached to the bottommost RoutingPad (without vertical slack). If a misalignment is detected, then a dogleg is added.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The north-east global wiring is attached to the topmost RoutingPad (without vertical slack).\par}
South/west and north/south can be build independantly. Depending on the number of globals, they can consist of:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Nothing (no south nor west).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
An sliding AutoContact on the bottommost RoutingPad (west present).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
An fixed AutoContact on the bottommost RoutingPad (only south present).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
An fixed AutoContact plus a vertical plus a VTee (south & west present).\par}
 \par
}{
References AutoContactVTee::create(), AutoContactTurn::create(), AutoSegment::create(), GCellTopology::doRp_Access(), GCellTopology::doRp_AutoContacts(), GCellTopology::doRp_StairCaseV(), anonymous_namespace\{LoadGrByNet.cpp\}::DoSourceContact, anonymous_namespace\{LoadGrByNet.cpp\}::DoTargetContact, Session::getContactLayer(), DbU::getValueString(), AutoContact::getX(), anonymous_namespace\{LoadGrByNet.cpp\}::HAccess, Katabatic::KbHorizontal, Katabatic::KbVertical, and anonymous_namespace\{LoadGrByNet.cpp\}::NoFlags.}\par
}
{\xe \v singleGCell\:Global Routing Loading}
{\xe \v Global Routing Loading\:singleGCell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void singleGCell ({\b KatabaticEngine} *  {\i ktbt}, {\b Net} *  {\i net})}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All the RoutingPads of the net are concentrated under a single GCell. This function assumes that all the terminals are in {\f2 METAL1}  (vertical), and link them two by two by horizontal wires. \par
}{
References AutoContactTurn::create(), AutoSegment::create(), GCellTopology::doRp_AutoContacts(), anonymous_namespace\{LoadGrByNet.cpp\}::DoSourceContact, Session::getContactLayer(), Grid< GCellT >::getGCell(), KatabaticEngine::getGCellGrid(), RoutingGauge::getLayerDepth(), Session::getRoutingGauge(), Net::getRoutingPads(), Katabatic::KbHorizontal, Katabatic::KbVertical, and anonymous_namespace\{LoadGrByNet.cpp\}::NoFlags.}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Documentation\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
anonymous_namespace\{AutoSegment.cpp\} Namespace Reference\par \pard\plain 
{\tc\tcl2 \v anonymous_namespace\{AutoSegment.cpp\}}
{\xe \v anonymous_namespace\{AutoSegment.cpp\}}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
anonymous_namespace\{ChipTools.cpp\} Namespace Reference\par \pard\plain 
{\tc\tcl2 \v anonymous_namespace\{ChipTools.cpp\}}
{\xe \v anonymous_namespace\{ChipTools.cpp\}}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
anonymous_namespace\{GCell.cpp\} Namespace Reference\par \pard\plain 
{\tc\tcl2 \v anonymous_namespace\{GCell.cpp\}}
{\xe \v anonymous_namespace\{GCell.cpp\}}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
anonymous_namespace\{KatabaticEngine.cpp\} Namespace Reference\par \pard\plain 
{\tc\tcl2 \v anonymous_namespace\{KatabaticEngine.cpp\}}
{\xe \v anonymous_namespace\{KatabaticEngine.cpp\}}
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
anonymous_namespace\{LoadGrByNet.cpp\} Namespace Reference\par \pard\plain 
{\tc\tcl2 \v anonymous_namespace\{LoadGrByNet.cpp\}}
{\xe \v anonymous_namespace\{LoadGrByNet.cpp\}}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GCellTopology}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Build the wiring for a Net inside a GCell ({\b internal} ). }\par}}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b LocalFunctionFlag} \{ {\b NoFlags} = 0x00000000
, {\b HAccess} = 0x00000002, 
{\b VSmall} = 0x00000004, 
{\b HSmall} = 0x00000008, 
{\b Punctual} = 0x00000010
, {\b DoSourceContact} = 0x00000100, 
{\b DoTargetContact} = 0x00000200
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b checkRoutingPadSize} ({\b Component} *anchor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b singleGCell} ({\b KatabaticEngine} *ktbt, {\b Net} *net)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
anonymous_namespace\{Session.cpp\} Namespace Reference\par \pard\plain 
{\tc\tcl2 \v anonymous_namespace\{Session.cpp\}}
{\xe \v anonymous_namespace\{Session.cpp\}}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Katabatic Namespace Reference\par \pard\plain 
{\tc\tcl2 \v Katabatic}
{\xe \v Katabatic}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace dedicated to {\b Katabatic}. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AutoContact}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract base class for {\b AutoContact}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AutoContactHTee}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AutoContact} H-Tee (two H, one V) }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AutoContactTerminal}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AutoContact} Terminal (S/T is a Terminal) }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AutoContactTurn}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AutoContact} Turn (one H, one V) }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AutoContactVTee}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AutoContact} V-Tee (one H, two V) }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AutoHorizontal}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Concrete Horizontal {\b AutoSegment}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AutoSegment}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract base class for {\b AutoSegment}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AutoSegments_Aligneds}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All aligned {\b AutoSegment} of a set. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AutoSegments_AnchorOnGCell}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All {\b AutoSegment} Beginning and/or Stopping in a {\b GCell}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AutoSegments_InDirection}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Filter to select {\b AutoSegment} in a given direction. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AutoSegments_IsAccountable}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Filter to select accoutable {\b AutoSegment}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AutoSegments_OnContact}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All {\b AutoSegment} anchored on a Contact. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AutoSegments_Perpandiculars}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All perpandicular {\b AutoSegment} to a set of aligneds. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AutoVertical}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Concrete Vertical {\b AutoSegment}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BaseGrid}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract Base Class for Irregular {\b Grid}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BaseObserver}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Observer} Design Pattern, {\b Observer} part. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ChipTools}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Utilities for Chip Level Design. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GCell}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Routing Global Cell. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GCellDensitySet}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} Set, sorted by density. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GCellGrid}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} {\b Grid}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Grid}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template Class for Regular {\b Grid}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b KatabaticEngine}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Katabatic} Tool. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LocatorHelper}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Locator Helper Collection's Locators. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Observable}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Observer} Design Pattern, Subject part. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Observer}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Observer} Design Pattern, {\b Observer} part. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Session}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Modification {\b Session} for {\b Katabatic}. }\par}}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b Hurricane::Filter}< {\b AutoSegment} * > {\b AutoSegmentHF}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b Hurricane::Locator}< {\b AutoSegment} * > {\b AutoSegmentHL}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b Hurricane::Collection}< {\b AutoSegment} * > {\b AutoSegmentHC}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b GenericCollection}< {\b AutoSegment} * > {\b AutoSegments}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b GenericLocator}< {\b AutoSegment} * > {\b AutoSegmentLocator}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b GenericFilter}< {\b AutoSegment} * > {\b AutoSegmentFilter}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b GenericCollection}< {\b GCell} * > {\b GCells}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b GenericLocator}< {\b GCell} * > {\b GCellLocator}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b GenericFilter}< {\b GCell} * > {\b GCellFilter}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b FunctionFlag} \{ , {\b KbOpenSession} = 0x00000001, 
{\b KbRealignate} = 0x00000002, 
{\b KbNativeConstraints} = 0x00000004, 
{\b KbForceMove} = 0x00000008, 
{\b KbHorizontal} = 0x00000010, 
{\b KbVertical} = 0x00000020, 
{\b KbWithPerpands} = 0x00000040, 
{\b KbSource} = 0x00000080, 
{\b KbTarget} = 0x00000100, 
{\b KbWarnOnError} = 0x00000200
, {\b KbPropagate} = 0x00008000
, {\b KbUseAboveLayer} = 0x00020000, 
{\b KbUseBelowLayer} = 0x00040000, 
{\b KbDoglegOnLeft} = 0x00080000, 
{\b KbDoglegOnRight} = 0x00100000
, {\b KbHalfSlacken} = 0x00800000
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b EngineState} \{ {\b EngineCreation} = 1, 
{\b EngineGlobalLoaded} = 2, 
{\b EngineActive} = 3, 
{\b EngineDriving} = 4, 
{\b EnginePreDestroying} = 5, 
{\b EngineGutted} = 6
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b AutoContactFlag} \{ {\b CntFixed} = 0x00000001, 
{\b CntTerminal} = 0x00000002, 
{\b CntTurn} = 0x00000004, 
{\b CntHTee} = 0x00000008, 
{\b CntVTee} = 0x00000010, 
{\b CntInvalidated} = 0x00000020, 
{\b CntInvalidatedCache} = 0x00000040, 
{\b CntInCreationStage} = 0x00000080, 
{\b CntBadTopology} = 0x00000100
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b AutoSegmentFlag} \{ , {\b SegHorizontal} = (1<< 0), 
{\b SegFixed} = (1<< 1), 
{\b SegGlobal} = (1<< 2), 
{\b SegWeakGlobal} = (1<< 3), 
{\b SegCanonical} = (1<< 4), 
{\b SegBipoint} = (1<< 5), 
{\b SegDogleg} = (1<< 6), 
{\b SegStrap} = (1<< 7), 
{\b SegSourceTop} = (1<< 8), 
{\b SegSourceBottom} = (1<< 9), 
{\b SegTargetTop} = (1<<10), 
{\b SegTargetBottom} = (1<<11), 
{\b SegIsReduced} = (1<<12), 
{\b SegLayerChange} = (1<<13)
, {\b SegStrongTerminal} = SegSourceTerminal|SegTargetTerminal, 
{\b SegWeakTerminal1} = (1<<16), 
{\b SegWeakTerminal2} = (1<<17), 
{\b SegNotSourceAligned} = (1<<18), 
{\b SegNotTargetAligned} = (1<<19)
, {\b SegSlackened} = (1<<22), 
{\b SegAxisSet} = (1<<23), 
{\b SegInvalidated} = (1<<24)
, {\b SegInvalidatedLayer} = (1<<27), 
{\b SegCreated} = (1<<28)
, {\b SegWeakTerminal} = SegStrongTerminal|SegWeakTerminal1|SegWeakTerminal2, 
{\b SegNotAligned} = SegNotSourceAligned|SegNotTargetAligned
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace dedicated to {\b Katabatic}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v AutoSegmentHF\:Katabatic}
{\xe \v Katabatic\:AutoSegmentHF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b Hurricane::Filter}< {\b AutoSegment} * > {\b AutoSegmentHF}}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Shorthand for {\b AutoSegment} Hurricane Filter. \par
}}
{\xe \v AutoSegmentHL\:Katabatic}
{\xe \v Katabatic\:AutoSegmentHL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b Hurricane::Locator}< {\b AutoSegment} * > {\b AutoSegmentHL}}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Shorthand for {\b AutoSegment} Hurricane Locator. \par
}}
{\xe \v AutoSegmentHC\:Katabatic}
{\xe \v Katabatic\:AutoSegmentHC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b Hurricane::Collection}< {\b AutoSegment} * > {\b AutoSegmentHC}}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Shorthand for {\b AutoSegment} Hurricane Collection. \par
}}
{\xe \v AutoSegments\:Katabatic}
{\xe \v Katabatic\:AutoSegments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b GenericCollection}< {\b AutoSegment} * > {\b AutoSegments}}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Shorthand for {\b AutoSegment} Hurricane Generic Collection (collection with {\f2 unique_ptr<>}  like support). \par
}}
{\xe \v AutoSegmentLocator\:Katabatic}
{\xe \v Katabatic\:AutoSegmentLocator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b GenericLocator}< {\b AutoSegment} * > {\b AutoSegmentLocator}}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Shorthand for {\b AutoSegment} Hurricane Generic Locator (locator with {\f2 unique_ptr<>}  like support). \par
}}
{\xe \v AutoSegmentFilter\:Katabatic}
{\xe \v Katabatic\:AutoSegmentFilter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b GenericFilter}< {\b AutoSegment} * > {\b AutoSegmentFilter}}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Shorthand for {\b AutoSegment} Hurricane Generic Filter (filter with {\f2 unique_ptr<>}  like support). \par
}}
{\xe \v GCells\:Katabatic}
{\xe \v Katabatic\:GCells}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b GenericCollection}< {\b GCell} * > {\b GCells}}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} Collection with auto-pointer like support. \par
}}
{\xe \v GCellLocator\:Katabatic}
{\xe \v Katabatic\:GCellLocator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b GenericLocator}< {\b GCell} * > {\b GCellLocator}}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} Locator with auto-pointer like support. \par
}}
{\xe \v GCellFilter\:Katabatic}
{\xe \v Katabatic\:GCellFilter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b GenericFilter}< {\b GCell} * > {\b GCellFilter}}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} Filter with auto-pointer like support. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v FunctionFlag\:Katabatic}
{\xe \v Katabatic\:FunctionFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b FunctionFlag}}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A set of flags to that can be passed to functions/methods througout all {\b Katabatic}. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v KbOpenSession\:Katabatic}
{\xe \v Katabatic\:KbOpenSession}
{\qr KbOpenSession{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tells the function to open it's own {\b Session}, otherwise use the one that should already have been opened. \par
}\cell }{\row }
{\xe \v KbRealignate\:Katabatic}
{\xe \v Katabatic\:KbRealignate}
{\qr KbRealignate{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
On {\b AutoSegment} axis manipulation, force the realignment of all the segment on an aligned set, even is the axis of the canonical is already at the right coordinate. \par
}\cell }{\row }
{\xe \v KbNativeConstraints\:Katabatic}
{\xe \v Katabatic\:KbNativeConstraints}
{\qr KbNativeConstraints{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ignore user-defined constraints or terminal induced ones (for AutoContacts anchored on terminals) and return the owning {\b GCell} alone. \par
}\cell }{\row }
{\xe \v KbForceMove\:Katabatic}
{\xe \v Katabatic\:KbForceMove}
{\qr KbForceMove{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tells the function to force move, even if it is not needed. \par
}\cell }{\row }
{\xe \v KbHorizontal\:Katabatic}
{\xe \v Katabatic\:KbHorizontal}
{\qr KbHorizontal{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Request some action to be done in the horizontal direction. \par
}\cell }{\row }
{\xe \v KbVertical\:Katabatic}
{\xe \v Katabatic\:KbVertical}
{\qr KbVertical{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Request some action to be done in the vertical direction. \par
}\cell }{\row }
{\xe \v KbWithPerpands\:Katabatic}
{\xe \v Katabatic\:KbWithPerpands}
{\qr KbWithPerpands{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Request that AutoSegments in perpandicular direction should be includeds. \par
}\cell }{\row }
{\xe \v KbSource\:Katabatic}
{\xe \v Katabatic\:KbSource}
{\qr KbSource{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Request AutoSegments anchored by their source anchor or that some operation has to be performed on the source. \par
}\cell }{\row }
{\xe \v KbTarget\:Katabatic}
{\xe \v Katabatic\:KbTarget}
{\qr KbTarget{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Request AutoSegments anchored by their target anchor or that some operation has to be performed on the target. \par
}\cell }{\row }
{\xe \v KbWarnOnError\:Katabatic}
{\xe \v Katabatic\:KbWarnOnError}
{\qr KbWarnOnError{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Display a warning if something has gone wrong. \par
}\cell }{\row }
{\xe \v KbPropagate\:Katabatic}
{\xe \v Katabatic\:KbPropagate}
{\qr KbPropagate{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The action will affect all the segments on an aligned set. \par
}\cell }{\row }
{\xe \v KbUseAboveLayer\:Katabatic}
{\xe \v Katabatic\:KbUseAboveLayer}
{\qr KbUseAboveLayer{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Request/tell the a above layer has been used. \par
}\cell }{\row }
{\xe \v KbUseBelowLayer\:Katabatic}
{\xe \v Katabatic\:KbUseBelowLayer}
{\qr KbUseBelowLayer{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Request/tell the a below layer has been used. \par
}\cell }{\row }
{\xe \v KbDoglegOnLeft\:Katabatic}
{\xe \v Katabatic\:KbDoglegOnLeft}
{\qr KbDoglegOnLeft{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The dogleg has occured on the left {\i of something}  \par
}\cell }{\row }
{\xe \v KbDoglegOnRight\:Katabatic}
{\xe \v Katabatic\:KbDoglegOnRight}
{\qr KbDoglegOnRight{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The dogleg has occured on the right {\i of something}  \par
}\cell }{\row }
{\xe \v KbHalfSlacken\:Katabatic}
{\xe \v Katabatic\:KbHalfSlacken}
{\qr KbHalfSlacken{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For {\b AutoSegment::slacken()}, change the overconstrained limit from 10 tracks down to 3 (hard-wired). \par
}\cell }{\row }
}
}
{\xe \v EngineState\:Katabatic}
{\xe \v Katabatic\:EngineState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b EngineState}}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Describe the current state of the {\b KatabaticEngine}. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v EngineCreation\:Katabatic}
{\xe \v Katabatic\:EngineCreation}
{\qr EngineCreation{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The tool is created, but still in the {\f2 _postCreate}  stage. \par
}\cell }{\row }
{\xe \v EngineGlobalLoaded\:Katabatic}
{\xe \v Katabatic\:EngineGlobalLoaded}
{\qr EngineGlobalLoaded{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The global routing has been loaded from Knik. \par
}\cell }{\row }
{\xe \v EngineActive\:Katabatic}
{\xe \v Katabatic\:EngineActive}
{\qr EngineActive{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Engine is in normal running mode (routing ordinary wires). \par
}\cell }{\row }
{\xe \v EngineDriving\:Katabatic}
{\xe \v Katabatic\:EngineDriving}
{\qr EngineDriving{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Engine is transforming the AutoContact/AutoSegment into normal Contact/Segment (prior to tool deletion). \par
}\cell }{\row }
{\xe \v EnginePreDestroying\:Katabatic}
{\xe \v Katabatic\:EnginePreDestroying}
{\qr EnginePreDestroying{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This state is used whenever the tool is destroyed without passing through the EngineDriving state. \par
}\cell }{\row }
{\xe \v EngineGutted\:Katabatic}
{\xe \v Katabatic\:EngineGutted}
{\qr EngineGutted{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
After the EngineDriving state, all the working structures are removed and the tool can no longer be used. It only awaits clean destruction. \par
}\cell }{\row }
}
}
{\xe \v AutoContactFlag\:Katabatic}
{\xe \v Katabatic\:AutoContactFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b AutoContactFlag}}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set of flags to describe the internal state of an {\b AutoContact}. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v CntFixed\:Katabatic}
{\xe \v Katabatic\:CntFixed}
{\qr CntFixed{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This contact cannot be moved. \par
}\cell }{\row }
{\xe \v CntTerminal\:Katabatic}
{\xe \v Katabatic\:CntTerminal}
{\qr CntTerminal{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This contact is anchored on a terminal ({\b AutoContactTerminal}), {\b must not be changed} . \par
}\cell }{\row }
{\xe \v CntTurn\:Katabatic}
{\xe \v Katabatic\:CntTurn}
{\qr CntTurn{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The object true class is {\b AutoContactTurn}, {\b must not be changed} . \par
}\cell }{\row }
{\xe \v CntHTee\:Katabatic}
{\xe \v Katabatic\:CntHTee}
{\qr CntHTee{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The object true class is {\b AutoContactHTee}, {\b must not be changed} . \par
}\cell }{\row }
{\xe \v CntVTee\:Katabatic}
{\xe \v Katabatic\:CntVTee}
{\qr CntVTee{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The object true class is {\b AutoContactVTee}, {\b must not be changed} . \par
}\cell }{\row }
{\xe \v CntInvalidated\:Katabatic}
{\xe \v Katabatic\:CntInvalidated}
{\qr CntInvalidated{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
At least one {\b AutoSegment} of this contact has been moved, the contact position must be recomputed (in the {\b Session} revalidation). \par
}\cell }{\row }
{\xe \v CntInvalidatedCache\:Katabatic}
{\xe \v Katabatic\:CntInvalidatedCache}
{\qr CntInvalidatedCache{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
At least one {\b AutoSegment} has been broken or moved up, the connexity must be checked and possibly corrected (in {\b Session} revalidation). \par
}\cell }{\row }
{\xe \v CntInCreationStage\:Katabatic}
{\xe \v Katabatic\:CntInCreationStage}
{\qr CntInCreationStage{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets only during the initial creation process. \par
}\cell }{\row }
{\xe \v CntBadTopology\:Katabatic}
{\xe \v Katabatic\:CntBadTopology}
{\qr CntBadTopology{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Something wrong has happened and the connexity of the {\b AutoContact} is no longer ensured (too much or too less AutoSegments, too wide span of {\b AutoSegment} layers). \par
}\cell }{\row }
}
}
{\xe \v AutoSegmentFlag\:Katabatic}
{\xe \v Katabatic\:AutoSegmentFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b AutoSegmentFlag}}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set of flags to describe the internal state of an {\b AutoSegment}. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v SegHorizontal\:Katabatic}
{\xe \v Katabatic\:SegHorizontal}
{\qr SegHorizontal{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This {\b AutoSegment} is associated to a {\b Hurricane::Horizontal}, if not set, it is associated to a {\b Hurricane::Vertical}. Set when the object is constructed. \par
}\cell }{\row }
{\xe \v SegFixed\:Katabatic}
{\xe \v Katabatic\:SegFixed}
{\qr SegFixed{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Hurricane::Segment} associated must/cannot be moved. \par
}\cell }{\row }
{\xe \v SegGlobal\:Katabatic}
{\xe \v Katabatic\:SegGlobal}
{\qr SegGlobal{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b AutoSegment} span between at least two GCells (i.e. not fully enclosed in one). \par
}\cell }{\row }
{\xe \v SegWeakGlobal\:Katabatic}
{\xe \v Katabatic\:SegWeakGlobal}
{\qr SegWeakGlobal{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b AutoSegment} is part of an aligned set which contains at least a global. The global segment is itself tagged as weak global. \par
}\cell }{\row }
{\xe \v SegCanonical\:Katabatic}
{\xe \v Katabatic\:SegCanonical}
{\qr SegCanonical{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This {\b AutoSegment} is the designated representant of a set of aligned {\b AutoSegment}. \par
}\cell }{\row }
{\xe \v SegBipoint\:Katabatic}
{\xe \v Katabatic\:SegBipoint}
{\qr SegBipoint{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This {\b AutoSegment} is a straight wire between two terminal {\b AutoContact}. \par
}\cell }{\row }
{\xe \v SegDogleg\:Katabatic}
{\xe \v Katabatic\:SegDogleg}
{\qr SegDogleg{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This {\b AutoSegment} has been created as the perpandicular part of a dogleg. \par
}\cell }{\row }
{\xe \v SegStrap\:Katabatic}
{\xe \v Katabatic\:SegStrap}
{\qr SegStrap{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This {\b AutoSegment} has been created to to reconnect parts of an {\b AutoSegment} after slackening. \par
}\cell }{\row }
{\xe \v SegSourceTop\:Katabatic}
{\xe \v Katabatic\:SegSourceTop}
{\qr SegSourceTop{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The source contact of this segment is connected to the {\i top}  layer. \par
}\cell }{\row }
{\xe \v SegSourceBottom\:Katabatic}
{\xe \v Katabatic\:SegSourceBottom}
{\qr SegSourceBottom{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The source contact of this segment is connected to the {\i bottom}  layer. \par
}\cell }{\row }
{\xe \v SegTargetTop\:Katabatic}
{\xe \v Katabatic\:SegTargetTop}
{\qr SegTargetTop{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The target contact of this segment is connected to the {\i top}  layer. \par
}\cell }{\row }
{\xe \v SegTargetBottom\:Katabatic}
{\xe \v Katabatic\:SegTargetBottom}
{\qr SegTargetBottom{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The target contact of this segment is connected to the {\i bottom}  layer. \par
}\cell }{\row }
{\xe \v SegIsReduced\:Katabatic}
{\xe \v Katabatic\:SegIsReduced}
{\qr SegIsReduced{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This segment is the perpandicular part of a dogleg which will use the {\i same}  layer as the parallels. \par
}\cell }{\row }
{\xe \v SegLayerChange\:Katabatic}
{\xe \v Katabatic\:SegLayerChange}
{\qr SegLayerChange{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This {\b AutoSegment} has been created to to reconnect parts of an {\b AutoSegment} after a layer change. \par
}\cell }{\row }
{\xe \v SegStrongTerminal\:Katabatic}
{\xe \v Katabatic\:SegStrongTerminal}
{\qr SegStrongTerminal{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This {\b AutoSegment} directly connected to a terminal. \par
}\cell }{\row }
{\xe \v SegWeakTerminal1\:Katabatic}
{\xe \v Katabatic\:SegWeakTerminal1}
{\qr SegWeakTerminal1{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This {\b AutoSegment} indirectly connected to a terminal with medium strength. \par
}\cell }{\row }
{\xe \v SegWeakTerminal2\:Katabatic}
{\xe \v Katabatic\:SegWeakTerminal2}
{\qr SegWeakTerminal2{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This {\b AutoSegment} indirectly connected to a terminal with weak strength. \par
}\cell }{\row }
{\xe \v SegNotSourceAligned\:Katabatic}
{\xe \v Katabatic\:SegNotSourceAligned}
{\qr SegNotSourceAligned{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This source contact of the segment is not the aligned part of a tee ({\f2 h1}  or {\f2 h2}  for a {\f2 HTee} , {\f2 v1}  or {\f2 v2}  for a {\f2 VTee} ).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid AutoSegmentFlag::SegNotAligned \par
}}\cell }{\row }
{\xe \v SegNotTargetAligned\:Katabatic}
{\xe \v Katabatic\:SegNotTargetAligned}
{\qr SegNotTargetAligned{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This target contact of the segment is not the aligned part of a tee ({\f2 h1}  or {\f2 h2}  for a {\f2 HTee} , {\f2 v1}  or {\f2 v2}  for a {\f2 VTee} ).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid AutoSegmentFlag::SegNotAligned \par
}}\cell }{\row }
{\xe \v SegSlackened\:Katabatic}
{\xe \v Katabatic\:SegSlackened}
{\qr SegSlackened{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This {\b AutoSegment} has been slackened, that is freed from any constraints from source or target through the insertion of straps. \par
}\cell }{\row }
{\xe \v SegAxisSet\:Katabatic}
{\xe \v Katabatic\:SegAxisSet}
{\qr SegAxisSet{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This {\b AutoSegment} has been explicitly positionned at least once. \par
}\cell }{\row }
{\xe \v SegInvalidated\:Katabatic}
{\xe \v Katabatic\:SegInvalidated}
{\qr SegInvalidated{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This position or topology of this {\b AutoSegment} has been changed, needing a revalidation. \par
}\cell }{\row }
{\xe \v SegInvalidatedLayer\:Katabatic}
{\xe \v Katabatic\:SegInvalidatedLayer}
{\qr SegInvalidatedLayer{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The segment has been chenged of layer, but the source & target {\b AutoContact} have not been topologicaly checked yet. This flag {\b must}  be used in whith AutoSegmentFlag::SegInvalidated. \par
}\cell }{\row }
{\xe \v SegCreated\:Katabatic}
{\xe \v Katabatic\:SegCreated}
{\qr SegCreated{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b AutoSegment} has just been created. This flag is set only from the contruction of the object until is {\i first}  revalidation. Used to disable some tests that cannot be satisfied initially. \par
}\cell }{\row }
{\xe \v SegWeakTerminal\:Katabatic}
{\xe \v Katabatic\:SegWeakTerminal}
{\qr SegWeakTerminal{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A mask composed of:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Katabatic::SegStrongTerminal}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Katabatic::SegWeakTerminal1}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Katabatic::SegWeakTerminal2} \par}
}\cell }{\row }
{\xe \v SegNotAligned\:Katabatic}
{\xe \v Katabatic\:SegNotAligned}
{\qr SegNotAligned{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A mask composed of:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Katabatic::SegNotSourceAligned}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Katabatic::SegNotTargetAligned}\par}
This mask is a quick way to know if a segment is {\b not}  part of an aligned set. It means that the segment is, on both ends, either connected to a terminal, a turn {\i or the stem part of a tee} . \par
}\cell }{\row }
}
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AutoContact Class Reference\par \pard\plain 
{\tc\tcl2 \v AutoContact}
{\xe \v AutoContact}
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract base class for {\b AutoContact}. }}\par
Inheritance diagram for AutoContact:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKatabatic_1_1AutoContact__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Hook} * {\b getBodyHook} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Hook} * {\b getAnchorHook} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Component} * {\b getAnchor} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Net} * {\b getNet} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Layer} * {\b getLayer} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getX} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getY} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getDx} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getDy} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Point} {\b getCenter} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Point} {\b getPosition} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getWidth} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getHalfWidth} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getHeight} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getHalfHeight} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Components} {\b getSlaveComponents} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLayer} (const {\b Layer} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setWidth} ({\b DbU::Unit})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setHeight} ({\b DbU::Unit})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSizes} ({\b DbU::Unit} width, {\b DbU::Unit} height)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setX} ({\b DbU::Unit})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setY} ({\b DbU::Unit})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPosition} ({\b DbU::Unit} width, {\b DbU::Unit} height)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPosition} (const {\b Point} &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setDx} ({\b DbU::Unit})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setDy} ({\b DbU::Unit})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setOffset} ({\b DbU::Unit} dx, {\b DbU::Unit} dy)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b translate} (const {\b DbU::Unit} &tx, const {\b DbU::Unit} &ty)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInCreationStage} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInvalidated} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInvalidatedCache} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isTurn} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isTee} (unsigned int direction) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isHTee} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isVTee} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isFixed} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasBadTopology} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b canDestroy} (unsigned int flags=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b canMoveUp} (const {\b AutoSegment} *moved) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Contact} * {\b base} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const {\b Name} & {\b getName} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getId} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Box} {\b getBoundingBox} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GCell} * {\b getGCell} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegment} * {\b getOpposite} (const {\b AutoSegment} *) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegment} * {\b getPerpandicular} (const {\b AutoSegment} *) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegment} * {\b getSegment} (unsigned int) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getMinDepth} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getMaxDepth} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getLengths} ({\b DbU::Unit} *lengths, AutoSegment::DepthLengthSet &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Box} {\b getNativeConstraintBox} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Interval} {\b getUConstraints} (unsigned int direction) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getCBXMin} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getCBXMax} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getCBYMin} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getCBYMax} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Box} {\b getConstraintBox} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Box} & {\b intersectConstraintBox} ({\b Box} &box) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b invalidate} (unsigned int flags=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateGeometry} ()=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateTopology} ()=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b showTopologyError} (const std::string &, unsigned int flags=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b checkTopology} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setGCell} ({\b GCell} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCBXMin} ({\b DbU::Unit} xMin)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCBXMax} ({\b DbU::Unit} xMax)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCBYMin} ({\b DbU::Unit} yMin)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCBYMax} ({\b DbU::Unit} yMax)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setConstraintBox} (const {\b Box} &box)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b restrictConstraintBox} ({\b DbU::Unit} constraintMin, {\b DbU::Unit} constraintMax, unsigned int flags={\b KbWarnOnError})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b migrateConstraintBox} ({\b AutoContact} *other)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static size_t {\b getAllocateds} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b Name} & {\b getStaticName} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b _getTopology} ({\b Contact} *, {\b Component} *&anchor, {\b Horizontal} **&, {\b Vertical} **&, size_t)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract base class for {\b AutoContact}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Caching Mechanism
\par}
{\tc\tcl2 \v Caching Mechanism}
To bypass the Ring/Hook mechanism {\i and}  the subsequent Session::Lookup() call, the AutoSegments anchored on an {\b AutoContact} are cached in the {\b AutoContact} itself. They can be accessed through {\f2 getHorizontalN()}  and getVerticalN() accessors {\f2 N}  depending on the subtype of {\b AutoContact}.\par
Cached AutoSegments are updated in the {\b AutoContact::updateTopology()} function only.\par}
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Invalidate on AutoContacts
\par}
{\tc\tcl2 \v Invalidate on AutoContacts}
The invalidation of an {\b AutoContact} invalidate all the segments that are anchored on it.\par
{\b Special Case of HTee & VTee} \par
When invalidating an HTee or VTee, two out of the three anchored segments are parallels. The {\i aligned}  constraint is passed on those two. By default, when we invalidate an {\b AutoSegment}, the invalidation is applied to the whole aligned set through the {\b AutoSegment::getAligneds()} collection. So if one of the parallel is invalidated and the other not, it should only be because we are already in {\f2 getAligneds()} , then we do not want to invalidate again the whole aligned set. In that case, we perform an atomic only invalidation (reset {\b Katabatic::KbPropagate}).\par
For the complete invalidation/revalidation mechanism see {\b Session Algorithm}.\par}
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Notes - Differences from Katabatic 2
\par}
{\tc\tcl2 \v Notes - Differences from Katabatic 2}
From the previous version of {\b Katabatic}, {\b AutoContact} have been greatly stripped down (again). They are now always punctual objetcs with stricly fixed topologies: {
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoContactTerminal} to connect to a terminal (one segment). \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoContactTurn} to make a turn: two perpandiculars segments. \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoContactHTee} an horizontal tee: two {\i aligned}  horizonals and one vertical. \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoContactVTee} an horizontal tee: two {\i aligned}  verticals and one horizontal. \par}
\par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getBodyHook\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getBodyHook}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Hook} * getBodyHook (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Component::getBodyHook().}\par
{
Referenced by GCellTopology::_do_xG_1Pad(), and AutoSegment::create().}\par
}
{\xe \v getAnchorHook\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getAnchorHook}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Hook} * getAnchorHook (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Contact::getAnchorHook().}\par
}
{\xe \v getAnchor\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getAnchor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Component} * getAnchor () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Contact::getAnchor().}\par
{
Referenced by AutoContactTerminal::getNativeConstraintBox(), and AutoContactTerminal::updateTopology().}\par
}
{\xe \v getNet\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getNet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Net} * getNet () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Component::getNet().}\par
{
Referenced by AutoContactVTee::updateGeometry(), AutoContactTurn::updateGeometry(), AutoContactHTee::updateGeometry(), AutoContactTerminal::updateGeometry(), AutoContactVTee::updateTopology(), AutoContactTurn::updateTopology(), AutoContactHTee::updateTopology(), and AutoContactTerminal::updateTopology().}\par
}
{\xe \v getLayer\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Layer} * getLayer () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Component::getLayer().}\par
{
Referenced by AutoSegment::makeDogleg(), AutoSegment::revalidate(), AutoContactVTee::updateTopology(), AutoContactTurn::updateTopology(), AutoContactHTee::updateTopology(), and AutoContactTerminal::updateTopology().}\par
}
{\xe \v getX\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getX () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Component::getX().}\par
{
Referenced by GCellTopology::_do_1G_1M3(), GCellTopology::_do_xG_xM3(), AutoSegment::create(), GCellTopology::doRp_StairCaseV(), AutoSegment::makeDogleg(), AutoContactVTee::updateGeometry(), AutoContactTurn::updateGeometry(), and AutoContactHTee::updateGeometry().}\par
}
{\xe \v getY\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getY () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Component::getY().}\par
{
Referenced by AutoSegment::create(), GCellTopology::doRp_StairCaseH(), AutoSegment::makeDogleg(), AutoContactVTee::updateGeometry(), AutoContactTurn::updateGeometry(), and AutoContactHTee::updateGeometry().}\par
}
{\xe \v getDx\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getDx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getDx () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Contact::getDx().}\par
}
{\xe \v getDy\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getDy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getDy () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Contact::getDy().}\par
}
{\xe \v getCenter\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getCenter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Point} getCenter () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}}
{\xe \v getPosition\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Point} getPosition () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Component::getPosition().}\par
}
{\xe \v getWidth\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getWidth () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Contact::getWidth().}\par
}
{\xe \v getHalfWidth\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getHalfWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getHalfWidth () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Contact::getHalfWidth().}\par
}
{\xe \v getHeight\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getHeight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getHeight () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Contact::getHeight().}\par
}
{\xe \v getHalfHeight\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getHalfHeight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getHalfHeight () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Contact::getHalfHeight().}\par
}
{\xe \v getSlaveComponents\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getSlaveComponents}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Components} getSlaveComponents () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Component::getSlaveComponents().}\par
}
{\xe \v setLayer\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:setLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setLayer (const {\b Layer} *  {\i layer}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Contact::setLayer().}\par
{
Referenced by AutoSegment::reduceDoglegLayer(), AutoContactVTee::updateTopology(), AutoContactTurn::updateTopology(), AutoContactHTee::updateTopology(), and AutoContactTerminal::updateTopology().}\par
}
{\xe \v setWidth\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:setWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setWidth ({\b DbU::Unit}  {\i w}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Contact::setWidth().}\par
}
{\xe \v setHeight\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:setHeight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setHeight ({\b DbU::Unit}  {\i h}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Contact::setHeight().}\par
}
{\xe \v setSizes\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:setSizes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setSizes ({\b DbU::Unit}  {\i w}, {\b DbU::Unit}  {\i h}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Contact::setSizes().}\par
}
{\xe \v setX\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:setX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setX ({\b DbU::Unit}  {\i x}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Contact::setX().}\par
{
Referenced by AutoVertical::_postCreate(), AutoContactVTee::updateGeometry(), AutoContactTurn::updateGeometry(), AutoContactHTee::updateGeometry(), and AutoContactTerminal::updateGeometry().}\par
}
{\xe \v setY\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:setY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setY ({\b DbU::Unit}  {\i y}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Contact::setY().}\par
{
Referenced by AutoHorizontal::_postCreate(), AutoContactVTee::updateGeometry(), AutoContactTurn::updateGeometry(), AutoContactHTee::updateGeometry(), and AutoContactTerminal::updateGeometry().}\par
}
{\xe \v setPosition\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:setPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setPosition ({\b DbU::Unit}  {\i w}, {\b DbU::Unit}  {\i h}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Contact::setPosition().}\par
}
{\xe \v setPosition\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:setPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setPosition (const {\b Point} &  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Contact::setPosition().}\par
}
{\xe \v setDx\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:setDx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setDx ({\b DbU::Unit}  {\i dx}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Contact::setDx().}\par
}
{\xe \v setDy\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:setDy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setDy ({\b DbU::Unit}  {\i dy}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Contact::setDy().}\par
}
{\xe \v setOffset\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:setOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setOffset ({\b DbU::Unit}  {\i w}, {\b DbU::Unit}  {\i h}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}{
References Contact::setOffset().}\par
}
{\xe \v translate\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:translate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void translate (const {\b DbU::Unit} &  {\i dx}, const {\b DbU::Unit} &  {\i dy}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Base class method proxy.}  \par
}}
{\xe \v isInCreationStage\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:isInCreationStage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isInCreationStage () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the {\b AutoContact} is still in it's initial creation stage. \par
}{
References Katabatic::CntInCreationStage.}\par
}
{\xe \v isInvalidated\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:isInvalidated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isInvalidated () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the some {\b AutoSegment} has changed and the {\b AutoContact} needs to be repositionned (through a call to {\b AutoContact::updateGeometry()}). \par
}{
References Katabatic::CntInvalidated.}\par
}
{\xe \v isInvalidatedCache\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:isInvalidatedCache}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isInvalidatedCache () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the some {\b AutoSegment} has changed and the {\b AutoContact} topology needs to be restored, as a gap may have appeared (through a call to AutoSegment::updateTopology()). \par
}{
References Katabatic::CntInvalidatedCache.}\par
{
Referenced by AutoContactVTee::updateGeometry(), AutoContactTurn::updateGeometry(), AutoContactHTee::updateGeometry(), AutoContactTerminal::updateGeometry(), AutoContactVTee::updateTopology(), AutoContactTurn::updateTopology(), AutoContactHTee::updateTopology(), and AutoContactTerminal::updateTopology().}\par
}
{\xe \v isTurn\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:isTurn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isTurn () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the dynamic type of the {\b AutoContact} is of type Turn. \par
}{
References Katabatic::CntTurn.}\par
{
Referenced by AutoSegment::canReduce(), and AutoSegment::revalidate().}\par
}
{\xe \v isTee\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:isTee}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isTee (unsigned int  {\i direction}) const}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the dynamic type of the {\b AutoContact} is either of type {\b AutoContactHTee} or {\b AutoContactVTee}, according to {\f2 direction} . \par
}{
References Katabatic::KbHorizontal, and Katabatic::KbVertical.}\par
}
{\xe \v isHTee\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:isHTee}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isHTee () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the dynamic type of the {\b AutoContact} is of type {\b AutoContactHTee}. \par
}{
References Katabatic::CntHTee.}\par
}
{\xe \v isVTee\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:isVTee}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isVTee () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the dynamic type of the {\b AutoContact} is of type {\b AutoContactHTee}. \par
}{
References Katabatic::CntVTee.}\par
}
{\xe \v isFixed\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:isFixed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isFixed () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the {\b AutoContact} cannot be moved. \par
}{
References Katabatic::CntFixed.}\par
{
Referenced by AutoSegment::create(), AutoContact::getCBXMax(), AutoContact::getCBXMin(), AutoContact::getCBYMax(), and AutoContact::getCBYMin().}\par
}
{\xe \v hasBadTopology\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:hasBadTopology}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool hasBadTopology () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the {\b AutoContact} topology has been broken and a gap has appeared. (sould not happen...) \par
}{
References Katabatic::CntBadTopology.}\par
{
Referenced by AutoContactVTee::updateGeometry(), AutoContactTurn::updateGeometry(), AutoContactHTee::updateGeometry(), AutoContactTerminal::updateGeometry(), AutoContactVTee::updateTopology(), AutoContactTurn::updateTopology(), and AutoContactHTee::updateTopology().}\par
}
{\xe \v canDestroy\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:canDestroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool canDestroy (unsigned int  {\i flags} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the {\b AutoContact} could be destroyed, that is, no segments remains anchored on it. If {\f2 flags}  contains {\b Katabatic::KbWarnOnError}, issue an error message. \par
}{
References Katabatic::KbWarnOnError.}\par
}
{\xe \v canMoveUp\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:canMoveUp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool canMoveUp (const {\b AutoSegment} *  {\i moved}) const}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if {\f2 segment}  can be moved up without triggering a topological modification. It meaans that:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Without {\f2 moved} , the {\b AutoContact} needs only one layer.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 moved}  go from {\i below}  the {\b AutoContact} to {\i above} . \par}
}{
References Component::getLayer(), AutoSegment::getLayer(), and RoutingGauge::getLayerDepth().}\par
}
{\xe \v base\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Contact} * base () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b Hurricane::Contact} which is decorated. \par
}{
Referenced by AutoVertical::_makeDogleg(), AutoSegment::create(), AutoSegment::getOppositeAnchor(), GCell::removeContact(), AutoContactVTee::updateGeometry(), AutoContactTurn::updateGeometry(), AutoContactHTee::updateGeometry(), and AutoContactTerminal::updateGeometry().}\par
}
{\xe \v getAllocateds\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getAllocateds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getAllocateds (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The total number of {\b AutoContact} currently allocateds. \par
}}
{\xe \v getStaticName\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getStaticName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Name} & getStaticName (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The name of the Hurricane::ExtensionGo slice. \par
}}
{\xe \v getName\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Name} & getName () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The name of the Hurricane::ExtensionGo slice. \par
}}
{\xe \v getId\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Name} & getId () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The unique {\f2 identifer}  of the {\b AutoSegment}. \par
}}
{\xe \v getBoundingBox\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getBoundingBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Box} getBoundingBox () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Contact::getBoundingBox()}. \par
}}}
{\xe \v getGCell\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getGCell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GCell} * getGCell () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b GCell} into which the {\b AutoContact} is located. \par
}{
Referenced by AutoHorizontal::_canSlacken(), AutoVertical::_canSlacken(), AutoHorizontal::_makeDogleg(), AutoVertical::_makeDogleg(), AutoHorizontal::_postCreate(), AutoVertical::_postCreate(), AutoHorizontal::_preDestroy(), AutoVertical::_preDestroy(), AutoSegment::AutoSegment(), AutoHorizontal::canMoveULeft(), AutoVertical::canMoveULeft(), AutoHorizontal::canMoveURight(), AutoVertical::canMoveURight(), AutoHorizontal::getGCells(), AutoVertical::getGCells(), AutoSegment::makeDogleg(), AutoHorizontal::moveULeft(), AutoVertical::moveULeft(), AutoHorizontal::moveURight(), AutoVertical::moveURight(), and AutoSegment::toConstraintAxis().}\par
}
{\xe \v getOpposite\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getOpposite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * getOpposite (const {\b AutoSegment} *  {\i reference}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The other {\b AutoSegment} the {\i same}  direction as {\f2 reference} , this is only meaningful on {\b AutoContactHTee} or {\b AutoContactVTee}. If there is no opposite, {\f2 NULL}  is returned. \par
}{
Implemented in {\b AutoContactTerminal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFZ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b AutoContactHTee} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGA \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b AutoContactTurn} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGB \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoContactVTee} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getPerpandicular\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getPerpandicular}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * getPerpandicular (const {\b AutoSegment} *  {\i reference}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} in the {\i perpandicular}  direction to {\f2 reference} , this is only meaningful on AutoContacTurn. It there is no unique perpandicular, {\f2 NULL}  is returned. \par
}{
Implemented in {\b AutoContactTerminal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGE \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b AutoContactHTee} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGF \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b AutoContactTurn} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGG \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoContactVTee} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by AutoSegment::raise(), AutoSegment::reduce(), and AutoSegment::revalidate().}\par
}
{\xe \v getSegment\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * getSegment (unsigned int  {\i index}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The nth anchored {\b AutoSegment}. The index is significant:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b 0}  : first horizontal ({\b h1} ).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b 1}  : second horizontal ({\b h2} ).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b 2}  : first vertical ({\b b1} ).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b 3}  : second vertical ({\b b2} ).\par}
Not all the indexes are filled for every {\b AutoContact}. For example {\f2 Turn}  have {\b h1}  and {\b b1} , and {\f2 HTee}  have {\b h1} , {\b h2}  and {\b v1} . \par
}{
Implemented in {\b AutoContactTerminal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b AutoContactHTee} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b AutoContactTurn} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGL \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoContactVTee} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by AutoHorizontal::canMoveULeft(), AutoVertical::canMoveULeft(), AutoHorizontal::canMoveURight(), AutoVertical::canMoveURight(), LocatorHelper::getSegment(), LocatorHelper::LocatorHelper(), AutoHorizontal::moveULeft(), AutoVertical::moveULeft(), AutoHorizontal::moveURight(), AutoVertical::moveURight(), and LocatorHelper::progress().}\par
}
{\xe \v getMinDepth\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getMinDepth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getMinDepth () const}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The layer depth of the bottom layer of the {\b AutoContact}. \par
}{
References Component::getLayer().}\par
{
Referenced by AutoSegment::canPivotUp().}\par
}
{\xe \v getMaxDepth\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getMaxDepth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getMaxDepth () const}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The layer depth of the top layer of the {\b AutoContact}. \par
}{
References Component::getLayer().}\par
{
Referenced by AutoSegment::canPivotDown().}\par
}
{\xe \v getLengths\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getLengths}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void getLengths ({\b DbU::Unit} *  {\i lengths}, AutoSegment::DepthLengthSet &  {\i processeds})}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lengths} \cell }{A table of {\b DbU::Unit}, the size of all routing layers used. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i processeds} \cell }{An {\b AutoSegment} sorted set holding all the already processeds AutoSegments.\cell }
{\row }
}
Compute the lengths over the owning {\b GCell} of all the AutoSegments anchored on this {\b AutoContact}. The lengths are added to the total length table {\f2 lengths} . To avoid double accounting of the local AutoSegments that have both source & target in the same {\b GCell}, we keep a set of already processeds AutoSegments in {\f2 processeds} . \par
}{
References Katabatic::KbHorizontal, Katabatic::KbVertical, and toLambda().}\par
}
{\xe \v getNativeConstraintBox\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getNativeConstraintBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Box} getNativeConstraintBox () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The native constraint box (that is, whithout any user constraints applied). For {\b AutoContactTerminal}, this is the Box of the supporting external component, and for all others the bounding box of the owning {\b GCell}. \par
}{
Reimplemented in {\b AutoContactTerminal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getUConstraints\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getUConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getUConstraints (unsigned int  {\i direction}) const}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The constraint interval in {\f2 direction}  (that is, the relevant side of the constraint box). \par
}{
References Interval::inflate(), and Katabatic::KbHorizontal.}\par
{
Referenced by AutoContactTerminal::updateGeometry().}\par
}
{\xe \v getCBXMin\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getCBXMin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getCBXMin () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The X coordinate of the bottom left corner of the constraint box. \par
}{
References DbU::fromLambda(), Component::getX(), GCell::getX(), and AutoContact::isFixed().}\par
{
Referenced by AutoContact::getConstraintBox(), and AutoVertical::getConstraints().}\par
}
{\xe \v getCBXMax\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getCBXMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getCBXMax () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The X coordinate of the top right corner of the constraint box. \par
}{
References DbU::fromLambda(), Component::getX(), GCell::getX(), and AutoContact::isFixed().}\par
{
Referenced by AutoContact::getConstraintBox(), and AutoVertical::getConstraints().}\par
}
{\xe \v getCBYMin\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getCBYMin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getCBYMin () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The Y coordinate of the bottom left corner of the constraint box. \par
}{
References DbU::fromLambda(), Component::getY(), GCell::getY(), and AutoContact::isFixed().}\par
{
Referenced by AutoContact::getConstraintBox(), and AutoHorizontal::getConstraints().}\par
}
{\xe \v getCBYMax\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getCBYMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getCBYMax () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The Y coordinate of the top right corner of the constraint box. \par
}{
References DbU::fromLambda(), Component::getY(), GCell::getY(), and AutoContact::isFixed().}\par
{
Referenced by AutoContact::getConstraintBox(), and AutoHorizontal::getConstraints().}\par
}
{\xe \v getConstraintBox\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:getConstraintBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Box} getConstraintBox () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The current constraint box: the native constraint box with all the user's contraints applieds. \par
}{
References AutoContact::getCBXMax(), AutoContact::getCBXMin(), AutoContact::getCBYMax(), and AutoContact::getCBYMin().}\par
{
Referenced by AutoSegment::computeOptimal(), and AutoContact::migrateConstraintBox().}\par
}
{\xe \v intersectConstraintBox\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:intersectConstraintBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Box} & intersectConstraintBox ({\b Box} &  {\i box}) const}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The intersection between {\f2 box}  and the constraint box. The result is stored into {\f2 box}  and a reference to it is returned. \par
}{
References Box::getIntersection().}\par
}
{\xe \v invalidate\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:invalidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void invalidate (unsigned int  {\i flags} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Invalidate the {\b AutoContact}, schedule it for revalidation in the {\b Session}. If flag containt Katabatic::CntInvalidTopology, the topology of the {\b AutoContact} will also be checked and possible gap closeds.\par
The revalidations methods associated are:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoSegment::updateGeometry(), recompute the punctual contact position.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoSegment::updateTopology(), restore the connexity. \par}
}{
References Katabatic::CntInvalidated, and Katabatic::CntInvalidatedCache.}\par
{
Referenced by AutoHorizontal::_makeDogleg(), AutoVertical::_makeDogleg(), and AutoSegment::AutoSegment().}\par
}
{\xe \v updateGeometry\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:updateGeometry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateGeometry (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute the new position of the {\b AutoContact} based on the {\b AutoSegment} positions. The {\b Session} mechanism ensure that all {\b AutoSegment} are set into their final positions before calling this updator. \par
}{
Implemented in {\b AutoContactTerminal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHB \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b AutoContactHTee} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHC \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b AutoContactTurn} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHD \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoContactVTee} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v updateTopology\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:updateTopology}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateTopology (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Modificate the {\b AutoContact} topology to close any gap. This could be by changing layer or creating a new dogleg on an incident {\b AutoSegment}. \par
}{
Implemented in {\b AutoContactTerminal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHG \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b AutoContactHTee} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHH \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b AutoContactTurn} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHI \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoContactVTee} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v showTopologyError\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:showTopologyError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void showTopologyError (const std::string &  {\i message}, unsigned int  {\i flags} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Comprensive display of the topology of the {\b AutoContact} to ease the debug work. Prepend with the error message {\f2 message} . Do no throw an error. \par
}{
References AutoSegment::isGlobal().}\par
{
Referenced by AutoContactTerminal::updateGeometry(), AutoContactVTee::updateTopology(), AutoContactTurn::updateTopology(), AutoContactHTee::updateTopology(), and AutoContactTerminal::updateTopology().}\par
}
{\xe \v checkTopology\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:checkTopology}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void checkTopology (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check for topology correctness (no gaps), display an error message if needed. \par
}}
{\xe \v setGCell\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:setGCell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setGCell ({\b GCell} *  {\i gcell})}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the owning {\b GCell}. \par
}{
References GCell::addContact(), and toLambda().}\par
{
Referenced by AutoHorizontal::moveULeft(), AutoVertical::moveULeft(), AutoHorizontal::moveURight(), and AutoVertical::moveURight().}\par
}
{\xe \v setCBXMin\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:setCBXMin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setCBXMin ({\b DbU::Unit}  {\i xMin}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the lower left X coordinate of the constraint box.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: It cannot go outside the GCell bounding box. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}{
References GCell::getX().}\par
}
{\xe \v setCBXMax\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:setCBXMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setCBXMax ({\b DbU::Unit}  {\i xMax}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the upper right X coordinate of the constraint box.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: It cannot go outside the GCell bounding box. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}{
References GCell::getX(), and GCell::getXMax().}\par
}
{\xe \v setCBYMin\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:setCBYMin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setCBYMin ({\b DbU::Unit}  {\i yMin}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the lower left Y coordinate of the constraint box.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: It cannot go outside the GCell bounding box. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}{
References GCell::getY().}\par
}
{\xe \v setCBYMax\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:setCBYMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setCBYMax ({\b DbU::Unit}  {\i yMax}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the upper right Y coordinate of the constraint box.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: It cannot go outside the GCell bounding box. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}{
References GCell::getY(), and GCell::getYMax().}\par
}
{\xe \v setConstraintBox\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:setConstraintBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setConstraintBox (const {\b Box} &  {\i box})}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the constraint box.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: It cannot go outside the GCell bounding box. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}{
References Box::getXMax(), Box::getXMin(), Box::getYMax(), and Box::getYMin().}\par
}
{\xe \v restrictConstraintBox\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:restrictConstraintBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool restrictConstraintBox ({\b DbU::Unit}  {\i min}, {\b DbU::Unit}  {\i max}, unsigned int  {\i flags} = {\f2 {\b KbWarnOnError}})}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i min} \cell }{The minimum of the restriction interval. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i max} \cell }{The maximum of the restriction interval. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i flags} \cell }{Gives the direction of the restriction. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b true}  if the restriction was actually applied.\par
}Restrict the current constraint box but check if the restriction will not lead to an empty interval, in that case, do nothing and return {\b false} . \par
}{
References Katabatic::KbHorizontal, Katabatic::KbVertical, Katabatic::KbWarnOnError, and toLambda().}\par
}
{\xe \v migrateConstraintBox\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:migrateConstraintBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void migrateConstraintBox ({\b AutoContact} *  {\i other})}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Transfer the user constraint box from {\f2 other}  to the current object {\f2 this} . The constraints of {\f2 other}  are restored to their native values. The two contacts must belong to the same {\b GCell} for this method to take effect. \par
}{
References AutoContact::getConstraintBox().}\par
{
Referenced by AutoHorizontal::_makeDogleg(), and AutoVertical::_makeDogleg().}\par
}
{\xe \v _getTopology\:Katabatic::AutoContact}
{\xe \v Katabatic::AutoContact\:_getTopology}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _getTopology ({\b Contact} *  {\i support}, {\b Component} *&  {\i anchor}, {\b Horizontal} **&  {\i horizontals}, {\b Vertical} **&  {\i verticals}, size_t  {\i size}){\f2 [static]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i anchor} \cell }{The anchor, if any. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i hs} \cell }{The {\b Hurricane::Horizontal} anchored. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vs} \cell }{The {\b Hurricane::Vertical} anchored. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sz} \cell }{The size of boths {\f2 hs}  & {\f2 vs}  table passed as arguments.\cell }
{\row }
}
Fill {\f2 anchor}  , {\f2 hs}  and {\f2 vs}  with the components anchored on this {\b AutoContact}. \par
}{
References Contact::getAnchor(), and Component::getSlaveComponents().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoContact.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoContact.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoContact.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AutoContactHTee Class Reference\par \pard\plain 
{\tc\tcl2 \v AutoContactHTee}
{\xe \v AutoContactHTee}
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AutoContact} H-Tee (two H, one V) }}\par
Inheritance diagram for AutoContactHTee:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKatabatic_1_1AutoContactHTee__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegment} * {\b getOpposite} (const {\b AutoSegment} *) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegment} * {\b getPerpandicular} (const {\b AutoSegment} *) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegment} * {\b getSegment} (unsigned int) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateGeometry} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateTopology} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b AutoContactHTee} * {\b create} ({\b GCell} *, {\b Net} *, const {\b Layer} *)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AutoContact} H-Tee (two H, one V) \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AutoContact} to build an horizontal tee (two H, one V). \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v create\:Katabatic::AutoContactHTee}
{\xe \v Katabatic::AutoContactHTee\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoContactHTee} * create ({\b GCell} *  {\i gcell}, {\b Net} *  {\i net}, const {\b Layer} *  {\i layer}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i gcell} \cell }{The {\b GCell} into which create the {\b AutoContact}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i net} \cell }{The Net to which this {\b AutoContact} belongs. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i layer} \cell }{The Layer of the {\b AutoContact}. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The created {\b AutoContactHTee}.\par
}Create a new {\b AutoContactHTee}. \par
}{
References Katabatic::CntInCreationStage, and Contact::create().}\par
{
Referenced by GCellTopology::_do_xG(), GCellTopology::_do_xG_1M1_1M2(), and GCellTopology::_do_xG_xM1_xM3().}\par
}
{\xe \v getOpposite\:Katabatic::AutoContactHTee}
{\xe \v Katabatic::AutoContactHTee\:getOpposite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * getOpposite (const {\b AutoSegment} *  {\i reference}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The other {\b AutoSegment} the {\i same}  direction as {\f2 reference} , this is only meaningful on {\b AutoContactHTee} or {\b AutoContactVTee}. If there is no opposite, {\f2 NULL}  is returned. \par
}{
Implements {\b AutoContact} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getPerpandicular\:Katabatic::AutoContactHTee}
{\xe \v Katabatic::AutoContactHTee\:getPerpandicular}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * getPerpandicular (const {\b AutoSegment} *  {\i reference}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} in the {\i perpandicular}  direction to {\f2 reference} , this is only meaningful on AutoContacTurn. It there is no unique perpandicular, {\f2 NULL}  is returned. \par
}{
Implements {\b AutoContact} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getSegment\:Katabatic::AutoContactHTee}
{\xe \v Katabatic::AutoContactHTee\:getSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * getSegment (unsigned int  {\i index}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The nth anchored {\b AutoSegment}. The index is significant:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b 0}  : first horizontal ({\b h1} ).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b 1}  : second horizontal ({\b h2} ).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b 2}  : first vertical ({\b b1} ).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b 3}  : second vertical ({\b b2} ).\par}
Not all the indexes are filled for every {\b AutoContact}. For example {\f2 Turn}  have {\b h1}  and {\b b1} , and {\f2 HTee}  have {\b h1} , {\b h2}  and {\b v1} . \par
}{
Implements {\b AutoContact} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v updateGeometry\:Katabatic::AutoContactHTee}
{\xe \v Katabatic::AutoContactHTee\:updateGeometry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateGeometry (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute the new position of the {\b AutoContact} based on the {\b AutoSegment} positions. The {\b Session} mechanism ensure that all {\b AutoSegment} are set into their final positions before calling this updator. \par
}{
Implements {\b AutoContact} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoContact::base(), DebugSession::close(), Katabatic::CntInvalidated, AutoContact::getNet(), AutoContact::getX(), AutoContact::getY(), AutoContact::hasBadTopology(), Go::invalidate(), AutoContact::isInvalidatedCache(), DebugSession::open(), AutoContact::setX(), and AutoContact::setY().}\par
}
{\xe \v updateTopology\:Katabatic::AutoContactHTee}
{\xe \v Katabatic::AutoContactHTee\:updateTopology}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateTopology (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restore the topology (i.e. connexity) of the contact after any number of connected segments has changed layer (at least one, up to three).\par
For any configuration, the connexity can be restored by making only one dogleg.\par
We distinguish two kind of layer changes:{
\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab The two horizontals ({\f2 h1}  and {\f2 h2} ) are still on the same layer (either they both moved or the vertical only has moved, see figures 2 & 4). In that case, the dogleg is made on the vertical.\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab The two horizontals no longer are on the same layer (figures 1 & 3). In that case, the dogleg is made on the horizontal which is at the greater distance (in a layer sense) from the vertical.\par}
 \par
}{
Implements {\b AutoContact} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References DebugSession::close(), Katabatic::CntBadTopology, RoutingGauge::getContactLayer(), AutoContact::getLayer(), RoutingGauge::getLayerDepth(), AutoContact::getNet(), Session::getRoutingGauge(), RoutingGauge::getRoutingLayer(), AutoContact::hasBadTopology(), AutoContact::isInvalidatedCache(), DebugSession::open(), AutoContact::setLayer(), and AutoContact::showTopologyError().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoContactHTee.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoContactHTee.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoContactHTee.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AutoContactTerminal Class Reference\par \pard\plain 
{\tc\tcl2 \v AutoContactTerminal}
{\xe \v AutoContactTerminal}
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AutoContact} Terminal (S/T is a Terminal) }}\par
Inheritance diagram for AutoContactTerminal:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKatabatic_1_1AutoContactTerminal__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Box} {\b getNativeConstraintBox} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegment} * {\b getSegment} (unsigned int) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegment} * {\b getOpposite} (const {\b AutoSegment} *) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegment} * {\b getPerpandicular} (const {\b AutoSegment} *) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateGeometry} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateTopology} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b AutoContactTerminal} * {\b create} ({\b GCell} *gcell, {\b Component} *anchor, const {\b Layer} *layer, {\b Point} point, {\b DbU::Unit} width, {\b DbU::Unit} height)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b AutoContactTerminal} * {\b create} ({\b GCell} *gcell, {\b Component} *anchor, const {\b Layer} *layer, const {\b DbU::Unit} dx, const {\b DbU::Unit} dy, const {\b DbU::Unit} width, const {\b DbU::Unit} height)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AutoContact} Terminal (S/T is a Terminal) \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AutoContact} that are directly attached by either source or target or both to a terminal. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v create\:Katabatic::AutoContactTerminal}
{\xe \v Katabatic::AutoContactTerminal\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoContactTerminal} * create ({\b GCell} *  {\i gcell}, {\b Component} *  {\i rp}, const {\b Layer} *  {\i layer}, {\b Point}  {\i point}, {\b DbU::Unit}  {\i width}, {\b DbU::Unit}  {\i height}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i gcell} \cell }{The {\b GCell} into which create the {\b AutoContact}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rp} \cell }{The RoutingPad on which to anchor the {\b AutoContact}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i layer} \cell }{The Layer of the {\b AutoContact}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i point} \cell }{The absolute position. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i width} \cell }{The width of the {\b AutoContact}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i height} \cell }{The height of the {\b AutoContact}. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The created {\b AutoContact}.\par
}Create a new {\b AutoContactTerminal} anchored on {\f2 rp} . {\f2 point}  gives the {\i absolute}  position. \par
}{
References Hook::detach(), and Component::getBodyHook().}\par
{
Referenced by GCellTopology::doRp_AccessPad(), and GCellTopology::doRp_AutoContacts().}\par
}
{\xe \v create\:Katabatic::AutoContactTerminal}
{\xe \v Katabatic::AutoContactTerminal\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoContactTerminal} * create ({\b GCell} *  {\i gcell}, {\b Component} *  {\i rp}, const {\b Layer} *  {\i layer}, const {\b DbU::Unit}  {\i x}, const {\b DbU::Unit}  {\i y}, const {\b DbU::Unit}  {\i width}, const {\b DbU::Unit}  {\i height}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i gcell} \cell }{The {\b GCell} into which create the {\b AutoContact}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rp} \cell }{The Component on which to anchor the {\b AutoContact}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i layer} \cell }{The Layer of the {\b AutoContact}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i x} \cell }{The absolute X position. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i y} \cell }{The absolute Y position. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i width} \cell }{The width of the {\b AutoContact}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i height} \cell }{The height of the {\b AutoContact}. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The created {\b AutoContact}.\par
}Create a new {\b AutoContactTerminal} anchored on {\f2 rp} . {\f2 (x,y)}  gives the {\i absolute}  position.\par
The anchor component {\f2 rp}  is most often a {\b Hurricane::RoutingPad} (occurrencing a {\b Hurricane::Segment}) or directly a {\b Hurricane::Segment}, in case of RoutingPad layer promotion. \par
}{
References Katabatic::CntInCreationStage, Contact::create(), Component::getPosition(), and DbU::getValueString().}\par
}
{\xe \v getNativeConstraintBox\:Katabatic::AutoContactTerminal}
{\xe \v Katabatic::AutoContactTerminal\:getNativeConstraintBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Box} getNativeConstraintBox () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The native constraint box (that is, whithout any user constraints applied). For {\b AutoContactTerminal}, this is the Box of the supporting external component, and for all others the bounding box of the owning {\b GCell}. \par
}{
Reimplemented from {\b AutoContact} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoContact::getAnchor(), GCell::getBoundingBox(), Occurrence::getEntity(), RoutingPad::getOccurrence(), Transformation::getOrientation(), Occurrence::getPath(), Component::getPosition(), RoutingPad::getSourcePosition(), Segment::getSourcePosition(), RoutingPad::getTargetPosition(), Segment::getTargetPosition(), Path::getTransformation(), and DbU::getValueString().}\par
}
{\xe \v getSegment\:Katabatic::AutoContactTerminal}
{\xe \v Katabatic::AutoContactTerminal\:getSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * getSegment (unsigned int  {\i index}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The nth anchored {\b AutoSegment}. The index is significant:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b 0}  : first horizontal ({\b h1} ).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b 1}  : second horizontal ({\b h2} ).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b 2}  : first vertical ({\b b1} ).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b 3}  : second vertical ({\b b2} ).\par}
Not all the indexes are filled for every {\b AutoContact}. For example {\f2 Turn}  have {\b h1}  and {\b b1} , and {\f2 HTee}  have {\b h1} , {\b h2}  and {\b v1} . \par
}{
Implements {\b AutoContact} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoSegment::isHorizontal(), and AutoSegment::isVertical().}\par
}
{\xe \v getOpposite\:Katabatic::AutoContactTerminal}
{\xe \v Katabatic::AutoContactTerminal\:getOpposite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * getOpposite (const {\b AutoSegment} *  {\i reference}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The other {\b AutoSegment} the {\i same}  direction as {\f2 reference} , this is only meaningful on {\b AutoContactHTee} or {\b AutoContactVTee}. If there is no opposite, {\f2 NULL}  is returned. \par
}{
Implements {\b AutoContact} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getPerpandicular\:Katabatic::AutoContactTerminal}
{\xe \v Katabatic::AutoContactTerminal\:getPerpandicular}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * getPerpandicular (const {\b AutoSegment} *  {\i reference}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} in the {\i perpandicular}  direction to {\f2 reference} , this is only meaningful on AutoContacTurn. It there is no unique perpandicular, {\f2 NULL}  is returned. \par
}{
Implements {\b AutoContact} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v updateGeometry\:Katabatic::AutoContactTerminal}
{\xe \v Katabatic::AutoContactTerminal\:updateGeometry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateGeometry (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute the new position of the {\b AutoContact} based on the {\b AutoSegment} positions. The {\b Session} mechanism ensure that all {\b AutoSegment} are set into their final positions before calling this updator. \par
}{
Implements {\b AutoContact} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoContact::base(), DebugSession::close(), Katabatic::CntInvalidated, Interval::contains(), AutoContact::getNet(), AutoContact::getUConstraints(), DbU::getValueString(), AutoSegment::getX(), AutoSegment::getY(), AutoContact::hasBadTopology(), Go::invalidate(), AutoSegment::isCreated(), AutoSegment::isHorizontal(), AutoContact::isInvalidatedCache(), Katabatic::KbHorizontal, Katabatic::KbVertical, DebugSession::open(), AutoContact::setX(), AutoContact::setY(), and AutoContact::showTopologyError().}\par
}
{\xe \v updateTopology\:Katabatic::AutoContactTerminal}
{\xe \v Katabatic::AutoContactTerminal\:updateTopology}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateTopology (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restore the topology (i.e. connexity) of the contact after the incident segment has changed layer.\par
Based on the layer depth delta between the terminal and the segment three case can occurs:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The delta is {\b zero} , then just sets the layer of the contact to the common metal layer.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The delta is {\b one} , then sets the contact layer to VIA connecting the two layers.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The delta is {\b two} , then create a dogleg to restore the connexity. Depending on whether the terminal was attached to the source or target, sets the layer of the segments.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
A delta of more than {\b two}  is an error, and must never occurs.\par}
As, by default, the perpandicular is set in the layer above the parallel, it may be necessary to adjust his layer as well (to the one below).\par
 \par
}{
Implements {\b AutoContact} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References DebugSession::close(), Katabatic::CntBadTopology, AutoContact::getAnchor(), RoutingGauge::getContactLayer(), AutoContact::getLayer(), AutoSegment::getLayer(), RoutingGauge::getLayerDepth(), AutoContact::getNet(), Session::getRoutingGauge(), RoutingGauge::getRoutingLayer(), AutoSegment::invalidate(), AutoContact::isInvalidatedCache(), AutoSegment::makeDogleg(), DebugSession::open(), AutoContact::setLayer(), and AutoContact::showTopologyError().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoContactTerminal.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoContactTerminal.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoContactTerminal.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AutoContactTurn Class Reference\par \pard\plain 
{\tc\tcl2 \v AutoContactTurn}
{\xe \v AutoContactTurn}
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AutoContact} Turn (one H, one V) }}\par
Inheritance diagram for AutoContactTurn:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKatabatic_1_1AutoContactTurn__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegment} * {\b getOpposite} (const {\b AutoSegment} *) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegment} * {\b getPerpandicular} (const {\b AutoSegment} *) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegment} * {\b getSegment} (unsigned int) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateGeometry} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateTopology} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b AutoContactTurn} * {\b create} ({\b GCell} *, {\b Net} *, const {\b Layer} *)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AutoContact} Turn (one H, one V) \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AutoContact} to make a turn (one H, one V). \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v create\:Katabatic::AutoContactTurn}
{\xe \v Katabatic::AutoContactTurn\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoContactTurn} * create ({\b GCell} *  {\i gcell}, {\b Net} *  {\i net}, const {\b Layer} *  {\i layer}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i gcell} \cell }{The {\b GCell} into which create the {\b AutoContact}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i net} \cell }{The Net to which this {\b AutoContact} belongs. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i layer} \cell }{The Layer of the {\b AutoContact}. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The created {\b AutoContactTurn}.\par
}Create a new {\b AutoContactTurn}. \par
}{
References Katabatic::CntInCreationStage, and Contact::create().}\par
{
Referenced by GCellTopology::_do_1G_1M3(), GCellTopology::_do_1G_xM1(), GCellTopology::_do_xG(), GCellTopology::_do_xG_1M1_1M2(), GCellTopology::_do_xG_1Pad(), GCellTopology::_do_xG_xM1_xM3(), GCellTopology::_do_xG_xM3(), AutoHorizontal::_makeDogleg(), AutoVertical::_makeDogleg(), GCellTopology::doRp_Access(), GCellTopology::doRp_StairCaseH(), GCellTopology::doRp_StairCaseV(), and anonymous_namespace\{LoadGrByNet.cpp\}::singleGCell().}\par
}
{\xe \v getOpposite\:Katabatic::AutoContactTurn}
{\xe \v Katabatic::AutoContactTurn\:getOpposite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * getOpposite (const {\b AutoSegment} *  {\i reference}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The other {\b AutoSegment} the {\i same}  direction as {\f2 reference} , this is only meaningful on {\b AutoContactHTee} or {\b AutoContactVTee}. If there is no opposite, {\f2 NULL}  is returned. \par
}{
Implements {\b AutoContact} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getPerpandicular\:Katabatic::AutoContactTurn}
{\xe \v Katabatic::AutoContactTurn\:getPerpandicular}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * getPerpandicular (const {\b AutoSegment} *  {\i reference}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} in the {\i perpandicular}  direction to {\f2 reference} , this is only meaningful on AutoContacTurn. It there is no unique perpandicular, {\f2 NULL}  is returned. \par
}{
Implements {\b AutoContact} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getSegment\:Katabatic::AutoContactTurn}
{\xe \v Katabatic::AutoContactTurn\:getSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * getSegment (unsigned int  {\i index}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The nth anchored {\b AutoSegment}. The index is significant:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b 0}  : first horizontal ({\b h1} ).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b 1}  : second horizontal ({\b h2} ).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b 2}  : first vertical ({\b b1} ).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b 3}  : second vertical ({\b b2} ).\par}
Not all the indexes are filled for every {\b AutoContact}. For example {\f2 Turn}  have {\b h1}  and {\b b1} , and {\f2 HTee}  have {\b h1} , {\b h2}  and {\b v1} . \par
}{
Implements {\b AutoContact} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v updateGeometry\:Katabatic::AutoContactTurn}
{\xe \v Katabatic::AutoContactTurn\:updateGeometry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateGeometry (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute the new position of the {\b AutoContact} based on the {\b AutoSegment} positions. The {\b Session} mechanism ensure that all {\b AutoSegment} are set into their final positions before calling this updator. \par
}{
Implements {\b AutoContact} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoContact::base(), DebugSession::close(), Katabatic::CntInvalidated, AutoContact::getNet(), AutoContact::getX(), AutoContact::getY(), AutoContact::hasBadTopology(), Go::invalidate(), AutoContact::isInvalidatedCache(), DebugSession::open(), AutoContact::setX(), and AutoContact::setY().}\par
}
{\xe \v updateTopology\:Katabatic::AutoContactTurn}
{\xe \v Katabatic::AutoContactTurn\:updateTopology}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateTopology (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restore the topology (i.e. connexity) of the contact after one or both connected segments has changed layer.\par
Based on the layer depth delta between the two perpandiculars segments. Three case can occurs:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The delta is {\b zero} , then just sets the layer of the contact to the common metal layer (turn in same layer).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The delta is {\b one} , then sets the contact layer to VIA connecting the two layers.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The delta {\b cannot be equal to two} , due to the alternatives routing directions, it would mean a {\i turn}  connecting two {\i horizontals}  (or verticals) in different layers.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The delta is {\b three} , then create a dogleg to restore the connexity. The dogleg will be created on the connected segment which as been {\i layer invalidated} . If both of them have been invalidated, the horizontal one is preferred.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
A delta of more than {\b three}  is an error, and must never occurs.\par}
 \par
}{
Implements {\b AutoContact} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References DebugSession::close(), Katabatic::CntBadTopology, RoutingGauge::getContactLayer(), AutoContact::getLayer(), AutoSegment::getLayer(), RoutingGauge::getLayerDepth(), AutoContact::getNet(), Session::getRoutingGauge(), RoutingGauge::getRoutingLayer(), AutoContact::hasBadTopology(), AutoSegment::invalidate(), AutoContact::isInvalidatedCache(), AutoSegment::isInvalidatedLayer(), AutoSegment::makeDogleg(), DebugSession::open(), AutoContact::setLayer(), and AutoContact::showTopologyError().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoContactTurn.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoContactTurn.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoContactTurn.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AutoContactVTee Class Reference\par \pard\plain 
{\tc\tcl2 \v AutoContactVTee}
{\xe \v AutoContactVTee}
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AutoContact} V-Tee (one H, two V) }}\par
Inheritance diagram for AutoContactVTee:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKatabatic_1_1AutoContactVTee__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegment} * {\b getOpposite} (const {\b AutoSegment} *) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegment} * {\b getPerpandicular} (const {\b AutoSegment} *) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegment} * {\b getSegment} (unsigned int) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateGeometry} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateTopology} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b AutoContactVTee} * {\b create} ({\b GCell} *, {\b Net} *, const {\b Layer} *)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AutoContact} V-Tee (one H, two V) \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AutoContact} to build a vertical tee (two V, one H). \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v create\:Katabatic::AutoContactVTee}
{\xe \v Katabatic::AutoContactVTee\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoContactVTee} * create ({\b GCell} *  {\i gcell}, {\b Net} *  {\i net}, const {\b Layer} *  {\i layer}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i gcell} \cell }{The {\b GCell} into which create the {\b AutoContact}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i net} \cell }{The Net to which this {\b AutoContact} belongs. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i layer} \cell }{The Layer of the {\b AutoContact}. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The created {\b AutoContactVTee}.\par
}Create a new {\b AutoContactVTee}. \par
}{
References Katabatic::CntInCreationStage, and Contact::create().}\par
{
Referenced by GCellTopology::_do_xG(), GCellTopology::_do_xG_xM1_xM3(), GCellTopology::_do_xG_xM2(), and GCellTopology::_do_xG_xM3().}\par
}
{\xe \v getOpposite\:Katabatic::AutoContactVTee}
{\xe \v Katabatic::AutoContactVTee\:getOpposite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * getOpposite (const {\b AutoSegment} *  {\i reference}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The other {\b AutoSegment} the {\i same}  direction as {\f2 reference} , this is only meaningful on {\b AutoContactHTee} or {\b AutoContactVTee}. If there is no opposite, {\f2 NULL}  is returned. \par
}{
Implements {\b AutoContact} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getPerpandicular\:Katabatic::AutoContactVTee}
{\xe \v Katabatic::AutoContactVTee\:getPerpandicular}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * getPerpandicular (const {\b AutoSegment} *  {\i reference}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} in the {\i perpandicular}  direction to {\f2 reference} , this is only meaningful on AutoContacTurn. It there is no unique perpandicular, {\f2 NULL}  is returned. \par
}{
Implements {\b AutoContact} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getSegment\:Katabatic::AutoContactVTee}
{\xe \v Katabatic::AutoContactVTee\:getSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * getSegment (unsigned int  {\i index}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The nth anchored {\b AutoSegment}. The index is significant:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b 0}  : first horizontal ({\b h1} ).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b 1}  : second horizontal ({\b h2} ).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b 2}  : first vertical ({\b b1} ).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b 3}  : second vertical ({\b b2} ).\par}
Not all the indexes are filled for every {\b AutoContact}. For example {\f2 Turn}  have {\b h1}  and {\b b1} , and {\f2 HTee}  have {\b h1} , {\b h2}  and {\b v1} . \par
}{
Implements {\b AutoContact} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v updateGeometry\:Katabatic::AutoContactVTee}
{\xe \v Katabatic::AutoContactVTee\:updateGeometry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateGeometry (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute the new position of the {\b AutoContact} based on the {\b AutoSegment} positions. The {\b Session} mechanism ensure that all {\b AutoSegment} are set into their final positions before calling this updator. \par
}{
Implements {\b AutoContact} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoContact::base(), DebugSession::close(), Katabatic::CntInvalidated, AutoContact::getNet(), AutoContact::getX(), AutoContact::getY(), AutoContact::hasBadTopology(), Go::invalidate(), AutoContact::isInvalidatedCache(), DebugSession::open(), AutoContact::setX(), and AutoContact::setY().}\par
}
{\xe \v updateTopology\:Katabatic::AutoContactVTee}
{\xe \v Katabatic::AutoContactVTee\:updateTopology}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateTopology (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restore the topology (i.e. connexity) of the contact after any number of connected segments has changed layer (at least one, up to three).\par
For a detailed explanation, see {\b AutoContactHTee::updateTopology()} and sawp horizontal & vertical... \par
}{
Implements {\b AutoContact} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References DebugSession::close(), Katabatic::CntBadTopology, RoutingGauge::getContactLayer(), AutoContact::getLayer(), RoutingGauge::getLayerDepth(), AutoContact::getNet(), Session::getRoutingGauge(), RoutingGauge::getRoutingLayer(), AutoContact::hasBadTopology(), AutoSegment::invalidate(), AutoContact::isInvalidatedCache(), DebugSession::open(), AutoContact::setLayer(), and AutoContact::showTopologyError().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoContactVTee.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoContactVTee.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoContactVTee.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AutoHorizontal Class Reference\par \pard\plain 
{\tc\tcl2 \v AutoHorizontal}
{\xe \v AutoHorizontal}
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Concrete Horizontal {\b AutoSegment}. }}\par
Inheritance diagram for AutoHorizontal:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKatabatic_1_1AutoHorizontal__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b _canSlacken} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canMoveULeft} (float reserve=0.0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canMoveURight} (float reserve=0.0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Segment} * {\b base} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Segment} * {\b base} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Horizontal} * {\b getHorizontal} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b DbU::Unit} {\b getSourceU} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b DbU::Unit} {\b getTargetU} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b DbU::Unit} {\b getDuSource} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b DbU::Unit} {\b getDuTarget} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Interval} {\b getSpanU} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b getConstraints} ({\b DbU::Unit} &min, {\b DbU::Unit} &max) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Interval} {\b getSourceConstraints} (unsigned int flags=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Interval} {\b getTargetConstraints} (unsigned int flags=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b getDirection} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual size_t {\b getGCells} (vector< {\b GCell} *> &) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b setDuSource} ({\b DbU::Unit})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b setDuTarget} ({\b DbU::Unit})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateOrient} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updatePositions} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b checkPositions} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b checkConstraints} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b _makeDogleg} ({\b GCell} *, unsigned int flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b moveULeft} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b moveURight} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b _postCreate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b _preDestroy} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Concrete Horizontal {\b AutoSegment}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v _canSlacken\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:_canSlacken}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool _canSlacken () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the segment can be slackened. That is, source or target constraints are less than three pitches. \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References Interval::contains(), AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoContact::getGCell(), GCell::getSide(), Interval::getSize(), DbU::getValueString(), Interval::inflate(), and Katabatic::KbVertical.}\par
}
{\xe \v canMoveULeft\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:canMoveULeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool canMoveULeft (float  {\i reserve} = {\f2 0.0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b true}  if the {\i global}  segment can be moved on the left {\b GCell} (for a vertical) or down (for an horizontal). The move is accepted only if it do not change the amount of global wiring. Thus the following conditions:{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The segment mustn't be on the leftmost {\b GCell} (obvious...).\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The segment must be global.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The source and target contacts must be AutoContactTurn(s).\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
At least one of the perpandicular must be global {\b and}  connected through the {\i target} . That is, it's a global which extends toward left.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The {\b GCell} of maximum density on the left must remains below the current {\b GCell} of maximum density, with a margin of {\f2 reserve}  (expressed in total saturation percentage). \par}
}}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAII \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), GCell::getDown(), AutoContact::getGCell(), AutoSegment::getGCell(), AutoSegment::getLayer(), RoutingGauge::getLayerDepth(), GCell::getRight(), Session::getRoutingGauge(), AutoContact::getSegment(), GCell::getWDensity(), and AutoSegment::isGlobal().}\par
}
{\xe \v canMoveURight\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:canMoveURight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool canMoveURight (float  {\i reserve} = {\f2 0.0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b true}  if the {\i global}  segment can be moved on the right {\b GCell} (for a vertical) or up (for an horizontal). The move is accepted only if it do not change the amount of global wiring. Thus the following conditions:{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The segment mustn't be on the leftmost {\b GCell} (obvious...).\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The segment must be global.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The source and target contacts must be AutoContactTurn(s).\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
At least one of the perpandicular must be global {\b and}  connected through the {\i source} . That is, it's a global which extends toward right.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The {\b GCell} of maximum density on the left must remains below the current {\b GCell} of maximum density, with a margin of {\f2 reserve}  (expressed in total saturation percentage). \par}
}}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoContact::getGCell(), AutoSegment::getGCell(), AutoSegment::getLayer(), RoutingGauge::getLayerDepth(), GCell::getRight(), Session::getRoutingGauge(), AutoContact::getSegment(), GCell::getUp(), GCell::getWDensity(), and AutoSegment::isGlobal().}\par
}
{\xe \v base\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Segment} * base (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  the decorated {\b Hurricane::Segment}. \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v base\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Segment} * base () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  the decorated {\b Hurricane::Segment} (const flavor). \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getHorizontal\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:getHorizontal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Horizontal} * getHorizontal (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  If the decorated segment is a {\b Hurricane::Horizontal}, return it. {\f2 NULL}  otherwise. \par
}{
Reimplemented from {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getSourceU\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:getSourceU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getSourceU () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} {\i uniform}  source position. (X for an horizontal and Y for a Vertical). \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References Segment::getSourceX().}\par
}
{\xe \v getTargetU\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:getTargetU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getTargetU () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} {\i uniform}  target position. (X for an horizontal and Y for a Vertical). \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References Segment::getTargetX().}\par
}
{\xe \v getDuSource\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:getDuSource}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getDuSource () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} {\i uniform}  delta from source. (dX for an horizontal and dY for a Vertical). \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References Horizontal::getDxSource().}\par
}
{\xe \v getDuTarget\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:getDuTarget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getDuTarget () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} {\i uniform}  delta from source. (dX for an horizontal and dY for a Vertical). \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References Horizontal::getDxTarget().}\par
}
{\xe \v getSpanU\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:getSpanU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getSpanU () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} {\i uniform}  occupying interval (on X for horizontal and on Y for vertical). \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References Segment::getSourceX(), and Segment::getTargetX().}\par
}
{\xe \v getConstraints\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:getConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool getConstraints ({\b DbU::Unit} &  {\i min}, {\b DbU::Unit} &  {\i max}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  in {\f2 min}  & {\f2 max}  the allowed range for the segment axis. \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoContact::getCBYMax(), AutoContact::getCBYMin(), AutoSegment::getUserConstraints(), and DbU::getValueString().}\par
}
{\xe \v getSourceConstraints\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:getSourceConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getSourceConstraints (unsigned int  {\i flags} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The Interval into witch the source {\b AutoContact} can vary. By default all deduced constraints and user constraints are took into account. If {\f2 flags}  contains {\f2 KbNativeConstraints}  the constraint returned is only the enclosing {\b GCell}. \par
}}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoSegment::getAutoSource(), Box::getYMax(), Box::getYMin(), and Katabatic::KbNativeConstraints.}\par
}
{\xe \v getTargetConstraints\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:getTargetConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getTargetConstraints (unsigned int  {\i flags} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The Interval into witch the target {\b AutoContact} can vary. By default all deduced constraints and user constraints are took into account. If {\f2 flags}  contains {\f2 KbNativeConstraints}  the constraint returned is only the enclosing {\b GCell}. \par
}}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoSegment::getAutoTarget(), Box::getYMax(), Box::getYMin(), and Katabatic::KbNativeConstraints.}\par
}
{\xe \v getDirection\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:getDirection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getDirection () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b Katabatic::KbHorizontal} or {\b Katabatic::KbVertical} according to the decorated segment. \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References Katabatic::KbHorizontal.}\par
}
{\xe \v getGCells\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:getGCells}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getGCells (vector< {\b GCell} *> &  {\i gcells}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i gcells} \cell }{A vector that will be filled by all the GCells that the segment overlap. In increasing order, from source to target. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The vector's size. \par
}}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoContact::getGCell(), AutoSegment::getGCell(), and GCell::getRight().}\par
}
{\xe \v setDuSource\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:setDuSource}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setDuSource ({\b DbU::Unit}  {\i du}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the {\i uniform}  {\f2 dU}  from source anchor (dX for Horizontal, dY for Vertical). \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v setDuTarget\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:setDuTarget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setDuTarget ({\b DbU::Unit}  {\i du}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the {\i uniform}  {\f2 dU}  from target anchor (dX for Horizontal, dY for Vertical). \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v updateOrient\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:updateOrient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateOrient (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ensure that source is lower than target. Swap them if needed. Swap never occurs on global segment because their source and target anchors are from different {\b GCell}, which are already ordered. \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References Segment::getSourceX(), Segment::getTargetX(), Segment::invert(), Katabatic::SegSourceBottom, Katabatic::SegSourceTop, Katabatic::SegStrongTerminal, Katabatic::SegTargetBottom, Katabatic::SegTargetTop, AutoSegment::setFlags(), and AutoSegment::unsetFlags().}\par
}
{\xe \v updatePositions\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:updatePositions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updatePositions (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update the segment begenning and ending positions. The positions takes into account the extension caps and reflect the real space used by the segment under it's long axis. \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References Session::getExtensionCap(), AutoSegment::getLayer(), Segment::getSourceX(), and Segment::getTargetX().}\par
}
{\xe \v checkPositions\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:checkPositions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool checkPositions () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the relative positions of source & target are coherent. (source <= target). \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References Session::getExtensionCap(), AutoSegment::getLayer(), Segment::getSourceX(), Segment::getTargetX(), and DbU::getValueString().}\par
}
{\xe \v checkConstraints\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:checkConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool checkConstraints () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the constraint intervel is coherent (non-empty or punctual in the worst case). \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), and Interval::intersect().}\par
}
{\xe \v _makeDogleg\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:_makeDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int _makeDogleg ({\b GCell} *  {\i doglegGCell}, unsigned int  {\i flags}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b This method is the workhorse for the various dogleg and topology restauration methods.}  It is the atomic method that actually make the dogleg on {\b this}  segment.\par
{\b Returns:}  {\b Katabatic::KbUseAboveLayer} if the dogleg is using the {\i above}  layer ({\b Katabatic::KbUseBelowLayer} for the below layer).\par
Break the current segment in two (a.k.a. making a dogleg).{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The segment is broken inside {\f2 doglegGCell} .\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Two new segments are createds, one perpandicular and one parallel.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The original segment is always kept attached to the {\i source} . (the new parallel fragment is attached to the {\i target} ).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The perpandicular segment is in the layer {\i above}  by default. If we are already on the topmost routing layer, the {\i below}  layer is used.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
If the segment pass through the breaking {\b GCell}, it's axis is set into the center. If the segment is local, the axis is the middle of the segment.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The Local/Global kind of the original segment is updated. The local/global status is computed by the constructor of the {\b AutoSegment} for the perpandicular and the new parallel.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The terminal state is updated. If the segment is a strong terminal the part that is no longer directly connected to the terminal is demoted to {\b Katabatic::SegWeakTerminal1}.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The perpandicular is obviously a canonical. If the broken segment is canonical, the original {\b is}  left canonical and only the new parallel is re-canonized. Otherwise, we re-canonise both sets of aligned segments (the one on the source and the one on the target).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The three segments are added to the session dogleg stack.\par}
After this method call the net topology is guarantee to be valid.\par
  \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoSegment::canonize(), DebugSession::close(), AutoContactTurn::create(), AutoSegment::create(), Session::dogleg(), AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), Session::getConfiguration(), RoutingGauge::getContactLayer(), AutoContact::getGCell(), Component::getLayer(), AutoSegment::getLayer(), RoutingGauge::getLayerDepth(), Component::getNet(), AutoSegment::getNet(), GCell::getRight(), Session::getRoutingGauge(), RoutingGauge::getRoutingLayer(), AutoSegment::getSourceX(), AutoSegment::getTargetX(), GCell::getX(), GCell::getXMax(), AutoSegment::getY(), AutoContact::invalidate(), AutoSegment::invalidate(), AutoSegment::isCanonical(), AutoSegment::isLocal(), AutoSegment::isSlackened(), AutoSegment::isWeakTerminal(), Katabatic::KbHorizontal, Katabatic::KbUseAboveLayer, Katabatic::KbUseBelowLayer, Katabatic::KbVertical, AutoContact::migrateConstraintBox(), DebugSession::open(), GCell::removeHSegment(), Katabatic::SegCanonical, Katabatic::SegDogleg, Katabatic::SegGlobal, Katabatic::SegNotAligned, Katabatic::SegSlackened, Katabatic::SegWeakTerminal1, AutoSegment::setFlags(), AutoSegment::setLayer(), and AutoSegment::unsetFlags().}\par
}
{\xe \v moveULeft\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:moveULeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool moveULeft (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b This function do not manage an aligned set. It applies on {\f2 this}  segment only.} \par
Displace an Horizontal or Vertical segment to the {\b GCell} below (a.k.a. lower or inferior). Rules for displacement:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The segment must be connected at both end to a turn contact (we do not want to manage more complex cases for the time beeing).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
And, of course, the segment must not already by on the bottomost {\b GCell}...\par}
The displacement take care of:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Managing the status of the various perpandiculars. The stretched one are made global if needed. The shrinked one made local, if needed.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The supporting {\b AutoContact} (source & target) are changed of {\b GCell}.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
If the segment is global, the go-through GCells are updateds.\par}
{\b Returns:}  {\b true}  if the move has succeeded.\par
 \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References GCell::addVSegment(), AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), GCell::getDown(), AutoContact::getGCell(), AutoSegment::getGCell(), GCell::getRight(), AutoContact::getSegment(), GCell::getSide(), Interval::getVMax(), AutoSegment::isLocal(), Katabatic::KbVertical, GCell::removeVSegment(), Katabatic::SegGlobal, AutoSegment::setAxis(), AutoSegment::setFlags(), AutoContact::setGCell(), and AutoSegment::unsetFlags().}\par
}
{\xe \v moveURight\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:moveURight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool moveURight (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b This function do not manage an aligned set. It applies on {\f2 this}  segment only.} \par
Displace an Horizontal or Vertical segment to the {\b GCell} above (a.k.a. upper or superior). Rules for displacement:\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b AutoSegment::moveULeft()} for a complete description. \par
}}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References GCell::addVSegment(), AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoContact::getGCell(), AutoSegment::getGCell(), GCell::getRight(), AutoContact::getSegment(), GCell::getSide(), GCell::getUp(), Interval::getVMin(), AutoSegment::isLocal(), Katabatic::KbVertical, GCell::removeVSegment(), Katabatic::SegGlobal, AutoSegment::setAxis(), AutoSegment::setFlags(), AutoContact::setGCell(), and AutoSegment::unsetFlags().}\par
}
{\xe \v _postCreate\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:_postCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _postCreate (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In addition to {\b AutoSegment::_postCreate()}, detect whether the segment is global or local and register it in the relevant GCells (if needed).\par
If the segment is anchored directly on a terminal, adjust the axis so it's connected. \par
}{
Reimplemented from {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoSegment::_postCreate(), GCell::addHSegment(), AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoContact::getGCell(), GCell::getRight(), GCell::getX(), Component::getY(), Katabatic::SegGlobal, AutoSegment::setFlags(), and AutoContact::setY().}\par
}
{\xe \v _preDestroy\:Katabatic::AutoHorizontal}
{\xe \v Katabatic::AutoHorizontal\:_preDestroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _preDestroy (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform operations that must be done before the actual destructor is called. Merely whidrawn the {\b AutoSegment} from the lookup/Session mechanism. \par
}{
Reimplemented from {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoSegment::_preDestroy(), AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoContact::getGCell(), AutoSegment::getId(), GCell::getRight(), GCell::getX(), and GCell::removeHSegment().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoHorizontal.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoHorizontal.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoHorizontal.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AutoSegment Class Reference\par \pard\plain 
{\tc\tcl2 \v AutoSegment}
{\xe \v AutoSegment}
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract base class for {\b AutoSegment}. }}\par
Inheritance diagram for AutoSegment:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKatabatic_1_1AutoSegment__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Segment} * {\b base} () const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Segment} * {\b base} ()=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Horizontal} * {\b getHorizontal} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Vertical} * {\b getVertical} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Cell} * {\b getCell} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Net} * {\b getNet} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Layer} * {\b getLayer} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Box} {\b getBoundingBox} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Hook} * {\b getSourceHook} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Hook} * {\b getTargetHook} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Contact} * {\b getSource} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Contact} * {\b getTarget} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Component} * {\b getOppositeAnchor} ({\b Component} *) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Components} {\b getAnchors} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b DbU::Unit} {\b getX} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b DbU::Unit} {\b getY} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getWidth} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getLength} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getSourcePosition} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getTargetPosition} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getSourceX} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getSourceY} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getTargetX} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getTargetY} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b invert} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLayer} (const {\b Layer} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isHorizontal} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isVertical} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isGlobal} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isLocal} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isFixed} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isBipoint} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isWeakTerminal} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isStrongTerminal} (unsigned int flags=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isLayerChange} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isSpinTop} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isSpinBottom} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isSpinTopOrBottom} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isReduced} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isStrap} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isDogleg} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInvalidated} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInvalidatedLayer} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isCreated} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isCanonical} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isUnsetAxis} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isSlackened} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b _canSlacken} () const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b canReduce} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mustRaise} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b canDogleg} ({\b Interval})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canMoveULeft} (float reserve=0.0) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canMoveURight} (float reserve=0.0) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b canMoveUp} (float reserve=0.0, unsigned int flags=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b canPivotUp} (float reserve=0.0, unsigned int flags=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b canPivotDown} (float reserve=0.0, unsigned int flags=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b canSlacken} (unsigned int flags=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b checkPositions} () const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b checkConstraints} () const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b getId} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b getDirection} () const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GCell} * {\b getGCell} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual size_t {\b getGCells} (vector< {\b GCell} *> &) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoContact} * {\b getAutoSource} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoContact} * {\b getAutoTarget} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoContact} * {\b getOppositeAnchor} ({\b AutoContact} *) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getPerpandicularsBound} (set< {\b AutoSegment} *> &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegment} * {\b getParent} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getAxis} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b DbU::Unit} {\b getSourceU} () const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b DbU::Unit} {\b getTargetU} () const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b DbU::Unit} {\b getDuSource} () const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b DbU::Unit} {\b getDuTarget} () const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getOrigin} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getExtremity} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Interval} {\b getSpanU} () const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Interval} {\b getMinSpanU} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Interval} {\b getSourceConstraints} (unsigned int flags=0) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Interval} {\b getTargetConstraints} (unsigned int flags=0) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b getConstraints} ({\b DbU::Unit} &min, {\b DbU::Unit} &max) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getConstraints} ({\b Interval} &i) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Interval} & {\b getUserConstraints} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b DbU::Unit} {\b getSlack} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getOptimalMin} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getOptimalMax} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Interval} & {\b getOptimal} ({\b Interval} &i) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b DbU::Unit} {\b getCost} ({\b DbU::Unit} axis) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegment} * {\b getCanonical} ({\b DbU::Unit} &min, {\b DbU::Unit} &max)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegment} * {\b getCanonical} ({\b Interval} &i)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b unsetFlags} (unsigned int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFlags} (unsigned int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b setDuSource} ({\b DbU::Unit} du)=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b setDuTarget} ({\b DbU::Unit} du)=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b computeTerminal} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateOrient} ()=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updatePositions} ()=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mergeUserConstraints} (const {\b Interval} &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetUserConstraints} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setOptimalMin} ({\b DbU::Unit} min)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setOptimalMax} ({\b DbU::Unit} max)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b revalidate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegment} * {\b makeDogleg} ({\b AutoContact} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b makeDogleg} ({\b Interval}, unsigned int flags=KbNoFlags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b makeDogleg} ({\b GCell} *, unsigned int flags=KbNoFlags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b _makeDogleg} ({\b GCell} *, unsigned int flags)=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b moveULeft} ()=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b moveURight} ()=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b slacken} (unsigned int flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b reduceDoglegLayer} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b reduce} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b raise} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegment} * {\b canonize} (unsigned int flags=KbNoFlags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b invalidate} (unsigned int flags={\b KbPropagate})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b computeOptimal} (set< {\b AutoSegment} *> &processeds)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAxis} ({\b DbU::Unit}, unsigned int flags=KbNoFlags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toConstraintAxis} (unsigned int flags={\b KbRealignate})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toOptimalAxis} (unsigned int flags={\b KbRealignate})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegments} {\b getOnSourceContact} (unsigned int direction)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegments} {\b getOnTargetContact} (unsigned int direction)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegments} {\b getAligneds} (unsigned int flags=KbNoFlags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegments} {\b getPerpandiculars} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b AutoSegment} * {\b create} ({\b AutoContact} *source, {\b AutoContact} *target, {\b Segment} *hurricaneSegment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b AutoSegment} * {\b create} ({\b AutoContact} *source, {\b AutoContact} *target, unsigned int dir, size_t depth=RoutingGauge::nlayerdepth)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegment} ({\b Segment} *segment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~AutoSegment} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b _postCreate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b _preDestroy} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _invalidate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _getFlags} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b _preCreate} ({\b AutoContact} *source, {\b AutoContact} *target)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract base class for {\b AutoSegment}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Creating AutoHorizontal & AutoVertical
\par}
{\tc\tcl2 \v Creating AutoHorizontal & AutoVertical}
{\b AutoSegment} is the abstract base class for {\b AutoHorizontal} and {\b AutoVertical}. They are must be created only through the factory method: {\b AutoSegment::create()}.\par}
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Characteristics of AutoSegments
\par}
{\tc\tcl2 \v Characteristics of AutoSegments}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Unique ID: to ease the enforcing of a deterministic behavior and to gain some independance from the pointers, each {\b AutoSegment} is associated with an unique identifier. {\b IDs}  are now directly taken from the {\b Hurricane::Segment}. \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Source contact is always lesser than Target contact {\f2 (Xs,Ys) < (Xt,Yt)} . \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
When assembled through {\b AutoContactVTee} or {\b AutoContactHTee}, AutoSegments became (i.e. must be kept) aligneds. Among a set of aligned AutoSegments, we distinguish a representative trough which we can manipulate the whole set. This representative is called the {\i canonical}  {\b AutoSegment} and is the one with the lowest {\f2 id} ). \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
When an aligned set contains at least one global, all the segments of the set are tagged {\b Katabatic::SegWeakGlobal}. This is especially useful on local ones to know if they are part of a much longer wire.\par
Conversely, a set of aligned may contains only local segments and thus will not have the flag set. \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
To allow some optimization, the {\b Katabatic::SegNotAligned} tells if a segment is part of an aligned set. It is deduced from the type of both source and target contact: not on the parallel branch of a tee. \par}
{\b The Ever Fragmenting Data Structure} \par
All the transformations applied to the database, after it's initial building, can be reduced to making new doglegs (and layer changes). Another way to put it, is that no Tee is ever created after the initial stage. The consequence is that the segments are only fragmenting more and more (up to a certain limit). The aligneds sets are progessively broken apart as needed, and until there remains only one tee per set (the two segments on the aligned branch).\par}
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Operations on AutoSegments
\par}
{\tc\tcl2 \v Operations on AutoSegments}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Slackening.}  Constraints transmited through either source or target {\b AutoContact} are too tight (tighter than the {\b GCell}), by adding straps in the perpandicular direction, the full slack of the segment is restored. \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Layer Change.}  One or two layers above or below the current layer. One up/down may means into the perpandicular routing direction. \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Dogleg Creation.}  Mean breaking the segment in two. This operation is used to slacken the constraints on a segment or restore connexity on source/target contact after a layer change. The new segment is always created on the source. \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Reduction/Raising.}  When a segment is a short dogleg, no greater than one picth, it can use the layer of the perpandiculars. \par}
\par}
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Invalidate on AutoSegments
\par}
{\tc\tcl2 \v Invalidate on AutoSegments}
The simple invalidation of an {\b AutoSegment} {\b do not}  invalidate it's source & target contact.\par
An axis position change or a layer change both invalidate the {\b AutoSegment} {\b and}  it's source & target contacts.\par
For the complete invalidation/revalidation mechanism see {\b Session Algorithm}.\par}
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Main Attributes of AutoSegments
\par}
{\tc\tcl2 \v Main Attributes of AutoSegments}
{\b AutoSegment} retains all attributes from Segment. The Segment itself beeing accessible through the {\b base()} methods. {
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
An unique {\f2 Id}  (for determinism). \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The {\b GCell} from wich it starts from. It is the {\b GCell} of the source {\b AutoContact}. \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
A state, combination of flags from {\b Katabatic::AutoSegmentFlag}. \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
An interval for the optimal range of the {\b AutoSegment} axis. \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
An interval for user's defined constraint on the axis. \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The interval giving the complete length of the {\b AutoSegment}, that is, with all extentions cap taken into account. This interval is refered as the {\i span} . \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
A small counter, of the number of reduced neighbors (never exceed two). \par}
\par}
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Implementation Details
\par}
{\tc\tcl2 \v Implementation Details}
{\b AutoSegment} / {\b AutoHorizontal} & {\b AutoVertical} are kind of decorators of {\b Hurricane::Segment} (they do not scrictly respect the pattern).\par
Canonical {\b AutoSegment} can should be considered as a kind of Composite.\par
Thoses objects are created using a Factory method.\par}
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Methods Classification
\par}
{\tc\tcl2 \v Methods Classification}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i Wrapper methods}  on the underlying {\b Hurricane::Segment}. \par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i Atomic methods}  on {\b AutoSegment}, that is, which applies exactly on the current {\b AutoSegment}. \par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i Canonical methods}  that applies on the set of aligned AutoSegments. There are two kind of those, the methods part of the API, and the ones that make the link with the atomic methods. Those intermediate methods hide some cumbersome {\b AutoSegment} list parameters. {
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b AutoSegment::invalidate()} \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b AutoSegment::computeOptimal()} \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b AutoSegment::setAxis()} \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b AutoSegment::toConstraintAxis()} \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b AutoSegment::toOptimalAxis()} \par}
\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i Uniform access} , to simplify the managment of {\b AutoHorizontal} and {\b AutoVertical} through {\b AutoSegment}, a set of uniformized methods is introduced. For instance, to avoid to check the dynamic type to choose to call {\b getSourceX()} or {\b getSourceY()}, we may call {\b getSourceU()}. Uniform methods are named by replacing {\f2 X/Y}  with {\f2 U} . {
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b AutoSegment::getSourceU()} \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b AutoSegment::getTargetU()} \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b AutoSegment::getDuSource()} \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b AutoSegment::getDuTarget()} \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b AutoSegment::getSpanU()} \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b AutoSegment::setDuSource()} \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b AutoSegment::setDuTarget()} \par}
\par}
\par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AutoSegment\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:AutoSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} ({\b Segment} *  {\i segment}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AutoSegment} constructor. It is not directly accessible, instead use one flavor of the {\b AutoSegment::create()}. \par
}{
References GCell::getBoundingBox(), AutoContact::getGCell(), Segment::getSource(), Segment::getTarget(), Box::getXMax(), Box::getYMax(), AutoContact::invalidate(), AutoSegment::isGlobal(), AutoSegment::isHorizontal(), Session::lookup(), Katabatic::SegCreated, Katabatic::SegHorizontal, AutoSegment::setFlags(), and AutoSegment::setOptimalMax().}\par
}
{\xe \v ~AutoSegment\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:~AutoSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
~{\b AutoSegment} (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AutoSegment} destructor. It is not directly accessible, instead use one flavor of the {\b AutoSegment::create()}. \par
}{
References AutoSegment::isGlobal().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v create\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * create ({\b AutoContact} *  {\i source}, {\b AutoContact} *  {\i target}, {\b Segment} *  {\i hurricaneSegment}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i source} \cell }{The source {\b AutoContact}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i target} \cell }{The target {\b AutoContact}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i hurricaneSegment} \cell }{The {\b Hurricane::Segment} to decorate. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The AutoHorizontal/AutoVertical decorator segment.\par
}Factory method to create {\b AutoHorizontal} or {\b AutoVertical}. It is important to note that this function may modify the underlying {\b Hurricane::Segment}.{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Layer is set to the default (bottom) routing Layers.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Source & target anchor of {\f2 hurricaneSegment}  are set on {\f2 source}  and {\f2 target} . If the {\f2 hurricaneSegment}  is already anchored and {\f2 source}  or {\f2 target}  are not the one decorating the anchors, an exception is thrown. \par}
}{
References AutoSegment::_postCreate(), Hook::attach(), Hook::detach(), AutoContact::getBodyHook(), Session::getKatabatic(), Component::getLayer(), Session::getRoutingLayer(), Segment::getSource(), Segment::getSourceHook(), Segment::getTarget(), Segment::getTargetHook(), DbU::getValueString(), Segment::getWidth(), AutoContact::getX(), AutoContact::getY(), AutoContact::isFixed(), KatabaticEngine::isGMetal(), Session::lookup(), Segment::setLayer(), Segment::setWidth(), Vertical::setX(), and Horizontal::setY().}\par
{
Referenced by GCellTopology::_do_1G_1M3(), GCellTopology::_do_1G_xM1(), GCellTopology::_do_xG(), GCellTopology::_do_xG_1M1_1M2(), GCellTopology::_do_xG_1Pad(), GCellTopology::_do_xG_xM1_xM3(), GCellTopology::_do_xG_xM2(), GCellTopology::_do_xG_xM3(), AutoHorizontal::_makeDogleg(), AutoVertical::_makeDogleg(), AutoSegment::create(), GCellTopology::doRp_Access(), GCellTopology::doRp_AutoContacts(), GCellTopology::doRp_StairCaseH(), GCellTopology::doRp_StairCaseV(), and anonymous_namespace\{LoadGrByNet.cpp\}::singleGCell().}\par
}
{\xe \v create\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * create ({\b AutoContact} *  {\i source}, {\b AutoContact} *  {\i target}, unsigned int  {\i dir}, size_t  {\i depth} = {\f2 RoutingGauge::nlayerdepth}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i source} \cell }{The source {\b AutoContact}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i target} \cell }{The target {\b AutoContact}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dir} \cell }{Specify the segment direction. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i depth} \cell }{The layer, given by it's depth in the RoutingGauge. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The AutoHorizontal/AutoVertical.\par
}Factory method to create {\b AutoHorizontal} or {\b AutoVertical}. {\f2 flags}  indicate the direction (KbHorizontal or KbVertical). The underlying Hurricane segment is also created. \par
}{
References AutoContact::base(), Horizontal::create(), Vertical::create(), AutoSegment::create(), Session::getRoutingLayer(), AutoContact::getX(), AutoContact::getY(), AutoContact::isFixed(), Katabatic::KbHorizontal, and Katabatic::KbVertical.}\par
}
{\xe \v base\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Segment} * base () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  the decorated {\b Hurricane::Segment} (const flavor). \par
}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKT \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by AutoSegment::getAxis(), AutoSegment::getBoundingBox(), AutoSegment::getCanonical(), AutoSegment::getCell(), AutoSegment::getLayer(), AutoSegment::getLength(), AutoSegment::getNet(), AutoSegment::getOppositeAnchor(), AutoSegment::getSource(), AutoSegment::getSourceHook(), AutoSegment::getSourceX(), AutoSegment::getSourceY(), AutoSegment::getTarget(), AutoSegment::getTargetHook(), AutoSegment::getTargetX(), AutoSegment::getTargetY(), AutoSegment::getWidth(), AutoSegment::getX(), AutoSegment::getY(), AutoSegment::invert(), and AutoSegment::setLayer().}\par
}
{\xe \v base\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Segment} * base (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  the decorated {\b Hurricane::Segment}. \par
}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKU \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getHorizontal\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getHorizontal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Horizontal} * getHorizontal (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  If the decorated segment is a {\b Hurricane::Horizontal}, return it. {\f2 NULL}  otherwise. \par
}{
Reimplemented in {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getVertical\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getVertical}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Vertical} * getVertical (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  If the decorated segment is a {\b Hurricane::Vertical}, return it. {\f2 NULL}  otherwise. \par
}{
Reimplemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getCell\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getCell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Cell} * getCell () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Segment::getCell()}. \par
}}{
References AutoSegment::base(), and Entity::getCell().}\par
}
{\xe \v getNet\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getNet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Net} * getNet () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Segment::getNet()}. \par
}}{
References AutoSegment::base(), and Component::getNet().}\par
{
Referenced by AutoHorizontal::_makeDogleg(), and AutoSegment::_postCreate().}\par
}
{\xe \v getLayer\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Layer} * getLayer () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Segment::getLayer()}. \par
}}{
References AutoSegment::base(), and Component::getLayer().}\par
{
Referenced by AutoHorizontal::_makeDogleg(), AutoVertical::_makeDogleg(), AutoHorizontal::canMoveULeft(), AutoVertical::canMoveULeft(), AutoContact::canMoveUp(), AutoSegment::canMoveUp(), AutoHorizontal::canMoveURight(), AutoVertical::canMoveURight(), AutoSegment::canPivotDown(), AutoSegment::canPivotUp(), AutoHorizontal::checkPositions(), AutoVertical::checkPositions(), AutoSegment::makeDogleg(), AutoSegment::revalidate(), AutoHorizontal::updatePositions(), AutoVertical::updatePositions(), AutoContactTurn::updateTopology(), and AutoContactTerminal::updateTopology().}\par
}
{\xe \v getBoundingBox\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getBoundingBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
BoundingBox * getBoundingBox () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Segment::getBoundingBox()}. \par
}}{
References AutoSegment::base(), and Component::getBoundingBox().}\par
}
{\xe \v getSourceHook\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getSourceHook}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Hook} * getSourceHook (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Segment::getSourceHook()}. \par
}}{
References AutoSegment::base(), and Segment::getSourceHook().}\par
}
{\xe \v getTargetHook\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getTargetHook}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Hook} * getTargetHook (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Segment::getTargetHook()}. \par
}}{
References AutoSegment::base(), and Segment::getTargetHook().}\par
}
{\xe \v getSource\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getSource}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Contact} * getSource () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Segment::getSource()}. \par
}}{
References AutoSegment::base(), and Segment::getSource().}\par
{
Referenced by AutoSegment::getAutoSource(), and AutoSegment::getOnSourceContact().}\par
}
{\xe \v getTarget\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getTarget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Contact} * getTarget () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Segment::getTarget()}. \par
}}{
References AutoSegment::base(), and Segment::getTarget().}\par
{
Referenced by AutoSegment::getAutoTarget(), and AutoSegment::getOnTargetContact().}\par
}
{\xe \v getOppositeAnchor\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getOppositeAnchor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Component} * getOppositeAnchor ({\b Component} *  {\i anchor}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Segment::getNet()}. \par
}}{
References AutoSegment::base(), and Segment::getOppositeAnchor().}\par
{
Referenced by AutoSegment::getOppositeAnchor().}\par
}
{\xe \v getAnchors\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getAnchors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Components} getAnchors () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Segment::getAnchors()}. \par
}}}
{\xe \v getX\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getX () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Segment::getX()}. \par
}}{
References AutoSegment::base(), and Component::getX().}\par
{
Referenced by AutoVertical::_makeDogleg(), and AutoContactTerminal::updateGeometry().}\par
}
{\xe \v getY\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getY () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Segment::getY()}. \par
}}{
References AutoSegment::base(), and Component::getY().}\par
{
Referenced by AutoHorizontal::_makeDogleg(), and AutoContactTerminal::updateGeometry().}\par
}
{\xe \v getWidth\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getWidth () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Segment::getWidth()}. \par
}}{
References AutoSegment::base(), and Segment::getWidth().}\par
}
{\xe \v getLength\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getLength () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Segment::getLength()}. \par
}}{
References AutoSegment::base(), and Segment::getLength().}\par
{
Referenced by AutoSegment::canReduce(), and AutoSegment::mustRaise().}\par
}
{\xe \v getSourcePosition\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getSourcePosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getSourcePosition () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Segment::getSourcePosition()}. \par
}}{
Referenced by AutoSegment::getCanonical().}\par
}
{\xe \v getTargetPosition\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getTargetPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getTargetPosition () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Segment::getTargetPosition()}. \par
}}{
Referenced by AutoSegment::getCanonical().}\par
}
{\xe \v getSourceX\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getSourceX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getSourceX () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Segment::getSourceX()}. \par
}}{
References AutoSegment::base(), and Segment::getSourceX().}\par
{
Referenced by AutoHorizontal::_makeDogleg().}\par
}
{\xe \v getSourceY\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getSourceY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getSourceY () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Segment::getSourceY()}. \par
}}{
References AutoSegment::base(), and Segment::getSourceY().}\par
{
Referenced by AutoVertical::_makeDogleg().}\par
}
{\xe \v getTargetX\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getTargetX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getTargetX () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Segment::getTargetX()}. \par
}}{
References AutoSegment::base(), and Segment::getTargetX().}\par
{
Referenced by AutoHorizontal::_makeDogleg().}\par
}
{\xe \v getTargetY\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getTargetY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getTargetY () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Segment::getTargetY()}. \par
}}{
References AutoSegment::base(), and Segment::getTargetY().}\par
{
Referenced by AutoVertical::_makeDogleg().}\par
}
{\xe \v invert\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:invert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} invert (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Segment::invert()}. \par
}}{
References AutoSegment::base(), and Segment::invert().}\par
}
{\xe \v setLayer\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:setLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setLayer (const {\b Layer} *  {\i layer}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Segment::setLayer()}. \par
}}{
References AutoSegment::base(), and Segment::setLayer().}\par
{
Referenced by AutoHorizontal::_makeDogleg(), AutoVertical::_makeDogleg(), and AutoSegment::reduceDoglegLayer().}\par
}
{\xe \v isHorizontal\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:isHorizontal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isHorizontal () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the {\b Hurricane::Segment} is Horizontal. \par
}{
References Katabatic::SegHorizontal.}\par
{
Referenced by AutoSegment::AutoSegment(), AutoSegment::computeOptimal(), AutoSegment::getAxis(), AutoSegment::getExtremity(), AutoSegment::getOrigin(), AutoContactTerminal::getSegment(), AutoSegment::makeDogleg(), AutoSegment::setAxis(), AutoSegment::toConstraintAxis(), and AutoContactTerminal::updateGeometry().}\par
}
{\xe \v isVertical\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:isVertical}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isVertical () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the {\b Hurricane::Segment} is Vertical. \par
}{
References Katabatic::SegHorizontal.}\par
{
Referenced by AutoSegment::computeOptimal(), and AutoContactTerminal::getSegment().}\par
}
{\xe \v isGlobal\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:isGlobal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isGlobal () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the segment is global (span over more than one {\b GCell}). \par
}{
References Katabatic::SegGlobal.}\par
{
Referenced by AutoSegment::AutoSegment(), AutoHorizontal::canMoveULeft(), AutoVertical::canMoveULeft(), AutoHorizontal::canMoveURight(), AutoVertical::canMoveURight(), AutoSegment::canonize(), AutoSegment::canReduce(), AutoSegment::canSlacken(), AutoContact::showTopologyError(), and AutoSegment::~AutoSegment().}\par
}
{\xe \v isLocal\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:isLocal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isLocal () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the segment is local (fully enclosed in one {\b GCell}). \par
}{
References Katabatic::SegGlobal.}\par
{
Referenced by AutoHorizontal::_makeDogleg(), AutoVertical::_makeDogleg(), AutoSegment::canMoveUp(), AutoSegment::canPivotDown(), AutoSegment::canPivotUp(), GCell::checkEdgeSaturation(), AutoHorizontal::moveULeft(), AutoVertical::moveULeft(), AutoHorizontal::moveURight(), and AutoVertical::moveURight().}\par
}
{\xe \v isFixed\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:isFixed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isFixed () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if segment must not be moved by the router. \par
}{
References Katabatic::SegFixed.}\par
{
Referenced by AutoSegment::canMoveUp(), AutoSegment::canPivotDown(), AutoSegment::canPivotUp(), and AutoSegment::makeDogleg().}\par
}
{\xe \v isBipoint\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:isBipoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isBipoint () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the segment straigh join two terminals. \par
}{
References Katabatic::SegBipoint.}\par
}
{\xe \v isWeakTerminal\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:isWeakTerminal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isWeakTerminal () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if segment is indirectly connected to a terminal. \par
}{
References Katabatic::SegWeakTerminal.}\par
{
Referenced by AutoHorizontal::_makeDogleg(), and AutoVertical::_makeDogleg().}\par
}
{\xe \v isStrongTerminal\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:isStrongTerminal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isStrongTerminal (unsigned int  {\i flags} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if segment is directly connected to a terminal. \par
}{
References AutoSegment::getAligneds(), Katabatic::KbPropagate, and Katabatic::SegStrongTerminal.}\par
{
Referenced by AutoSegment::canMoveUp(), AutoSegment::canPivotDown(), and AutoSegment::canPivotUp().}\par
}
{\xe \v isLayerChange\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:isLayerChange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isLayerChange () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if segment is a strap used only to connect between two different metal layers on the way up or down. \par
}{
References Katabatic::SegLayerChange.}\par
{
Referenced by AutoSegment::canMoveUp(), AutoSegment::canPivotDown(), and AutoSegment::canPivotUp().}\par
}
{\xe \v isSpinTop\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:isSpinTop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isSpinTop () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if segment is connected to turns and both perpandiculars segments are in the {\i top}  layer (candidate for reduction). \par
}{
Referenced by AutoSegment::canReduce(), AutoSegment::isSpinTopOrBottom(), AutoSegment::mustRaise(), and AutoSegment::reduceDoglegLayer().}\par
}
{\xe \v isSpinBottom\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:isSpinBottom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isSpinBottom () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if segment is connected to turns and both perpandiculars segments are in the {\i bottom}  layer (candidate for reduction). \par
}{
Referenced by AutoSegment::canReduce(), AutoSegment::isSpinTopOrBottom(), AutoSegment::mustRaise(), and AutoSegment::reduceDoglegLayer().}\par
}
{\xe \v isSpinTopOrBottom\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:isSpinTopOrBottom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isSpinTopOrBottom () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if segment is either {\i spin top}  or {\i spin bottom}  (candidate for reduction). \par
}{
References AutoSegment::isSpinBottom(), and AutoSegment::isSpinTop().}\par
{
Referenced by AutoSegment::canReduce().}\par
}
{\xe \v isReduced\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:isReduced}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isReduced () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if segment is actually in a reduced state: it's effective layer will be the one of it's perpandiculars. \par
}{
References Katabatic::SegIsReduced.}\par
{
Referenced by AutoSegment::reduceDoglegLayer(), and AutoSegment::revalidate().}\par
}
{\xe \v isStrap\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:isStrap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isStrap () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if segment has been created from a slackening operation to restore the slack of another segment. \par
}{
References Katabatic::SegStrap.}\par
}
{\xe \v isDogleg\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:isDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isDogleg () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if segment has been created as the perpandicular part of a dogleg. \par
}{
References Katabatic::SegDogleg.}\par
{
Referenced by AutoSegment::toConstraintAxis().}\par
}
{\xe \v isInvalidated\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:isInvalidated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isInvalidated () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if segment has been moved or topologicaly altered. \par
}{
References Katabatic::SegInvalidated.}\par
{
Referenced by AutoSegment::_invalidate(), AutoSegment::invalidate(), and AutoSegment::revalidate().}\par
}
{\xe \v isInvalidatedLayer\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:isInvalidatedLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isInvalidatedLayer () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if segment has been changed of layer. Source and Target {\b AutoContact} may need to be altered. \par
}{
References Katabatic::SegInvalidatedLayer.}\par
{
Referenced by AutoContactTurn::updateTopology().}\par
}
{\xe \v isCreated\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:isCreated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isCreated () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if segment has just been created and is not revalidated for the first time \par
}{
References Katabatic::SegCreated.}\par
{
Referenced by AutoContactTerminal::updateGeometry().}\par
}
{\xe \v isCanonical\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:isCanonical}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isCanonical () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if segment is the representant of an aligned set. \par
}{
References Katabatic::SegCanonical.}\par
{
Referenced by AutoHorizontal::_makeDogleg(), AutoVertical::_makeDogleg(), AutoSegment::canonize(), AutoSegment::getCanonical(), AutoSegment::setAxis(), AutoSegment::toConstraintAxis(), and AutoSegment::toOptimalAxis().}\par
}
{\xe \v isUnsetAxis\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:isUnsetAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isUnsetAxis () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the segment axis has never been set. \par
}{
References Katabatic::SegAxisSet.}\par
}
{\xe \v isSlackened\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:isSlackened}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isSlackened () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the segment has already been slackened. \par
}{
References Katabatic::SegSlackened.}\par
{
Referenced by AutoHorizontal::_makeDogleg(), and AutoVertical::_makeDogleg().}\par
}
{\xe \v _canSlacken\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:_canSlacken}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool _canSlacken () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the segment can be slackened. That is, source or target constraints are less than three pitches. \par
}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMO \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by AutoSegment::canSlacken().}\par
}
{\xe \v canReduce\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:canReduce}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool canReduce () const}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the segment can be reduced. That is:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Source & target are {\b AutoContactTurn}.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
It is either {\i spin top}  or {\i spin bottom} , that is connecting perpandiculars both in the same layer.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Has a length less or equal one pitch in the perpandicular direction.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Neither of the perpandicular are also reduceds. \par}
}{
References AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoSegment::getLength(), AutoSegment::isGlobal(), AutoSegment::isSpinBottom(), AutoSegment::isSpinTop(), AutoSegment::isSpinTopOrBottom(), and AutoContact::isTurn().}\par
{
Referenced by AutoSegment::reduce().}\par
}
{\xe \v mustRaise\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:mustRaise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool mustRaise () const}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the segment must {\i be}  reduced. That is:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
It is in reduced state...\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
It is no longer {\i spin top}  or {\i spin bottom} .\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
It's length exceed one pitch in the perpandicular direction. \par}
}{
References AutoSegment::getLength(), AutoSegment::isSpinBottom(), AutoSegment::isSpinTop(), and Katabatic::SegIsReduced.}\par
}
{\xe \v canDogleg\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:canDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int canDogleg ({\b Interval}  {\i interval})}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  non-zero if the aligned set of segment can be broken {\i outside}  {\f2 interval} . The returned value could be zero (failure) or {\b Katabatic::KbDoglegOnLeft} or {\b Katabatic::KbDoglegOnRight} menaing that the aligned set could be broken on the left of the {\f2 interval}  (resp. right of it). \par
}{
References Interval::contains(), AutoSegment::getAligneds(), AutoSegment::getSpanU(), Interval::getVMax(), Interval::getVMin(), Katabatic::KbDoglegOnLeft, and Katabatic::KbDoglegOnRight.}\par
}
{\xe \v canMoveULeft\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:canMoveULeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool canMoveULeft (float  {\i reserve} = {\f2 0.0}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b true}  if the {\i global}  segment can be moved on the left {\b GCell} (for a vertical) or down (for an horizontal). The move is accepted only if it do not change the amount of global wiring. Thus the following conditions:{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The segment mustn't be on the leftmost {\b GCell} (obvious...).\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The segment must be global.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The source and target contacts must be AutoContactTurn(s).\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
At least one of the perpandicular must be global {\b and}  connected through the {\i target} . That is, it's a global which extends toward left.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The {\b GCell} of maximum density on the left must remains below the current {\b GCell} of maximum density, with a margin of {\f2 reserve}  (expressed in total saturation percentage). \par}
}}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMS \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v canMoveURight\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:canMoveURight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool canMoveURight (float  {\i reserve} = {\f2 0.0}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b true}  if the {\i global}  segment can be moved on the right {\b GCell} (for a vertical) or up (for an horizontal). The move is accepted only if it do not change the amount of global wiring. Thus the following conditions:{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The segment mustn't be on the leftmost {\b GCell} (obvious...).\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The segment must be global.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The source and target contacts must be AutoContactTurn(s).\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
At least one of the perpandicular must be global {\b and}  connected through the {\i source} . That is, it's a global which extends toward right.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The {\b GCell} of maximum density on the left must remains below the current {\b GCell} of maximum density, with a margin of {\f2 reserve}  (expressed in total saturation percentage). \par}
}}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMT \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v canMoveUp\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:canMoveUp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool canMoveUp (float  {\i reserve} = {\f2 0.0}, unsigned int  {\i flags} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i reserve} \cell }{Number of track that must remains free {\i after}  the move. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i flags} \cell }{Modificate the method behavior, see below. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b true}  if the segment can be moved up, that is to the next layer above in the same preferred routing direction. This method will check that in every {\b GCell} of the segment, at least {\f2 reserve}  tracks are still avalaible {\i after}  the segment has been moved up ({\f2 reserve}  can be less than {\f2 1.0} ).\par
}Possible (bitwise) value for {\f2 flags}  :{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 KbAllowTerminal}  : allow strong terminal to be moved up.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 KbAllowLocal}  : allow local segments to be moved up.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 KbPropagate}  : perform the check on the whole aligned set.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 KbWithPerpands}  : also check the density on the perpandiculars begin & end {\b GCell}, there must be at least a {\f2 0.5}  density reserve on them. \par}
}{
References AutoSegment::getAligneds(), AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), Session::getConfiguration(), GCell::getFragmentation(), AutoSegment::getGCells(), GCell::getIndex(), AutoSegment::getLayer(), RoutingGauge::getLayerDepth(), Session::getRoutingGauge(), AutoSegment::isFixed(), AutoSegment::isLayerChange(), AutoSegment::isLocal(), AutoSegment::isStrongTerminal(), Katabatic::KbPropagate, and Katabatic::KbWithPerpands.}\par
}
{\xe \v canPivotUp\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:canPivotUp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool canPivotUp (float  {\i reserve} = {\f2 0.0}, unsigned int  {\i flags} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i reserve} \cell }{Number of track that must remains free {\i after}  the move. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i flags} \cell }{Modificate the method behavior, see below.\cell }
{\row }
}
Checks of the segment can be {\i pivoted}  up. The difference between {\f2 {\b canMoveUp()}}  and {\f2 {\b canPivotUp()}}  lies in the fact that no perpandicular segment needs to be altered if the current segment is moved up. For example an {\b M3}  segment connected to only {\b M4}  can be pivoted up (in {\b M5} ), but if connected to {\b M2} , it cannot.\par
Possible (bitwise) value for {\f2 flags}  :{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 KbPropagate}  : perform the check on the whole aligned set.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 KbIgnoreContacts}  : do not check the source & target layers to know if the segment can be pivoted up. \par}
}{
References AutoSegment::getAligneds(), AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoSegment::getGCells(), AutoSegment::getLayer(), RoutingGauge::getLayerDepth(), AutoContact::getMinDepth(), Session::getRoutingGauge(), AutoSegment::isFixed(), AutoSegment::isLayerChange(), AutoSegment::isLocal(), AutoSegment::isStrongTerminal(), and Katabatic::KbPropagate.}\par
}
{\xe \v canPivotDown\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:canPivotDown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool canPivotDown (float  {\i reserve} = {\f2 0.0}, unsigned int  {\i flags} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i reserve} \cell }{Number of track that must remains free {\i after}  the move. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i flags} \cell }{Modificate the method behavior, see below.\cell }
{\row }
}
Checks of the segment can be {\i pivoted}  down. The difference between {\f2 canMoveDown()}  and {\f2 {\b canPivotDown()}}  lies in the fact that no perpandicular segment needs to be altered if the current segment is moved down.\par
Possible (bitwise) value for {\f2 flags}  :{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 KbPropagate}  : perform the check on the whole aligned set. \par}
}{
References AutoSegment::getAligneds(), AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoSegment::getGCells(), AutoSegment::getLayer(), RoutingGauge::getLayerDepth(), AutoContact::getMaxDepth(), Session::getRoutingGauge(), AutoSegment::isFixed(), AutoSegment::isLayerChange(), AutoSegment::isLocal(), AutoSegment::isStrongTerminal(), and Katabatic::KbPropagate.}\par
}
{\xe \v canSlacken\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:canSlacken}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool canSlacken (unsigned int  {\i flags} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the segment can be slackened. That is, source or target constraints are less than three pitches.\par
If {\f2 flags}  contains KbPropagate, look on the whole aligned set. \par
}{
References AutoSegment::_canSlacken(), AutoSegment::getAligneds(), AutoSegment::isGlobal(), and Katabatic::KbPropagate.}\par
}
{\xe \v checkPositions\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:checkPositions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool checkPositions () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the relative positions of source & target are coherent. (source <= target). \par
}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMY \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v checkConstraints\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:checkConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool checkConstraints () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the constraint intervel is coherent (non-empty or punctual in the worst case). \par
}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMZ \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getId\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long getId () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} unique identifier. \par
}{
Referenced by AutoHorizontal::_preDestroy(), and AutoVertical::_preDestroy().}\par
}
{\xe \v getDirection\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getDirection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getDirection () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b Katabatic::KbHorizontal} or {\b Katabatic::KbVertical} according to the decorated segment. \par
}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAANB \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by AutoSegment::getMinSpanU(), AutoSegment::getPerpandicularsBound(), and AutoSegment::makeDogleg().}\par
}
{\xe \v getGCell\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getGCell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GCell} * getGCell () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b GCell} into which the {\b AutoSegment} starts (the one of the source). \par
}{
Referenced by AutoHorizontal::canMoveULeft(), AutoVertical::canMoveULeft(), AutoHorizontal::canMoveURight(), AutoVertical::canMoveURight(), AutoHorizontal::getGCells(), AutoVertical::getGCells(), AutoHorizontal::moveULeft(), AutoVertical::moveULeft(), AutoHorizontal::moveURight(), and AutoVertical::moveURight().}\par
}
{\xe \v getGCells\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getGCells}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getGCells (vector< {\b GCell} *> &  {\i gcells}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i gcells} \cell }{A vector that will be filled by all the GCells that the segment overlap. In increasing order, from source to target. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The vector's size. \par
}}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAND \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by AutoSegment::canMoveUp(), AutoSegment::canPivotDown(), and AutoSegment::canPivotUp().}\par
}
{\xe \v getAutoSource\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getAutoSource}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoContact} * getAutoSource () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The source {\b AutoContact}. \par
}{
References AutoSegment::getSource(), and Session::lookup().}\par
{
Referenced by AutoHorizontal::_canSlacken(), AutoVertical::_canSlacken(), AutoHorizontal::_makeDogleg(), AutoVertical::_makeDogleg(), AutoHorizontal::_postCreate(), AutoVertical::_postCreate(), AutoHorizontal::_preDestroy(), AutoVertical::_preDestroy(), AutoHorizontal::canMoveULeft(), AutoVertical::canMoveULeft(), AutoSegment::canMoveUp(), AutoHorizontal::canMoveURight(), AutoVertical::canMoveURight(), AutoSegment::canPivotDown(), AutoSegment::canPivotUp(), AutoSegment::canReduce(), AutoHorizontal::checkConstraints(), AutoVertical::checkConstraints(), AutoSegment::computeOptimal(), AutoSegment::computeTerminal(), AutoHorizontal::getConstraints(), AutoVertical::getConstraints(), AutoHorizontal::getGCells(), AutoVertical::getGCells(), AutoHorizontal::getSourceConstraints(), AutoVertical::getSourceConstraints(), AutoSegment::makeDogleg(), AutoHorizontal::moveULeft(), AutoVertical::moveULeft(), AutoHorizontal::moveURight(), AutoVertical::moveURight(), AutoSegment::raise(), AutoSegment::reduce(), AutoSegment::reduceDoglegLayer(), AutoSegment::revalidate(), and AutoSegment::toConstraintAxis().}\par
}
{\xe \v getAutoTarget\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getAutoTarget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoContact} * getAutoTarget () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The target {\b AutoContact}. \par
}{
References AutoSegment::getTarget(), and Session::lookup().}\par
{
Referenced by AutoHorizontal::_canSlacken(), AutoVertical::_canSlacken(), AutoHorizontal::_makeDogleg(), AutoVertical::_makeDogleg(), AutoHorizontal::_postCreate(), AutoVertical::_postCreate(), AutoHorizontal::_preDestroy(), AutoVertical::_preDestroy(), AutoHorizontal::canMoveULeft(), AutoVertical::canMoveULeft(), AutoSegment::canMoveUp(), AutoHorizontal::canMoveURight(), AutoVertical::canMoveURight(), AutoSegment::canPivotDown(), AutoSegment::canPivotUp(), AutoSegment::canReduce(), AutoHorizontal::checkConstraints(), AutoVertical::checkConstraints(), AutoSegment::computeOptimal(), AutoSegment::computeTerminal(), AutoHorizontal::getConstraints(), AutoVertical::getConstraints(), AutoHorizontal::getGCells(), AutoVertical::getGCells(), AutoHorizontal::getTargetConstraints(), AutoVertical::getTargetConstraints(), AutoSegment::makeDogleg(), AutoHorizontal::moveULeft(), AutoVertical::moveULeft(), AutoHorizontal::moveURight(), AutoVertical::moveURight(), AutoSegment::raise(), AutoSegment::reduce(), AutoSegment::reduceDoglegLayer(), and AutoSegment::revalidate().}\par
}
{\xe \v getOppositeAnchor\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getOppositeAnchor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoContact} * getOppositeAnchor ({\b AutoContact} *  {\i contact}) const}}
\par
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The source or target {\b AutoContact} opposite to {\f2 contact} . \par
}{
References AutoContact::base(), AutoSegment::getOppositeAnchor(), and Session::lookup().}\par
}
{\xe \v getPerpandicularsBound\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getPerpandicularsBound}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getPerpandicularsBound (set< {\b AutoSegment} *> &  {\i bounds})}}
\par
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bounds} \cell }{A vector that will be filled by all the AutoSegments perpandicular to this one that induce a constraint. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The vector's size. \par
}}{
References AutoSegment::getDirection(), Component::getSlaveComponents(), Collection< Type >::getSubSet(), and Session::lookup().}\par
}
{\xe \v getParent\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getParent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * getParent () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  If this segment has been created by a dogleg operation, the parent is the one from which we fragmented. \par
}}
{\xe \v getAxis\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getAxis () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} axis position. \par
}{
References AutoSegment::base(), Component::getX(), Component::getY(), and AutoSegment::isHorizontal().}\par
{
Referenced by AutoSegment::computeOptimal(), AutoSegment::setAxis(), AutoSegment::toConstraintAxis(), and AutoSegment::toOptimalAxis().}\par
}
{\xe \v getSourceU\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getSourceU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getSourceU () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} {\i uniform}  source position. (X for an horizontal and Y for a Vertical). \par
}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAANK \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getTargetU\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getTargetU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getTargetU () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} {\i uniform}  target position. (X for an horizontal and Y for a Vertical). \par
}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAANL \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getDuSource\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getDuSource}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getDuSource () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} {\i uniform}  delta from source. (dX for an horizontal and dY for a Vertical). \par
}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAANM \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getDuTarget\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getDuTarget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getDuTarget () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} {\i uniform}  delta from source. (dX for an horizontal and dY for a Vertical). \par
}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAANN \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getOrigin\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getOrigin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getOrigin () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} {\i uniform}  source (lowest) {\b GCell} coordinate. (dX for an horizontal and dY for a Vertical). \par
}{
References GCell::getX(), GCell::getY(), and AutoSegment::isHorizontal().}\par
{
Referenced by AutoSegment::computeOptimal(), AutoSegment::getOptimalMax(), AutoSegment::getOptimalMin(), AutoSegment::setOptimalMax(), and AutoSegment::setOptimalMin().}\par
}
{\xe \v getExtremity\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getExtremity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getExtremity () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} {\i uniform}  target (greatest) {\b GCell} coordinate. (dX for an horizontal and dY for a Vertical). \par
}{
References GCell::getXMax(), GCell::getYMax(), and AutoSegment::isHorizontal().}\par
{
Referenced by AutoSegment::computeOptimal().}\par
}
{\xe \v getSpanU\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getSpanU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getSpanU () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} {\i uniform}  occupying interval (on X for horizontal and on Y for vertical). \par
}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAANQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by AutoSegment::canDogleg(), and AutoSegment::makeDogleg().}\par
}
{\xe \v getMinSpanU\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getMinSpanU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getMinSpanU () const}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The {\b AutoSegment} {\i uniform}  minimum occupying interval, computed from the constraints of all the supporting aligned AutoContacts. (on X for horizontal and on Y for vertical). \par
}}{
References AutoSegment::getDirection(), Interval::getVMax(), and Interval::getVMin().}\par
}
{\xe \v getSourceConstraints\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getSourceConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getSourceConstraints (unsigned int  {\i flags} = {\f2 0}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The Interval into witch the source {\b AutoContact} can vary. By default all deduced constraints and user constraints are took into account. If {\f2 flags}  contains {\f2 KbNativeConstraints}  the constraint returned is only the enclosing {\b GCell}. \par
}}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAANS \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by AutoSegment::makeDogleg().}\par
}
{\xe \v getTargetConstraints\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getTargetConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getTargetConstraints (unsigned int  {\i flags} = {\f2 0}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The Interval into witch the target {\b AutoContact} can vary. By default all deduced constraints and user constraints are took into account. If {\f2 flags}  contains {\f2 KbNativeConstraints}  the constraint returned is only the enclosing {\b GCell}. \par
}}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAANT \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by AutoSegment::makeDogleg().}\par
}
{\xe \v getConstraints\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool getConstraints ({\b DbU::Unit} &  {\i min}, {\b DbU::Unit} &  {\i max}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  in {\f2 min}  & {\f2 max}  the allowed range for the segment axis. \par
}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAANU \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by AutoSegment::computeOptimal(), AutoSegment::getConstraints(), AutoSegment::getSlack(), AutoSegment::toConstraintAxis(), and AutoSegment::toOptimalAxis().}\par
}
{\xe \v getConstraints\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool getConstraints ({\b Interval} &  {\i i}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  in {\f2 i}  the allowed range for the segment axis. \par
}{
References AutoSegment::getConstraints(), Interval::getVMax(), and Interval::getVMin().}\par
}
{\xe \v getUserConstraints\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getUserConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Interval} & getUserConstraints () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  A reference to the additional constraints added to the axis of the segment. \par
}{
Referenced by AutoHorizontal::getConstraints(), and AutoVertical::getConstraints().}\par
}
{\xe \v getSlack\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getSlack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getSlack () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The length of the axis constraint interval. \par
}{
References AutoSegment::getConstraints().}\par
}
{\xe \v getOptimalMin\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getOptimalMin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getOptimalMin () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} minimum axis optimal range. \par
}{
References AutoSegment::getOrigin(), and DbU::lambda().}\par
{
Referenced by AutoSegment::getCost(), AutoSegment::getOptimal(), and AutoSegment::toOptimalAxis().}\par
}
{\xe \v getOptimalMax\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getOptimalMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getOptimalMax () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} maximum axis optimal range. \par
}{
References AutoSegment::getOrigin(), and DbU::lambda().}\par
{
Referenced by AutoSegment::getCost(), AutoSegment::getOptimal(), and AutoSegment::toOptimalAxis().}\par
}
{\xe \v getOptimal\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getOptimal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} & getOptimal ({\b Interval} &  {\i i}) const}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inialize {\f2 i}  with the {\b AutoSegment} axis optimal range. \par
}{
References AutoSegment::getOptimalMax(), AutoSegment::getOptimalMin(), Interval::getVMax(), and Interval::getVMin().}\par
}
{\xe \v getCost\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getCost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getCost ({\b DbU::Unit}  {\i axis}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The cost if this segment is placed at {\f2 axis} . The cost is null if {\f2 axis}  is inside the optimal interval and is the distance toward the nearest bound outside. \par
}}{
References AutoSegment::getOptimalMax(), and AutoSegment::getOptimalMin().}\par
}
{\xe \v getCanonical\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getCanonical}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * getCanonical ({\b DbU::Unit} &  {\i min}, {\b DbU::Unit} &  {\i max}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The canonical segment associated to this one. Additionnaly compute the source & target position of the whole set of aligned segments. \par
}}{
References AutoSegment::base(), AutoSegment::getAligneds(), AutoSegment::getSourcePosition(), AutoSegment::getTargetPosition(), and AutoSegment::isCanonical().}\par
{
Referenced by AutoSegment::getCanonical().}\par
}
{\xe \v getCanonical\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getCanonical}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * getCanonical ({\b Interval} &  {\i i}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The canonical segment associated to this one. Additionnaly compute the source & target position of the whole set of aligned segments. \par
}}{
References AutoSegment::getCanonical(), Interval::getVMax(), and Interval::getVMin().}\par
}
{\xe \v unsetFlags\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:unsetFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void unsetFlags (unsigned int  {\i flags}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unsets {\f2 flags}  given as arguments. \par
}{
Referenced by AutoHorizontal::_makeDogleg(), AutoVertical::_makeDogleg(), AutoSegment::canonize(), AutoSegment::computeTerminal(), AutoHorizontal::moveULeft(), AutoVertical::moveULeft(), AutoHorizontal::moveURight(), AutoVertical::moveURight(), AutoSegment::revalidate(), AutoHorizontal::updateOrient(), and AutoVertical::updateOrient().}\par
}
{\xe \v setFlags\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:setFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setFlags (unsigned int  {\i flags}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets {\f2 flags}  given as arguments. \par
}{
Referenced by AutoSegment::_invalidate(), AutoHorizontal::_makeDogleg(), AutoVertical::_makeDogleg(), AutoHorizontal::_postCreate(), AutoVertical::_postCreate(), AutoSegment::AutoSegment(), AutoSegment::canonize(), AutoSegment::computeTerminal(), GCellTopology::doRp_AutoContacts(), AutoSegment::invalidate(), AutoHorizontal::moveULeft(), AutoVertical::moveULeft(), AutoHorizontal::moveURight(), AutoVertical::moveURight(), AutoSegment::revalidate(), AutoHorizontal::updateOrient(), and AutoVertical::updateOrient().}\par
}
{\xe \v setDuSource\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:setDuSource}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setDuSource ({\b DbU::Unit}  {\i du}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the {\i uniform}  {\f2 dU}  from source anchor (dX for Horizontal, dY for Vertical). \par
}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOG \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v setDuTarget\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:setDuTarget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setDuTarget ({\b DbU::Unit}  {\i du}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the {\i uniform}  {\f2 dU}  from target anchor (dX for Horizontal, dY for Vertical). \par
}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOH \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v computeTerminal\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:computeTerminal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void computeTerminal ()}}
\par
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Recompute the terminal status of an {\b AutoSegment}. Initially, a segment which source or target is a terminal is flagged as SegStrongTerminal. After a topological modification, if the segment is no longer directly attached to a terminal, the status is progessively weakened. Once it reaches the weakest level, it stays on it so the algorithm can work out which segments is a start to a path toward a terminal.\par
Status from stronger to weaker:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Katabatic::SegStrongTerminal}.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Katabatic::SegWeakTerminal1}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Katabatic::SegWeakTerminal2}\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: The weakening is poorly done. After making a dogleg we do not\par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid know which of the segment must be weakened if not directly attached on a terminal. We must examinate source & target. \par
}}{
References AutoSegment::_getFlags(), AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), Katabatic::SegWeakTerminal, Katabatic::SegWeakTerminal1, Katabatic::SegWeakTerminal2, AutoSegment::setFlags(), and AutoSegment::unsetFlags().}\par
}
{\xe \v updateOrient\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:updateOrient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateOrient (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ensure that source is lower than target. Swap them if needed. Swap never occurs on global segment because their source and target anchors are from different {\b GCell}, which are already ordered. \par
}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by AutoSegment::_postCreate(), and AutoSegment::revalidate().}\par
}
{\xe \v updatePositions\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:updatePositions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updatePositions (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update the segment begenning and ending positions. The positions takes into account the extension caps and reflect the real space used by the segment under it's long axis. \par
}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOK \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by AutoSegment::_postCreate(), and AutoSegment::revalidate().}\par
}
{\xe \v mergeUserConstraints\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:mergeUserConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void mergeUserConstraints (const {\b Interval} &  {\i constraints})}}
\par
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constraints applies on the valid axis interval. Merge in {\f2 constraints}  with the user's constraints. The resulting constraints is the intersection of the former user's contraints and the one given as argument. \par
}{
References Interval::intersection().}\par
}
{\xe \v resetUserConstraints\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:resetUserConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void resetUserConstraints (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constraints applies on the valid axis interval. Suppress all user's constraints. \par
}}
{\xe \v setOptimalMin\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:setOptimalMin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setOptimalMin ({\b DbU::Unit}  {\i min}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the lower bound of the optimal axis interval. \par
}{
References DbU::getLambda(), and AutoSegment::getOrigin().}\par
{
Referenced by AutoSegment::computeOptimal().}\par
}
{\xe \v setOptimalMax\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:setOptimalMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setOptimalMax ({\b DbU::Unit}  {\i max}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the lower bound of the optimal axis interval. \par
}{
References DbU::getLambda(), and AutoSegment::getOrigin().}\par
{
Referenced by AutoSegment::AutoSegment(), and AutoSegment::computeOptimal().}\par
}
{\xe \v revalidate\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:revalidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} revalidate ()}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mark this segment as valid (unset the Invalidated flag) and update positions. Unlike {\b AutoSegment::invalidate()}, it's an atomic method. \par
}{
References AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoContact::getLayer(), AutoSegment::getLayer(), AutoContact::getPerpandicular(), Layer::getTop(), AutoSegment::isInvalidated(), AutoSegment::isReduced(), AutoContact::isTurn(), Observable::notify(), Katabatic::SegCreated, Katabatic::SegInvalidated, Katabatic::SegInvalidatedLayer, Katabatic::SegSourceBottom, Katabatic::SegSourceTop, Katabatic::SegTargetBottom, Katabatic::SegTargetTop, AutoSegment::setFlags(), AutoSegment::unsetFlags(), AutoSegment::updateOrient(), and AutoSegment::updatePositions().}\par
}
{\xe \v makeDogleg\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:makeDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * makeDogleg ({\b AutoContact} *  {\i from})}}
\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i from} \cell }{The {\b AutoContact} {\i from}  which we want to make a dogleg.\cell }
{\row }
}
This method is dedicated for the restauration of topology connexity on AutoContcact after a layer change on one of their connected {\b AutoSegment}.\par
It perform three operations:{
\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab Create a dogleg on the {\b AutoSegment} (using the normal {\b GCell} variant).\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab Adjust the layers of the dogleg according whether we are going {\i up}  or {\i down}  from the {\b AutoContact} {\f2 from}  to the segment.\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
3.\tab Returns the new {\b AutoSegment} connected to {\f2 from}  (it may be the same as before, {\b if}  the {\b AutoContact} is the source of the segment). \par}
}{
References Layer::contains(), AutoSegment::getAutoSource(), RoutingGauge::getContactLayer(), Session::getDoglegs(), AutoContact::getGCell(), AutoContact::getLayer(), AutoSegment::getLayer(), RoutingGauge::getLayerDepth(), Session::getRoutingGauge(), RoutingGauge::getRoutingLayer(), AutoContact::getX(), AutoContact::getY(), and AutoSegment::isHorizontal().}\par
{
Referenced by AutoContactTurn::updateTopology(), and AutoContactTerminal::updateTopology().}\par
}
{\xe \v makeDogleg\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:makeDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int makeDogleg ({\b Interval}  {\i interval}, unsigned int  {\i flags} = {\f2 KbNoFlags})}}
\par
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Make a dogleg {\i in a set of aligned segments} , thus the dogleg may not be created on {\f2 this}  segment but in one which span intersect {\f2 interval} .\par
{\b Returns:}  A set of flags telling if the break has occured on the left candidate ({\b Katabatic::KbDoglegOnLeft}) or right ({\b Katabatic::KbDoglegOnRight}). it is combined with the flag telling if the above or below layer was used for the dogleg. In case of failure, zero is returned.\par
Break the set of aligned segments so the break point is {\i outside}  {\f2 interval} . The break point so can occurs on the {\i left}  of the interval ({\b Katabatic::KbDoglegOnLeft}) or on the {\i right}  of the interval ({\b Katabatic::KbDoglegOnRight}). When the set of aligned segments fully enclose {\f2 interval} , a choice has to be made between the left and right candidate. The rules are as follow:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
A {\i left}  candidate include the {\i min}  of the interval into it's span.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
A {\i right}  candidate include the {\i max}  of the interval into it's span.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
In certain topologies, there can be more than left or right candidates (more than one segment of the set intersect the bounds of the interval). Thoses candidates are ecludeds.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
If the two candidates are avalaibles, we choose the one with the greated {\i native}  constraints.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
In case of strict equality, the left candidate is choosen.\par}
 \par
}{
References AutoSegment::_makeDogleg(), Interval::contains(), AutoSegment::getAligneds(), AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoSegment::getDirection(), Session::getDoglegs(), AutoContact::getGCell(), GCell::getRight(), GCell::getSide(), Interval::getSize(), AutoSegment::getSourceConstraints(), AutoSegment::getSpanU(), AutoSegment::getTargetConstraints(), GCell::getUp(), DbU::getValueString(), Interval::getVMax(), Interval::getVMin(), Katabatic::KbDoglegOnLeft, Katabatic::KbDoglegOnRight, Katabatic::KbHorizontal, and Katabatic::KbNativeConstraints.}\par
}
{\xe \v makeDogleg\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:makeDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int makeDogleg ({\b GCell} *  {\i doglegGCell}, unsigned int  {\i flags} = {\f2 KbNoFlags})}}
\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Make a dogleg {\i in a set of aligned segments} , thus the dogleg may not be created on {\f2 this}  segment but in the one which is under {\f2 doglegGCell} .\par
{\b Returns:}  A flag telling if the above or below layer was used for the perpandicular segment ({\b Katabatic::KbUseAboveLayer} or {\b Katabatic::KbUseBelowLayer}). \par
}{
References AutoSegment::_makeDogleg(), Katabatic::EngineGlobalLoaded, AutoSegment::getAligneds(), AutoSegment::getDirection(), Session::getKatabatic(), GCell::getSide(), AutoSegment::getSpanU(), Interval::intersect(), and AutoSegment::isFixed().}\par
}
{\xe \v _makeDogleg\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:_makeDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int _makeDogleg ({\b GCell} *  {\i doglegGCell}, unsigned int  {\i flags}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b This method is the workhorse for the various dogleg and topology restauration methods.}  It is the atomic method that actually make the dogleg on {\b this}  segment.\par
{\b Returns:}  {\b Katabatic::KbUseAboveLayer} if the dogleg is using the {\i above}  layer ({\b Katabatic::KbUseBelowLayer} for the below layer).\par
Break the current segment in two (a.k.a. making a dogleg).{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The segment is broken inside {\f2 doglegGCell} .\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Two new segments are createds, one perpandicular and one parallel.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The original segment is always kept attached to the {\i source} . (the new parallel fragment is attached to the {\i target} ).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The perpandicular segment is in the layer {\i above}  by default. If we are already on the topmost routing layer, the {\i below}  layer is used.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
If the segment pass through the breaking {\b GCell}, it's axis is set into the center. If the segment is local, the axis is the middle of the segment.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The Local/Global kind of the original segment is updated. The local/global status is computed by the constructor of the {\b AutoSegment} for the perpandicular and the new parallel.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The terminal state is updated. If the segment is a strong terminal the part that is no longer directly connected to the terminal is demoted to {\b Katabatic::SegWeakTerminal1}.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The perpandicular is obviously a canonical. If the broken segment is canonical, the original {\b is}  left canonical and only the new parallel is re-canonized. Otherwise, we re-canonise both sets of aligned segments (the one on the source and the one on the target).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The three segments are added to the session dogleg stack.\par}
After this method call the net topology is guarantee to be valid.\par
  \par
}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOT \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by AutoSegment::makeDogleg().}\par
}
{\xe \v moveULeft\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:moveULeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool moveULeft (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b This function do not manage an aligned set. It applies on {\f2 this}  segment only.} \par
Displace an Horizontal or Vertical segment to the {\b GCell} below (a.k.a. lower or inferior). Rules for displacement:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The segment must be connected at both end to a turn contact (we do not want to manage more complex cases for the time beeing).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
And, of course, the segment must not already by on the bottomost {\b GCell}...\par}
The displacement take care of:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Managing the status of the various perpandiculars. The stretched one are made global if needed. The shrinked one made local, if needed.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The supporting {\b AutoContact} (source & target) are changed of {\b GCell}.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
If the segment is global, the go-through GCells are updateds.\par}
{\b Returns:}  {\b true}  if the move has succeeded.\par
 \par
}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOU \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v moveURight\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:moveURight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool moveURight (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b This function do not manage an aligned set. It applies on {\f2 this}  segment only.} \par
Displace an Horizontal or Vertical segment to the {\b GCell} above (a.k.a. upper or superior). Rules for displacement:\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b AutoSegment::moveULeft()} for a complete description. \par
}}{
Implemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOV \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v slacken\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:slacken}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void slacken (unsigned int  {\i flags})}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the the {\b AutoSegment} is attached trough source and/or target to a terminal with too tight constraints, create a dogleg on overconstrained extremities.\par
If {\f2 flags}  contains {\b Katabatic::KbPropagate}, not only the current segment will be looked up, but the whole aligned set. Note that due to the structure of the database, there can be no more than two terminal connected segments on the whole set (one on each extremity).\par
If {\f2 flags}  contains {\b Katabatic::KbHalfSlacken}, the number of tracks under which the constraints are considered too tight is 3. Otherwise it is 10, that is a whole {\b GCell} side span. This flag should be used when a long set of global wire is overconstrained by only one of it's terminal, the other one offering sufficient slack (typically: 8).\par
The segment will also be slackened from it's terminal if the difference between the current slack (resulting from all the constraints of the aligned set) and the native slack is less than 3 tracks. This case means that we are already near the native slack and it not sufficent enough a degree of freedom.\par
 The {\f2 {\b slacken()}}  method reject the slackening of short locals as shown in figure {\b 2.a} . One way or another, we must connect to the terminal through {\b this}  short local. If we cannot place it, breaking it in two other short local wouldn't help. In fact, it will only clutter more the {\b GCell} and make subsequent routing more difficult.\par
The figures {\b 2.b}  and {\b 2.c}  shows the special case of slackening an horizontal from an {\i horizontal}  terminal. In the original configuration, the slack on segment {\f2 id:10}  is null, it's only choice is to be aligned with the terminal. If a slackening is requested, it generally implies that the horizontal track is blocked, and close to the terminal. Based on thoses hypothesis, when we slacken the segment {\f2 id:10}  we impose that the {\i source}  contact is {\b fixed}  on the terminal itself. That is, the segment {\f2 id:10}  will be reduced to a zero-length and we made an immediate turn (see {\b 2.c}  ).\par
 \par
}{
References AutoSegment::getAligneds(), and Katabatic::KbPropagate.}\par
}
{\xe \v reduceDoglegLayer\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:reduceDoglegLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool reduceDoglegLayer ()}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform the actual layer change on a reduced segment. This method is to be called juste before destroying the {\b Katabatic} database.\par
{\b Returns:}  {\b true}  if a change occurs. \par
}{
References AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), Session::getRoutingLayer(), AutoSegment::isReduced(), AutoSegment::isSpinBottom(), AutoSegment::isSpinTop(), AutoContact::setLayer(), and AutoSegment::setLayer().}\par
}
{\xe \v reduce\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:reduce}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool reduce ()}}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the segment into reduced state.\par
{\b Returns:}  {\b true}  if the operation did succeed. The layer will not be actually changed until the {\b Katabatic} database is saved/destroyed.\par
A segment can be reduced if:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Source & target are {\b AutoContactTurn}.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
It is either {\i spin top}  or {\i spin bottom} , that is connecting perpandiculars both in the same layer.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Has a length less or equal one pitch in the perpandicular direction.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Neither of the perpandicular are also reduceds.\par}
 If segment {\f2 id:12}  is reduced, it prevents {\f2 id:10}  & {\f2 id:14}  to be also reduced, by increasing the {\f2 _reduced}  counter. In this example {\f2 id:14}  is {\i spin top}  and {\f2 id:12}  is {\i spin bottom} .\par
If we reduce two adjacent segments, one will go up while the other will go down (they will actually exchange their layers), it will thus defeat the purpose of creating a {\i same layer}  dogleg. Besides, the turn contact between them will be changed into a pure metal one, generating a disconnexion...\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b AutoSegment::raise()} \par
}}{
References AutoSegment::canReduce(), AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoContact::getPerpandicular(), and Katabatic::SegIsReduced.}\par
}
{\xe \v raise\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:raise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool raise ()}}
\par
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a segment out of {\i reduced}  state.\par
{\b Returns:}  {\b true}  if a state change did really take place.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b AutoSegment::reduce()} \par
}}{
References AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoContact::getPerpandicular(), and Katabatic::SegIsReduced.}\par
}
{\xe \v canonize\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:canonize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * canonize (unsigned int  {\i flags} = {\f2 KbNoFlags})}}
\par
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Find and set the canonical {\b AutoSegment} from a set of aligneds. For the time beeing we assumes that there is no merging process, so the Segments will only gets more and more fragmented. This implies that a segment can become canonical but it will never revert to normal status.\par
The canonical {\b AutoSegment} is the one with the lowest {\f2 Id} . This a way of ensuring reproductible results. Note that the canonical one may not be the {\i geometrically}  lowest one.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: Canonical aware method. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}{
References AutoSegment::getAligneds(), AutoSegment::isCanonical(), AutoSegment::isGlobal(), Katabatic::SegCanonical, Katabatic::SegNotAligned, Katabatic::SegWeakGlobal, AutoSegment::setFlags(), and AutoSegment::unsetFlags().}\par
{
Referenced by AutoHorizontal::_makeDogleg(), and AutoVertical::_makeDogleg().}\par
}
{\xe \v invalidate\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:invalidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void invalidate (unsigned int  {\i flags} = {\f2 {\b KbPropagate}}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Invalidate this {\b AutoSegment}, or if the {\b Katabatic::KbPropagate} flags is set, the whole set of aligned segments.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: If Katabatic is in the destruction stage, this function does nothing.\par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: Canonical aware method. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}{
References AutoSegment::_invalidate(), AutoSegment::getAligneds(), AutoSegment::isInvalidated(), Katabatic::KbPropagate, Katabatic::KbSource, Katabatic::KbTarget, and AutoSegment::setFlags().}\par
{
Referenced by AutoHorizontal::_makeDogleg(), AutoVertical::_makeDogleg(), AutoSegment::_postCreate(), AutoContactVTee::updateTopology(), AutoContactTurn::updateTopology(), and AutoContactTerminal::updateTopology().}\par
}
{\xe \v computeOptimal\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:computeOptimal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} computeOptimal (set< {\b AutoSegment} *> &  {\i processeds})}}
\par
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i processeds} \cell }{A set of already processeds {\b AutoSegment}. Used by the caller function to avoid doing again the computation on an {\b AutoSegment} from an already proccessed aligned set. Compute the optimal axis interval for the aligned set.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: Canonical aware method. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}{
References AutoSegment::getAligneds(), AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoSegment::getAxis(), GCell::getBoundingBox(), GCell::getColumn(), AutoContact::getConstraintBox(), AutoSegment::getConstraints(), AutoSegment::getExtremity(), AutoSegment::getOrigin(), AutoSegment::getPerpandiculars(), GCell::getRow(), Box::getXMax(), Box::getXMin(), Box::getYMax(), Box::getYMin(), AutoSegment::isHorizontal(), AutoSegment::isVertical(), AutoSegment::setOptimalMax(), AutoSegment::setOptimalMin(), and DbU::toLambda().}\par
}
{\xe \v setAxis\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:setAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setAxis ({\b DbU::Unit}  {\i axis}, unsigned int  {\i flags} = {\f2 KbNoFlags})}}
\par
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i axis} \cell }{The new position of the axis. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i flags} \cell }{See KbRealignate.\cell }
{\row }
}
Set the axis of an aligned set. This method does nothing if not called on the canonical {\b AutoSegment} of the set. If the new value of the axis is equal to the previous one, nothing is done (non-canonical {\b AutoSegment} are not looked after). To force an actual axis set, with invalidation of the whole {\b AutoSegment} set, set the KbRealignate flag.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: Canonical aware method. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}{
References AutoSegment::getAligneds(), AutoSegment::getAxis(), AutoSegment::isCanonical(), AutoSegment::isHorizontal(), Katabatic::KbRealignate, and DbU::toLambda().}\par
{
Referenced by AutoHorizontal::moveULeft(), AutoVertical::moveULeft(), AutoHorizontal::moveURight(), AutoVertical::moveURight(), AutoSegment::toConstraintAxis(), and AutoSegment::toOptimalAxis().}\par
}
{\xe \v toConstraintAxis\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:toConstraintAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toConstraintAxis (unsigned int  {\i flags} = {\f2 {\b KbRealignate}})}}
\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the {\b AutoSegment} axis is outside the constraint interval, put it on nearest bound. This method is active only on canonical AutoSegments.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b true}  if an actual axis change is made.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: Canonical aware method. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}{
References AutoSegment::getAutoSource(), AutoSegment::getAxis(), AutoSegment::getConstraints(), AutoContact::getGCell(), Interval::getHalfSize(), GCell::getSide(), AutoSegment::isCanonical(), AutoSegment::isDogleg(), AutoSegment::isHorizontal(), Katabatic::KbHorizontal, Katabatic::KbVertical, and AutoSegment::setAxis().}\par
}
{\xe \v toOptimalAxis\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:toOptimalAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toOptimalAxis (unsigned int  {\i flags} = {\f2 {\b KbRealignate}})}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the {\b AutoSegment} axis is outside the optimal interval, put it on nearest bound. This method is active only on canonical AutoSegments.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b true}  if an actual axis change is made.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: Canonical aware method. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}{
References AutoSegment::getAxis(), AutoSegment::getConstraints(), AutoSegment::getOptimalMax(), AutoSegment::getOptimalMin(), AutoSegment::isCanonical(), Katabatic::KbRealignate, and AutoSegment::setAxis().}\par
}
{\xe \v getOnSourceContact\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getOnSourceContact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegments} getOnSourceContact (unsigned int  {\i direction})}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The Collection of {\b AutoSegment} in {\f2 direction}  that are on this segment source contact. \par
}{
References AutoSegment::getSource(), and Collection< Type >::getSubSet().}\par
}
{\xe \v getOnTargetContact\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getOnTargetContact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegments} getOnTargetContact (unsigned int  {\i direction})}}
\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The Collection of {\b AutoSegment} in {\f2 direction}  that are on this segment target contact. \par
}{
References Collection< Type >::getSubSet(), and AutoSegment::getTarget().}\par
}
{\xe \v getAligneds\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getAligneds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegments} getAligneds (unsigned int  {\i flags} = {\f2 KbNoFlags})}}
\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Collection of AutoSegments that are aligned on this one through {\b AutoContactHTee} or {\b AutoContactVTee}. If the {\f2 flags}  contains {\b Katabatic::KbWithPerpands}, the Collection will also includes the AutoSegments directly perpandiculars to the whole aligned set. \par
}{
Referenced by AutoSegment::canDogleg(), AutoSegment::canMoveUp(), AutoSegment::canonize(), AutoSegment::canPivotDown(), AutoSegment::canPivotUp(), AutoSegment::canSlacken(), AutoSegment::computeOptimal(), AutoSegment::getCanonical(), AutoSegment::invalidate(), AutoSegment::isStrongTerminal(), AutoSegment::makeDogleg(), AutoSegment::setAxis(), and AutoSegment::slacken().}\par
}
{\xe \v getPerpandiculars\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:getPerpandiculars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegments} getPerpandiculars ()}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Collection of all AutoSegments directly perpandiculars to the whole aligned set. \par
}{
Referenced by AutoSegment::computeOptimal().}\par
}
{\xe \v _preCreate\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:_preCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _preCreate ({\b AutoContact} *  {\i source}, {\b AutoContact} *  {\i target}){\f2 [static]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform sanity checks before allowing the actual creation of an {\b AutoSegment}. If an error occurs throw an exception.\par
Check for:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 source}  and {\f2 target}  must not be {\f2 NULL} .\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 source}  and {\f2 target}  must be different. \par}
}}
{\xe \v _postCreate\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:_postCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _postCreate (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform operations that, given the data structure cannot be done in the constructor. Also allows for sharing code with the derived classes. Currently:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Invalidate the whole net (topology change).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Insert the {\b AutoSegment} in the lookup/Session machanism.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Call {\b AutoSegment::invalidate()}.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Call {\b AutoSegment::updateOrient()}.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Call {\b AutoSegment::updatePositions()}. \par}
}{
Reimplemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPL \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoSegment::getNet(), Session::invalidate(), AutoSegment::invalidate(), Session::link(), Observable::notify(), AutoSegment::updateOrient(), and AutoSegment::updatePositions().}\par
{
Referenced by AutoHorizontal::_postCreate(), AutoVertical::_postCreate(), and AutoSegment::create().}\par
}
{\xe \v _preDestroy\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:_preDestroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _preDestroy (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform operations that must be done before the actual destructor is called. Merely whidrawn the {\b AutoSegment} from the lookup/Session mechanism. \par
}{
Reimplemented in {\b AutoVertical} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPM \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b AutoHorizontal} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References Observable::notify(), and Session::unlink().}\par
{
Referenced by AutoHorizontal::_preDestroy(), and AutoVertical::_preDestroy().}\par
}
{\xe \v _invalidate\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:_invalidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} _invalidate (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Invalidate this segment. The segment is scheduled into the {\b Session} revalidation mechanism. \par
}{
References Session::invalidate(), AutoSegment::isInvalidated(), Observable::notify(), Katabatic::SegInvalidated, and AutoSegment::setFlags().}\par
{
Referenced by AutoSegment::invalidate().}\par
}
{\xe \v _getFlags\:Katabatic::AutoSegment}
{\xe \v Katabatic::AutoSegment\:_getFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int _getFlags () const{\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets {\f2 flags}  given as arguments. \par
}{
Referenced by AutoSegment::computeTerminal().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoSegment.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoSegment.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoSegment.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AutoSegments_Aligneds Class Reference\par \pard\plain 
{\tc\tcl2 \v AutoSegments_Aligneds}
{\xe \v AutoSegments_Aligneds}
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All aligned {\b AutoSegment} of a set. }}\par
Inheritance diagram for AutoSegments_Aligneds:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKatabatic_1_1AutoSegments__Aligneds__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegments_Aligneds} ({\b AutoSegment} *, unsigned int flags=KbNoFlags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegments_Aligneds} (const {\b AutoSegments_Aligneds} &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegmentHC} * {\b getClone} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegmentHL} * {\b getLocator} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All aligned {\b AutoSegment} of a set. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Collection to iterate over all the {\b AutoSegment} aligned with {\f2 master} . The {\f2 master}  itself will not be included in the walkthrough. If the {\b Katabatic::KbWithPerpands} flag is passed as argument, the collection will also includes the AutoSegments directly perpandicular to the aligned set.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: AutoSegments are forced to be aligneds only when connected through\par
}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\b AutoContactHTee} or {\b AutoContactVTee}. \par
}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AutoSegments_Aligneds\:Katabatic::AutoSegments_Aligneds}
{\xe \v Katabatic::AutoSegments_Aligneds\:AutoSegments_Aligneds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegments_Aligneds} ({\b AutoSegment} *  {\i master}, unsigned int  {\i flags} = {\f2 KbNoFlags}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a collection of all the {\b AutoSegment} aligned on {\f2 master}  (master itself is excluded from the Collection). If the flag {\b Katabatic::KbWithPerpands} is given the directly perpandicular {\b AutoSegment} will also be includeds. \par
}}
{\xe \v AutoSegments_Aligneds\:Katabatic::AutoSegments_Aligneds}
{\xe \v Katabatic::AutoSegments_Aligneds\:AutoSegments_Aligneds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegments_Aligneds} (const {\b AutoSegments_Aligneds} &  {\i autosegments}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getClone\:Katabatic::AutoSegments_Aligneds}
{\xe \v Katabatic::AutoSegments_Aligneds\:getClone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegmentHC} * getClone () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  A deep copy of the Collection. \par
}{
Implements {\b Collection< Type >}.}\par
}
{\xe \v getLocator\:Katabatic::AutoSegments_Aligneds}
{\xe \v Katabatic::AutoSegments_Aligneds\:getLocator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegmentHC} * getLocator () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  A deep copy of the Collection Locator. \par
}{
Implements {\b Collection< Type >}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoSegments.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoSegments.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AutoSegments_AnchorOnGCell Class Reference\par \pard\plain 
{\tc\tcl2 \v AutoSegments_AnchorOnGCell}
{\xe \v AutoSegments_AnchorOnGCell}
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All {\b AutoSegment} Beginning and/or Stopping in a {\b GCell}. }}\par
Inheritance diagram for AutoSegments_AnchorOnGCell:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKatabatic_1_1AutoSegments__AnchorOnGCell__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegments_AnchorOnGCell} ({\b GCell} *fcell, unsigned int flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegments_AnchorOnGCell} (const {\b AutoSegments_AnchorOnGCell} &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegmentHC} * {\b getClone} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegmentHL} * {\b getLocator} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All {\b AutoSegment} Beginning and/or Stopping in a {\b GCell}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Collection to iterate over all the {\b AutoSegment} that begin from and/or end in a {\b GCell}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AutoSegments_AnchorOnGCell\:Katabatic::AutoSegments_AnchorOnGCell}
{\xe \v Katabatic::AutoSegments_AnchorOnGCell\:AutoSegments_AnchorOnGCell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegments_AnchorOnGCell} ({\b GCell} *  {\i fcell}, unsigned int  {\i flags}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a collection of all the {\b AutoSegment} beginning from and/or ending in {\f2 fcell} . The set returned by the Collection is selected through {\f2 flags}  :{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Katabatic::KbBySource : include {\b AutoSegment} starting from {\f2 fcell} .\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Katabatic::KbByTarget : include {\b AutoSegment} ending in {\f2 fcell} .\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Katabatic::KbHorizontal} : include horizontal {\b AutoSegment}.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Katabatic::KbVertical} : include vertical {\b AutoSegment}. \par}
}}
{\xe \v AutoSegments_AnchorOnGCell\:Katabatic::AutoSegments_AnchorOnGCell}
{\xe \v Katabatic::AutoSegments_AnchorOnGCell\:AutoSegments_AnchorOnGCell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegments_AnchorOnGCell} (const {\b AutoSegments_AnchorOnGCell} &  {\i autosegments}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getClone\:Katabatic::AutoSegments_AnchorOnGCell}
{\xe \v Katabatic::AutoSegments_AnchorOnGCell\:getClone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegmentHC} * getClone () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  A deep copy of the Collection. \par
}{
Implements {\b Collection< Type >}.}\par
}
{\xe \v getLocator\:Katabatic::AutoSegments_AnchorOnGCell}
{\xe \v Katabatic::AutoSegments_AnchorOnGCell\:getLocator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegmentHC} * getLocator () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  A deep copy of the Collection Locator. \par
}{
Implements {\b Collection< Type >}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoSegments.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoSegments.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AutoSegments_InDirection Class Reference\par \pard\plain 
{\tc\tcl2 \v AutoSegments_InDirection}
{\xe \v AutoSegments_InDirection}
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Filter to select {\b AutoSegment} in a given direction. }}\par
Inheritance diagram for AutoSegments_InDirection:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKatabatic_1_1AutoSegments__InDirection__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegments_InDirection} (unsigned int direction)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegmentHF} * {\b getClone} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b accept} ({\b AutoSegment} *segment) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Filter to select {\b AutoSegment} in a given direction. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Filter to select {\b AutoSegment} in a specific direction. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AutoSegments_InDirection\:Katabatic::AutoSegments_InDirection}
{\xe \v Katabatic::AutoSegments_InDirection\:AutoSegments_InDirection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegments_InDirection} (unsigned int  {\i direction}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a filter for {\b AutoSegment} in {\f2 direction}  ({\b Katabatic::KbHorizontal} or {\b Katabatic::KbVertical}). \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getClone\:Katabatic::AutoSegments_InDirection}
{\xe \v Katabatic::AutoSegments_InDirection\:getClone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegmentHF} * getClone () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  A deep copy of the Collection. \par
}{
Implements {\b Filter< Type >}.}\par
}
{\xe \v accept\:Katabatic::AutoSegments_InDirection}
{\xe \v Katabatic::AutoSegments_InDirection\:accept}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool accept ({\b AutoSegment} *  {\i segment}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the {\f2 segment}  is in the correct direction. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoSegments.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoSegments.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AutoSegments_IsAccountable Class Reference\par \pard\plain 
{\tc\tcl2 \v AutoSegments_IsAccountable}
{\xe \v AutoSegments_IsAccountable}
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Filter to select accoutable {\b AutoSegment}. }}\par
Inheritance diagram for AutoSegments_IsAccountable:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKatabatic_1_1AutoSegments__IsAccountable__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegmentHF} * {\b getClone} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b accept} ({\b AutoSegment} *) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Filter to select accoutable {\b AutoSegment}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Filter to select accoutable {\b AutoSegment}. An {\b AutoSegment} is said to be accountable if it is canonical (in the sense of an aligned set). \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getClone\:Katabatic::AutoSegments_IsAccountable}
{\xe \v Katabatic::AutoSegments_IsAccountable\:getClone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegmentHF} * getClone () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  A deep copy of the Collection. \par
}{
Implements {\b Filter< Type >}.}\par
}
{\xe \v accept\:Katabatic::AutoSegments_IsAccountable}
{\xe \v Katabatic::AutoSegments_IsAccountable\:accept}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool accept ({\b AutoSegment} *  {\i segment}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the {\f2 segment}  is accountable (i.e. canonical). \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoSegments.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoSegments.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AutoSegments_OnContact Class Reference\par \pard\plain 
{\tc\tcl2 \v AutoSegments_OnContact}
{\xe \v AutoSegments_OnContact}
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All {\b AutoSegment} anchored on a Contact. }}\par
Inheritance diagram for AutoSegments_OnContact:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKatabatic_1_1AutoSegments__OnContact__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegments_OnContact} ({\b AutoSegment} *master, {\b Contact} *contact)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegments_OnContact} (const {\b AutoSegments_OnContact} &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegmentHC} * {\b getClone} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegmentHL} * {\b getLocator} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All {\b AutoSegment} anchored on a Contact. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All {\b AutoSegment} Beginning from an {\b AutoContact}.\par
A Collection to iterate over all the {\b AutoSegment} anchored on {\f2 contact} . If supplied, the {\b AutoSegment} {\f2 master}  will be excluded from the list.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: If a Hurricane::Segment is anchored on the {\f2 contact} , but is not\par
}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid associated to an {\b AutoSegment}, it will be silently skipped.\par
}A Collection to iterate over all the {\b AutoSegment} that begin from {\b AutoContact}. As AutoSegments are kept orienteds (source anchor must be lower than target), selecting source anchored AutoSegments implies that they are starting from this {\b AutoContact}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AutoSegments_OnContact\:Katabatic::AutoSegments_OnContact}
{\xe \v Katabatic::AutoSegments_OnContact\:AutoSegments_OnContact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegments_OnContact} ({\b AutoSegment} *  {\i master}, {\b Contact} *  {\i contact}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i master} \cell }{Exclude this {\b AutoSegment} from the Collection. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i contact} \cell }{The Hurricane Contact over which to iterate.\cell }
{\row }
}
Construct a Collection of all the {\b AutoSegment} anchored on {\f2 contact} .\par
Create the collection of all AutoSegments direcly anchored on {\f2 contact} , with exclusion of {\f2 master} . \par
}}
{\xe \v AutoSegments_OnContact\:Katabatic::AutoSegments_OnContact}
{\xe \v Katabatic::AutoSegments_OnContact\:AutoSegments_OnContact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegments_OnContact} (const {\b AutoSegments_OnContact} &  {\i segments}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getClone\:Katabatic::AutoSegments_OnContact}
{\xe \v Katabatic::AutoSegments_OnContact\:getClone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegmentHC} * getClone () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  A deep copy of the Collection. \par
}{
Implements {\b Collection< Type >}.}\par
}
{\xe \v getLocator\:Katabatic::AutoSegments_OnContact}
{\xe \v Katabatic::AutoSegments_OnContact\:getLocator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegmentHC} * getLocator () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  A deep copy of the Collection Locator. \par
}{
Implements {\b Collection< Type >}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoSegments.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoSegments.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AutoSegments_Perpandiculars Class Reference\par \pard\plain 
{\tc\tcl2 \v AutoSegments_Perpandiculars}
{\xe \v AutoSegments_Perpandiculars}
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All perpandicular {\b AutoSegment} to a set of aligneds. }}\par
Inheritance diagram for AutoSegments_Perpandiculars:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKatabatic_1_1AutoSegments__Perpandiculars__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegments_Perpandiculars} ({\b AutoSegment} *master)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegments_Perpandiculars} (const {\b AutoSegments_Perpandiculars} &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegmentHC} * {\b getClone} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b AutoSegmentHL} * {\b getLocator} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All perpandicular {\b AutoSegment} to a set of aligneds. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Collection to iterate over all the {\b AutoSegment} perpandicular to the set of aligned {\b AutoSegment} of {\f2 master} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: This Collection is canonical aware (work on the aligned set).\par
}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \par
}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AutoSegments_Perpandiculars\:Katabatic::AutoSegments_Perpandiculars}
{\xe \v Katabatic::AutoSegments_Perpandiculars\:AutoSegments_Perpandiculars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegments_Perpandiculars} ({\b AutoSegment} *  {\i master}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a collection of all the {\b AutoSegment} perpandicular to the aligned set of {\f2 master} . \par
}}
{\xe \v AutoSegments_Perpandiculars\:Katabatic::AutoSegments_Perpandiculars}
{\xe \v Katabatic::AutoSegments_Perpandiculars\:AutoSegments_Perpandiculars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegments_Perpandiculars} (const {\b AutoSegments_Perpandiculars} &  {\i autosegments}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getClone\:Katabatic::AutoSegments_Perpandiculars}
{\xe \v Katabatic::AutoSegments_Perpandiculars\:getClone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegmentHC} * getClone () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  A deep copy of the Collection. \par
}{
Implements {\b Collection< Type >}.}\par
}
{\xe \v getLocator\:Katabatic::AutoSegments_Perpandiculars}
{\xe \v Katabatic::AutoSegments_Perpandiculars\:getLocator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegmentHC} * getLocator () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  A deep copy of the Collection Locator. \par
}{
Implements {\b Collection< Type >}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoSegments.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoSegments.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AutoVertical Class Reference\par \pard\plain 
{\tc\tcl2 \v AutoVertical}
{\xe \v AutoVertical}
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Concrete Vertical {\b AutoSegment}. }}\par
Inheritance diagram for AutoVertical:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKatabatic_1_1AutoVertical__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b _canSlacken} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canMoveULeft} (float reserve=0.0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canMoveURight} (float reserve=0.0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Segment} * {\b base} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Segment} * {\b base} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Vertical} * {\b getVertical} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b DbU::Unit} {\b getSourceU} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b DbU::Unit} {\b getTargetU} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b DbU::Unit} {\b getDuSource} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b DbU::Unit} {\b getDuTarget} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Interval} {\b getSpanU} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b getConstraints} ({\b DbU::Unit} &min, {\b DbU::Unit} &max) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Interval} {\b getSourceConstraints} (unsigned int flags=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Interval} {\b getTargetConstraints} (unsigned int flags=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b getDirection} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual size_t {\b getGCells} (vector< {\b GCell} *> &) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b setDuSource} ({\b DbU::Unit})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b setDuTarget} ({\b DbU::Unit})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateOrient} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updatePositions} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b checkPositions} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b checkConstraints} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b _makeDogleg} ({\b GCell} *, unsigned int flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b moveULeft} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b moveURight} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b _postCreate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b _preDestroy} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Concrete Vertical {\b AutoSegment}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v _canSlacken\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:_canSlacken}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool _canSlacken () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the segment can be slackened. That is, source or target constraints are less than three pitches. \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References Interval::contains(), AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoContact::getGCell(), GCell::getSide(), Interval::inflate(), and Katabatic::KbHorizontal.}\par
}
{\xe \v canMoveULeft\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:canMoveULeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool canMoveULeft (float  {\i reserve} = {\f2 0.0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b true}  if the {\i global}  segment can be moved on the left {\b GCell} (for a vertical) or down (for an horizontal). The move is accepted only if it do not change the amount of global wiring. Thus the following conditions:{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The segment mustn't be on the leftmost {\b GCell} (obvious...).\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The segment must be global.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The source and target contacts must be AutoContactTurn(s).\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
At least one of the perpandicular must be global {\b and}  connected through the {\i target} . That is, it's a global which extends toward left.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The {\b GCell} of maximum density on the left must remains below the current {\b GCell} of maximum density, with a margin of {\f2 reserve}  (expressed in total saturation percentage). \par}
}}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAII \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoContact::getGCell(), AutoSegment::getGCell(), AutoSegment::getLayer(), RoutingGauge::getLayerDepth(), GCell::getLeft(), Session::getRoutingGauge(), AutoContact::getSegment(), GCell::getUp(), GCell::getWDensity(), and AutoSegment::isGlobal().}\par
}
{\xe \v canMoveURight\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:canMoveURight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool canMoveURight (float  {\i reserve} = {\f2 0.0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b true}  if the {\i global}  segment can be moved on the right {\b GCell} (for a vertical) or up (for an horizontal). The move is accepted only if it do not change the amount of global wiring. Thus the following conditions:{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The segment mustn't be on the leftmost {\b GCell} (obvious...).\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The segment must be global.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The source and target contacts must be AutoContactTurn(s).\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
At least one of the perpandicular must be global {\b and}  connected through the {\i source} . That is, it's a global which extends toward right.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The {\b GCell} of maximum density on the left must remains below the current {\b GCell} of maximum density, with a margin of {\f2 reserve}  (expressed in total saturation percentage). \par}
}}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoContact::getGCell(), AutoSegment::getGCell(), AutoSegment::getLayer(), RoutingGauge::getLayerDepth(), GCell::getRight(), Session::getRoutingGauge(), AutoContact::getSegment(), GCell::getUp(), GCell::getWDensity(), and AutoSegment::isGlobal().}\par
}
{\xe \v base\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Segment} * base (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  the decorated {\b Hurricane::Segment}. \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v base\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Segment} * base () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  the decorated {\b Hurricane::Segment} (const flavor). \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getVertical\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:getVertical}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Vertical} * getVertical (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  If the decorated segment is a {\b Hurricane::Vertical}, return it. {\f2 NULL}  otherwise. \par
}{
Reimplemented from {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getSourceU\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:getSourceU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getSourceU () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} {\i uniform}  source position. (X for an horizontal and Y for a Vertical). \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References Segment::getSourceY().}\par
}
{\xe \v getTargetU\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:getTargetU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getTargetU () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} {\i uniform}  target position. (X for an horizontal and Y for a Vertical). \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References Segment::getTargetY().}\par
}
{\xe \v getDuSource\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:getDuSource}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getDuSource () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} {\i uniform}  delta from source. (dX for an horizontal and dY for a Vertical). \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References Vertical::getDySource().}\par
}
{\xe \v getDuTarget\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:getDuTarget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getDuTarget () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} {\i uniform}  delta from source. (dX for an horizontal and dY for a Vertical). \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References Vertical::getDyTarget().}\par
}
{\xe \v getSpanU\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:getSpanU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getSpanU () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b AutoSegment} {\i uniform}  occupying interval (on X for horizontal and on Y for vertical). \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References Segment::getSourceY(), and Segment::getTargetY().}\par
}
{\xe \v getConstraints\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:getConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool getConstraints ({\b DbU::Unit} &  {\i min}, {\b DbU::Unit} &  {\i max}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  in {\f2 min}  & {\f2 max}  the allowed range for the segment axis. \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoContact::getCBXMax(), AutoContact::getCBXMin(), AutoSegment::getUserConstraints(), and DbU::getValueString().}\par
}
{\xe \v getSourceConstraints\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:getSourceConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getSourceConstraints (unsigned int  {\i flags} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The Interval into witch the source {\b AutoContact} can vary. By default all deduced constraints and user constraints are took into account. If {\f2 flags}  contains {\f2 KbNativeConstraints}  the constraint returned is only the enclosing {\b GCell}. \par
}}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoSegment::getAutoSource(), Box::getXMax(), Box::getXMin(), and Katabatic::KbNativeConstraints.}\par
}
{\xe \v getTargetConstraints\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:getTargetConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getTargetConstraints (unsigned int  {\i flags} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The Interval into witch the target {\b AutoContact} can vary. By default all deduced constraints and user constraints are took into account. If {\f2 flags}  contains {\f2 KbNativeConstraints}  the constraint returned is only the enclosing {\b GCell}. \par
}}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoSegment::getAutoTarget(), Box::getXMax(), Box::getXMin(), and Katabatic::KbNativeConstraints.}\par
}
{\xe \v getDirection\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:getDirection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getDirection () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b Katabatic::KbHorizontal} or {\b Katabatic::KbVertical} according to the decorated segment. \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References Katabatic::KbVertical.}\par
}
{\xe \v getGCells\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:getGCells}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getGCells (vector< {\b GCell} *> &  {\i gcells}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i gcells} \cell }{A vector that will be filled by all the GCells that the segment overlap. In increasing order, from source to target. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The vector's size. \par
}}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoContact::getGCell(), AutoSegment::getGCell(), and GCell::getUp().}\par
}
{\xe \v setDuSource\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:setDuSource}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setDuSource ({\b DbU::Unit}  {\i du}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the {\i uniform}  {\f2 dU}  from source anchor (dX for Horizontal, dY for Vertical). \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v setDuTarget\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:setDuTarget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setDuTarget ({\b DbU::Unit}  {\i du}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the {\i uniform}  {\f2 dU}  from target anchor (dX for Horizontal, dY for Vertical). \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v updateOrient\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:updateOrient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateOrient (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ensure that source is lower than target. Swap them if needed. Swap never occurs on global segment because their source and target anchors are from different {\b GCell}, which are already ordered. \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References Segment::getSourceY(), Segment::getTargetY(), Segment::invert(), Katabatic::SegSourceBottom, Katabatic::SegSourceTop, Katabatic::SegTargetBottom, Katabatic::SegTargetTop, AutoSegment::setFlags(), and AutoSegment::unsetFlags().}\par
}
{\xe \v updatePositions\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:updatePositions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updatePositions (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update the segment begenning and ending positions. The positions takes into account the extension caps and reflect the real space used by the segment under it's long axis. \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References Session::getExtensionCap(), AutoSegment::getLayer(), Segment::getSourceY(), and Segment::getTargetY().}\par
}
{\xe \v checkPositions\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:checkPositions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool checkPositions () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the relative positions of source & target are coherent. (source <= target). \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References Session::getExtensionCap(), AutoSegment::getLayer(), Segment::getSourceY(), Segment::getTargetY(), and DbU::getValueString().}\par
}
{\xe \v checkConstraints\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:checkConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool checkConstraints () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the constraint intervel is coherent (non-empty or punctual in the worst case). \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), and Interval::intersect().}\par
}
{\xe \v _makeDogleg\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:_makeDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int _makeDogleg ({\b GCell} *  {\i doglegGCell}, unsigned int  {\i flags}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b This method is the workhorse for the various dogleg and topology restauration methods.}  It is the atomic method that actually make the dogleg on {\b this}  segment.\par
{\b Returns:}  {\b Katabatic::KbUseAboveLayer} if the dogleg is using the {\i above}  layer ({\b Katabatic::KbUseBelowLayer} for the below layer).\par
Break the current segment in two (a.k.a. making a dogleg).{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The segment is broken inside {\f2 doglegGCell} .\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Two new segments are createds, one perpandicular and one parallel.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The original segment is always kept attached to the {\i source} . (the new parallel fragment is attached to the {\i target} ).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The perpandicular segment is in the layer {\i above}  by default. If we are already on the topmost routing layer, the {\i below}  layer is used.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
If the segment pass through the breaking {\b GCell}, it's axis is set into the center. If the segment is local, the axis is the middle of the segment.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The Local/Global kind of the original segment is updated. The local/global status is computed by the constructor of the {\b AutoSegment} for the perpandicular and the new parallel.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The terminal state is updated. If the segment is a strong terminal the part that is no longer directly connected to the terminal is demoted to {\b Katabatic::SegWeakTerminal1}.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The perpandicular is obviously a canonical. If the broken segment is canonical, the original {\b is}  left canonical and only the new parallel is re-canonized. Otherwise, we re-canonise both sets of aligned segments (the one on the source and the one on the target).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The three segments are added to the session dogleg stack.\par}
After this method call the net topology is guarantee to be valid.\par
  \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoContact::base(), AutoSegment::canonize(), AutoContactTurn::create(), AutoSegment::create(), Session::dogleg(), AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), Session::getConfiguration(), RoutingGauge::getContactLayer(), AutoContact::getGCell(), Component::getLayer(), AutoSegment::getLayer(), RoutingGauge::getLayerDepth(), Component::getNet(), Session::getRoutingGauge(), RoutingGauge::getRoutingLayer(), AutoSegment::getSourceY(), AutoSegment::getTargetY(), GCell::getUp(), AutoSegment::getX(), GCell::getY(), GCell::getYMax(), AutoContact::invalidate(), AutoSegment::invalidate(), AutoSegment::isCanonical(), AutoSegment::isLocal(), AutoSegment::isSlackened(), AutoSegment::isWeakTerminal(), Katabatic::KbHorizontal, Katabatic::KbUseAboveLayer, Katabatic::KbUseBelowLayer, Katabatic::KbVertical, AutoContact::migrateConstraintBox(), GCell::removeVSegment(), Katabatic::SegCanonical, Katabatic::SegDogleg, Katabatic::SegGlobal, Katabatic::SegNotAligned, Katabatic::SegSlackened, Katabatic::SegWeakTerminal1, AutoSegment::setFlags(), AutoSegment::setLayer(), and AutoSegment::unsetFlags().}\par
}
{\xe \v moveULeft\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:moveULeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool moveULeft (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b This function do not manage an aligned set. It applies on {\f2 this}  segment only.} \par
Displace an Horizontal or Vertical segment to the {\b GCell} below (a.k.a. lower or inferior). Rules for displacement:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The segment must be connected at both end to a turn contact (we do not want to manage more complex cases for the time beeing).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
And, of course, the segment must not already by on the bottomost {\b GCell}...\par}
The displacement take care of:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Managing the status of the various perpandiculars. The stretched one are made global if needed. The shrinked one made local, if needed.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The supporting {\b AutoContact} (source & target) are changed of {\b GCell}.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
If the segment is global, the go-through GCells are updateds.\par}
{\b Returns:}  {\b true}  if the move has succeeded.\par
 \par
}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References GCell::addHSegment(), AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoContact::getGCell(), AutoSegment::getGCell(), GCell::getLeft(), AutoContact::getSegment(), GCell::getSide(), GCell::getUp(), Interval::getVMax(), AutoSegment::isLocal(), Katabatic::KbHorizontal, GCell::removeHSegment(), Katabatic::SegGlobal, AutoSegment::setAxis(), AutoSegment::setFlags(), AutoContact::setGCell(), and AutoSegment::unsetFlags().}\par
}
{\xe \v moveURight\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:moveURight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool moveURight (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b This function do not manage an aligned set. It applies on {\f2 this}  segment only.} \par
Displace an Horizontal or Vertical segment to the {\b GCell} above (a.k.a. upper or superior). Rules for displacement:\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b AutoSegment::moveULeft()} for a complete description. \par
}}{
Implements {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References GCell::addHSegment(), AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoContact::getGCell(), AutoSegment::getGCell(), GCell::getRight(), AutoContact::getSegment(), GCell::getSide(), GCell::getUp(), DbU::getValueString(), Interval::getVMin(), AutoSegment::isLocal(), Katabatic::KbHorizontal, GCell::removeHSegment(), Katabatic::SegGlobal, AutoSegment::setAxis(), AutoSegment::setFlags(), AutoContact::setGCell(), and AutoSegment::unsetFlags().}\par
}
{\xe \v _postCreate\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:_postCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _postCreate (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In addition to {\b AutoSegment::_postCreate()}, detect whether the segment is global or local and register it in the relevant GCells (if needed).\par
If the segment is anchored directly on a terminal, adjust the axis so it's connected. \par
}{
Reimplemented from {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoSegment::_postCreate(), GCell::addVSegment(), AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoContact::getGCell(), GCell::getUp(), Component::getX(), GCell::getY(), Katabatic::SegGlobal, AutoSegment::setFlags(), and AutoContact::setX().}\par
}
{\xe \v _preDestroy\:Katabatic::AutoVertical}
{\xe \v Katabatic::AutoVertical\:_preDestroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _preDestroy (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform operations that must be done before the actual destructor is called. Merely whidrawn the {\b AutoSegment} from the lookup/Session mechanism. \par
}{
Reimplemented from {\b AutoSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References AutoSegment::_preDestroy(), AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoContact::getGCell(), AutoSegment::getId(), GCell::getUp(), GCell::getY(), and GCell::removeVSegment().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoVertical.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoVertical.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoVertical.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
BaseGrid::Axis Class Reference\par \pard\plain 
{\tc\tcl2 \v BaseGrid::Axis}
{\xe \v BaseGrid::Axis}
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Graduations on a {\b BaseGrid} {\b Axis} (H or V). }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addGraduation} ({\b DbU::Unit})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sort} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getSize} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getGraduationNumber} ({\b DbU::Unit} pos, bool &onGraduation) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b DbU::Unit} & {\b operator[]} (unsigned int i) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Graduations on a {\b BaseGrid} {\b Axis} (H or V). \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Describe the list of graduations on either X or Y axis of a {\b BaseGrid}. Graduations correspond to cut lines and may not be evenly spaced.\par
Graduations are internally stored into a vector that needs to be sorted whenever new graduations are added ({\b BaseGrid::Axis::sort()}). \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addGraduation\:Katabatic::BaseGrid::Axis}
{\xe \v Katabatic::BaseGrid::Axis\:addGraduation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void addGraduation ({\b DbU::Unit}  {\i pos}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a new graduation. After adding new graduations, do not forget to perform a sort. \par
}{
Referenced by GCellGrid::_postCreate().}\par
}
{\xe \v sort\:Katabatic::BaseGrid::Axis}
{\xe \v Katabatic::BaseGrid::Axis\:sort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void sort ()}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Re-order the graduations after an addition. \par
}{
Referenced by GCellGrid::_postCreate().}\par
}
{\xe \v getSize\:Katabatic::BaseGrid::Axis}
{\xe \v Katabatic::BaseGrid::Axis\:getSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getSize () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The number of graduations on the axis. \par
}{
Referenced by GCellGrid::_postCreate().}\par
}
{\xe \v getGraduationNumber\:Katabatic::BaseGrid::Axis}
{\xe \v Katabatic::BaseGrid::Axis\:getGraduationNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getGraduationNumber ({\b DbU::Unit}  {\i pos}, bool &  {\i onGraduation}) const}}
\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The index of the graduation which is immediatly inferior or equal to {\f2 pos} . In case of strict equality, {\f2 onGraduation}  is set to {\b true} . \par
}}
{\xe \v operator[]\:Katabatic::BaseGrid::Axis}
{\xe \v Katabatic::BaseGrid::Axis\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} operator[] (unsigned int  {\i index}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The graduation at {\f2 index} . \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Grid.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Grid.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Grid.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
BaseGrid Class Reference\par \pard\plain 
{\tc\tcl2 \v BaseGrid}
{\xe \v BaseGrid}
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract Base Class for Irregular {\b Grid}. }}\par
Inheritance diagram for BaseGrid:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKatabatic_1_1BaseGrid__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Axis}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Graduations on a {\b BaseGrid} {\b Axis} (H or V). }\par}}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b destroy} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Box} & {\b getBoundingBox} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getColumns} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getRows} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getRawSize} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getIndex} (unsigned int c, unsigned int r) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getRow} (unsigned int) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getColumn} (unsigned int) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Axis} & {\b getXGrads} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Axis} & {\b getYGrads} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BaseGrid} (const {\b Box} &)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract Base Class for Irregular {\b Grid}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An abstract class for a 2-D matrix of objects. The grid is irregular in the sense that the horizontal and vertical cut lines may not be evenly spaced.\par
The coordinates of cut lines in horizontal and vertical direction are stored {\b BaseGrid::Axis} structure.\par
The {\b BaseGrid} contains all the non-template methods of the {\b Grid}, that is that do not depend of the matrix element type.\par
The internal storage implemented in derived classes is expected to store "row by row" (rows are put one after another in the vector). \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v BaseGrid\:Katabatic::BaseGrid}
{\xe \v Katabatic::BaseGrid\:BaseGrid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BaseGrid} (const {\b Box} &  {\i bb}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a new {\b BaseGrid} on area {\f2 bb} . Graduations, rows & columns are sets to zero. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v destroy\:Katabatic::BaseGrid}
{\xe \v Katabatic::BaseGrid\:destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void destroy (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The user-level destructor. \par
}}
{\xe \v getBoundingBox\:Katabatic::BaseGrid}
{\xe \v Katabatic::BaseGrid\:getBoundingBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Box} & getBoundingBox () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The grid bounding box. \par
}}
{\xe \v getColumns\:Katabatic::BaseGrid}
{\xe \v Katabatic::BaseGrid\:getColumns}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getColumns () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The numbers of columns in the grid. \par
}{
Referenced by GCellGrid::_postCreate(), KatabaticEngine::createDetailedGrid(), BaseGrid::getColumn(), BaseGrid::getIndex(), BaseGrid::getRawSize(), and BaseGrid::getRow().}\par
}
{\xe \v getRows\:Katabatic::BaseGrid}
{\xe \v Katabatic::BaseGrid\:getRows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getRows () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The numbers of rows in the grid. \par
}{
Referenced by GCellGrid::_postCreate(), KatabaticEngine::createDetailedGrid(), and BaseGrid::getRawSize().}\par
}
{\xe \v getRawSize\:Katabatic::BaseGrid}
{\xe \v Katabatic::BaseGrid\:getRawSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getRawSize () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The total number of elements in the grid (i.e. $ rows \times columns $) \par
}{
References BaseGrid::getColumns(), and BaseGrid::getRows().}\par
}
{\xe \v getIndex\:Katabatic::BaseGrid}
{\xe \v Katabatic::BaseGrid\:getIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getIndex (unsigned int  {\i c}, unsigned int  {\i r}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An helper function that compute the linear index in the element vector from a {\f2 } (c,r) coordinate pair: \[ index = c + r \times columns \] \par
}{
References BaseGrid::getColumns().}\par
{
Referenced by Grid< GCell >::getGCellDown(), Grid< GCell >::getGCellLeft(), Grid< GCell >::getGCellRight(), and Grid< GCell >::getGCellUp().}\par
}
{\xe \v getRow\:Katabatic::BaseGrid}
{\xe \v Katabatic::BaseGrid\:getRow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getRow (unsigned int  {\i i}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An helper function that compute the row number from the linear index in the vector: \[ row = index / columns \] \par
}{
References BaseGrid::getColumns().}\par
{
Referenced by GCell::getRow().}\par
}
{\xe \v getColumn\:Katabatic::BaseGrid}
{\xe \v Katabatic::BaseGrid\:getColumn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getColumn (unsigned int  {\i i}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An helper function that compute the column number from the linear index in the vector: \[ column = index \div columns \] \par
}{
References BaseGrid::getColumns().}\par
{
Referenced by GCell::getColumn().}\par
}
{\xe \v getXGrads\:Katabatic::BaseGrid}
{\xe \v Katabatic::BaseGrid\:getXGrads}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Axis} & getXGrads () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The graduations on the X axis. \par
}}
{\xe \v getYGrads\:Katabatic::BaseGrid}
{\xe \v Katabatic::BaseGrid\:getYGrads}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Axis} & getYGrads () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The graduations on the Y axis. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Grid.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Grid.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Grid.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
BaseObserver Class Reference\par \pard\plain 
{\tc\tcl2 \v BaseObserver}
{\xe \v BaseObserver}
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Observer} Design Pattern, {\b Observer} part. }}\par
Inheritance diagram for BaseObserver:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKatabatic_1_1BaseObserver__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b notify} (unsigned int flags)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Observer} Design Pattern, {\b Observer} part. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is used as a non-template base class for the templatized {\b Observer} one. It is used to avoid propagating template to the whole {\b Observable} class. It only contains the {\b Observer::notify()} virtual method. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v notify\:Katabatic::BaseObserver}
{\xe \v Katabatic::BaseObserver\:notify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void notify (unsigned int  {\i flags}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The method which will be called whenever a change occurs on the {\b Observable}. \par
}{
Referenced by Observable::notify().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Observer.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Observer.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Observer.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ChipTools Class Reference\par \pard\plain 
{\tc\tcl2 \v ChipTools}
{\xe \v ChipTools}
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Utilities for Chip Level Design. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ChipTools} ({\b Cell} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isChip} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Cell} * {\b getCell} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Instance} * {\b getCore} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Box} & {\b getChipBb} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Box} & {\b getLeftPadsBb} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Box} & {\b getRightPadsBb} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Box} & {\b getTopPadsBb} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Box} & {\b getBottomPadsBb} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const Torus & {\b getCorona} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b intersectVPads} (const {\b Box} &) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b intersectHPads} (const {\b Box} &) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Utilities for Chip Level Design. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b ChipTools} class provides a small set of utilities to ease the managment of a complete chip following the Alliance top hierarchical structure. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ChipTools\:Katabatic::ChipTools}
{\xe \v Katabatic::ChipTools\:ChipTools}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ChipTools} ({\b Cell} *  {\i cell})}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a ChipTool for {\f2 cell} . \par
}{
References Cell::getAbutmentBox(), Entity::getBoundingBox(), DataBase::getDB(), Box::getHeight(), Net::getHorizontals(), Technology::getLayer(), Instance::getMasterCell(), Instance::getName(), Cell::getName(), Cell::getNet(), DataBase::getTechnology(), Box::getWidth(), Box::getXMax(), Box::getXMin(), Box::getYMax(), Box::getYMin(), Box::inflate(), and ChipTools::isChip().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v isChip\:Katabatic::ChipTools}
{\xe \v Katabatic::ChipTools\:isChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isChip () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the Cell is truly a top level design. If not, this object is useless and does nothing. \par
}{
Referenced by ChipTools::ChipTools(), KatabaticEngine::createDetailedGrid(), and KatabaticEngine::isChip().}\par
}
{\xe \v getCell\:Katabatic::ChipTools}
{\xe \v Katabatic::ChipTools\:getCell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Cell} * getCell () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The top-level design. \par
}}
{\xe \v getCore\:Katabatic::ChipTools}
{\xe \v Katabatic::ChipTools\:getCore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Instance} * getCore () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The instance of the core, that is, the only instance that is {\i not}  a pad... \par
}}
{\xe \v getChipBb\:Katabatic::ChipTools}
{\xe \v Katabatic::ChipTools\:getChipBb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Box} & getChipBb () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The chip complete bounding box, this *is* simply the Cell bounding box. \par
}}
{\xe \v getLeftPadsBb\:Katabatic::ChipTools}
{\xe \v Katabatic::ChipTools\:getLeftPadsBb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Box} & getLeftPadsBb () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The bounding box enclosing all the pads on the left side of the chip.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: This box is computed from the chip bounding box and the pad height. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}}
{\xe \v getRightPadsBb\:Katabatic::ChipTools}
{\xe \v Katabatic::ChipTools\:getRightPadsBb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Box} & getRightPadsBb () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The bounding box enclosing all the pads on the right side of the chip.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: This box is computed from the chip bounding box and the pad height. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}}
{\xe \v getTopPadsBb\:Katabatic::ChipTools}
{\xe \v Katabatic::ChipTools\:getTopPadsBb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Box} & getTopPadsBb () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The bounding box enclosing all the pads on the top side of the chip.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: This box is computed from the chip bounding box and the pad height. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}}
{\xe \v getBottomPadsBb\:Katabatic::ChipTools}
{\xe \v Katabatic::ChipTools\:getBottomPadsBb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Box} & getBottomPadsBb () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The bounding box enclosing all the pads on the bottom side of the chip.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: This box is computed from the chip bounding box and the pad height. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}}
{\xe \v getCorona\:Katabatic::ChipTools}
{\xe \v Katabatic::ChipTools\:getCorona}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const Torus & getCorona () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The torus (in term of manhanttan distance) enclosed between the pad area and the core area. \par
}}
{\xe \v intersectVPads\:Katabatic::ChipTools}
{\xe \v Katabatic::ChipTools\:intersectVPads}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool intersectVPads (const {\b Box} &  {\i box}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if {\f2 box}  intersect either the left or right pad box. \par
}{
References Box::intersect().}\par
}
{\xe \v intersectHPads\:Katabatic::ChipTools}
{\xe \v Katabatic::ChipTools\:intersectHPads}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool intersectHPads (const {\b Box} &  {\i box}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if {\f2 box}  intersect either the top or bottom pad box. \par
}{
References Box::intersect().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
ChipTools.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
ChipTools.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
ChipTools.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GCell::CompareByDensity Class Reference\par \pard\plain 
{\tc\tcl2 \v GCell::CompareByDensity}
{\xe \v GCell::CompareByDensity}
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} Density Comparison Functor. }}\par
{
Inherits binary_function< GCell *, GCell *, bool >.}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CompareByDensity} (unsigned int depth)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} Density Comparison Functor. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A comparison functor for {\b GCell}, compare by density on layer {\f2 depth} . \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CompareByDensity\:Katabatic::GCell::CompareByDensity}
{\xe \v Katabatic::GCell::CompareByDensity\:CompareByDensity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CompareByDensity} (unsigned int  {\i depth})}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Build a density comparator for GCells on layer {\f2 depth} . \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
GCell.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
GCell.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
GCell.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GCell::CompareByIndex Class Reference\par \pard\plain 
{\tc\tcl2 \v GCell::CompareByIndex}
{\xe \v GCell::CompareByIndex}
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} Index Comparison Functor. }}\par
{
Inherits binary_function< const GCell *, const GCell *, bool >.}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} Index Comparison Functor. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A comparison functor for {\b GCell}, compare by {\f2 index}  (the linear index in the {\b GCellGrid} vector. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
GCell.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GCell Class Reference\par \pard\plain 
{\tc\tcl2 \v GCell}
{\xe \v GCell}
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Routing Global Cell. }}\par
{
Inherits ExtensionGo.}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CompareByDensity}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} Density Comparison Functor. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CompareByIndex}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} Index Comparison Functor. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Key}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} {\b Key} - Density Cache. }\par}}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef set< {\b GCell} *, {\b CompareByIndex} > {\b SetIndex}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const {\b Name} & {\b getName} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isSaturated} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isSaturated} (unsigned int depth) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isValid} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isAboveDensity} (float threshold) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasFreeTrack} (size_t depth, float reserve) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GCellGrid} * {\b getGCellGrid} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getDepth} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getIndex} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getRow} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getColumn} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GCell} * {\b getLeft} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GCell} * {\b getRight} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GCell} * {\b getUp} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GCell} * {\b getDown} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b translate} (const {\b DbU::Unit} &, const {\b DbU::Unit} &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Box} {\b getBoundingBox} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getX} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getY} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getXMax} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getYMax} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Interval} {\b getSide} (unsigned int) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getHCapacity} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getVCapacity} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getDensity} (unsigned int flags=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getCDensity} (unsigned int flags=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getWDensity} (unsigned int depth, unsigned int flags=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getBlockage} (unsigned int depth) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getFragmentation} (unsigned int depth) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getFeedthroughs} (unsigned int depth) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getGlobalsCount} (unsigned int depth) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const vector< {\b AutoSegment} * > & {\b getHSegments} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const vector< {\b AutoSegment} * > & {\b getVSegments} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const vector< {\b AutoContact} * > & {\b getContacts} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegments} {\b getHStartSegments} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegments} {\b getVStartSegments} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegments} {\b getHStopSegments} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegments} {\b getVStopSegments} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegments} {\b getStartSegments} (unsigned int direction)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegments} {\b getStopSegments} (unsigned int direction)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getRoutingPads} (set< {\b RoutingPad} *> &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Key} & {\b getKey} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b checkDensity} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b checkEdgeSaturation} (size_t hreserved, size_t vreserved) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addBlockage} (unsigned int depth, {\b DbU::Unit})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addHSegment} ({\b AutoSegment} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addVSegment} ({\b AutoSegment} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addContact} ({\b AutoContact} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeVSegment} ({\b AutoSegment} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeHSegment} ({\b AutoSegment} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeContact} ({\b AutoContact} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateContacts} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b updateDensity} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateKey} (unsigned int depth)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rpDesaturate} (set< {\b Net} *> &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b stepDesaturate} (unsigned int depth, set< {\b Net} *> &, {\b AutoSegment} *&moved, unsigned int flags=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b stepNetDesaturate} (unsigned int depth, set< {\b Net} *> &globalNets, {\b SetIndex} &invalidateds)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static size_t {\b getAllocateds} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b DbU::Unit} {\b getTopRightShrink} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b Name} & {\b getStaticName} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Routing Global Cell. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GCell Description
\par}
{\tc\tcl2 \v GCell Description}
Please note that there are two kind of Global Cells (or {\b GCell} for short):{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The {\b GCell} used by the global router Knik.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The {\b GCell} used by the detailed router ({\b Katabatic} & Kite). Although the information they hold is obviously related, they are two separate kind of objects.\par}
The area of the design to be routed is divided in a regular grid of rectangular area, the {\b GCellGrid}. Each rectangular area is a {\b GCell}.\par
The {\b GCell} contains the following informations:{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The AutoSegments that begins or ends in it. The list of segments is not avalaible directly but through the AutoContacts that are owned by the {\b GCell}.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The AutoSegments that go straight {\i through}  it (or {\i over}  it). Horizontal & Vertical segments are stored in two separeted list. Those two lists are sorted by layer depth (the deepest layers first).\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
A lot of synthetic information about the density of tracks used in the {\b GCell}.\par}
AutoContacts are affected to GCells, the area of the {\b GCell} is the one into which the {\b AutoContact} is allowed to be placed. It is this that way that the respect of the global routing choosen by Knik is enforced. See the {\b AutoContact} constraint box.\par
When tracks are aligned with the {\b GCell} boundaries they one exactly on the boundary can belong to the {\b GCell} on either side of the boundary. But we want a clear and mutually exclusive ownership of each {\b GCell} area. So, we choose that one {\b GCell} do not own the topmost and rightmost track. And to implement it, we shrink top and right coordinates by the amount of {\b GCell::getTopRightShrink()}, which must be less than the track spacing.\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Saturation & Density Computation
\par}
{\tc\tcl3 \v Saturation & Density Computation}
At any depth (i.e. layer), in the preferred routing direction, a {\b GCell} can pass a finite length of wire. For example on an horizontal preferred layer: \[ WL_{max} = width(GCell) \times Htracks(GCell) \] Then the density, is the ratio between $WL_{max}$ and the actually used wirelength: \[ Wdensity(depth) = \frac{WL_{used}(depth)}{WL_{max}(depth)} \] Normally, the ratio musn't exceed 1.0, but the occupied wire length computation, for now, doesn't merge overlapping wires belonging to the same net, so the ratio may be slightly inaccurate. Thus in some pathological cases may be greater than 1.0 whithout truly been overloaded.\par
A Cell is considered as {\i saturated}  if the overall density is above the saturation ratio given by {\b Session::getSaturateRatio()}.\par
Contact density is calculated as follow: \[ Cont_{density} = \frac{|Contacts|}{Htracks \times Vtracks \times 4} \] It is a ratio over the number of actual contacts in the {\b GCell} and the maximal number. The maximal number being the product of the number of tracks in both direction and 4 stands for the hardwired number of layers (the depth).\par
Should not be hardwired... {\i To be corrected in future versions.} \par}
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Feedthrough Computation
\par}
{\tc\tcl3 \v Feedthrough Computation}
The feedtrough value is an estimate is of how many complete tracks have been used on a given layer of the {\b GCell}. It varies between zero and the number of track on the {\b GCell} (complete saturation). As an estimate, it doesn't tell you the actual number of free track, but how many you {\i may expect}  assuming the routing is reasonably well done.\par
Computation is done as follow: \par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Wire type\cell }{Estimated Cost \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Straight wire (feedthrough) \cell }{{\b 1.0}  \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Beginning or ending global wire \cell }{{\b 0.5}  \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Local wire. \cell }{{\b 1/3}  \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Blockage wire \cell }{The exact percentage of the track \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
\par}
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Track Computation
\par}
{\tc\tcl3 \v Track Computation}
The number of track that can go through a {\b GCell} in the horizontal direction is computed as follow: \[ Htracks = \frac{heigth(GCell)}{Vpitch} + 1 \]\par
The pitch is assumed to be the same for every layer and is hardwired to 5.0 lambda.\par
This is a bad architectural choice. The informations pertaining to routing should be held at Kite level, not be hardwired and the pitch should be made variable with the layer... {\i To be corrected in future versions} .\par}
\par}
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GCell Lazy Evaluation
\par}
{\tc\tcl2 \v GCell Lazy Evaluation}
To save processing time, the densities are not recomputed every time a segment is modified (added, removed or moved). Instead a lazy evaluation mechanism is used. Densities are recomputed each time a density is queried {\i and}  the lazy evaluation {\i not}  explicitly disabled (flag NoUpdate).\par}
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GCell Sorting Key
\par}
{\tc\tcl2 \v GCell Sorting Key}
In order to perform a lexicographical sort on the tuple $(density(depth),id)$ of a {\b GCell}, a specific slave object {\b GCell::Key} is introduced. It is the density on one specific depth, not the average density.\par}
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GCell Desaturation / Layer Assignment
\par}
{\tc\tcl2 \v GCell Desaturation / Layer Assignment}
In addition to it's geometrical and density functionality, the {\b GCell} provides {\i desaturation}  capabilities. Desaturation is the operation of moving up feedthough {\b AutoSegment} from the bottom layers towards the upper ones in order to balance the densities in the different densities. Thoses operations provides building blocks for the layer assignment stage which is provided by the Kabatic tool.\par
Two strategies are avalaibles, moving one global {\b AutoSegment} at a time with {\b GCell::stepDesaturate()} or, when one {\b AutoSegment} is moved up, move up the whole net trunk with {\b GCell::stepNetDesaturate()}.\par}
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GCell Implantation
\par}
{\tc\tcl2 \v GCell Implantation}
{\b GCell} derives from Hurricane::ExtensionGo to allow a graphical rendering of the routing density. \par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v SetIndex\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:SetIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef set< {\b GCell} *, {\b CompareByIndex} > {\b SetIndex}}}
\par
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Shorthand for a set of {\b GCell} sorted on their index. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getAllocateds\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getAllocateds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getAllocateds (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The number of allocated GCells. \par
}}
{\xe \v getTopRightShrink\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getTopRightShrink}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getTopRightShrink (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The amount of shrink on the top and right boundaries. \par
}}
{\xe \v getStaticName\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getStaticName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Name} & getStaticName (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The name of the Go slice: {\f2 "Katabatic::GCell"} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Hurricane::ExtensionGo \par
}}}
{\xe \v getName\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Name} & getName () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The name of the Go slice: {\f2 "Katabatic::GCell"} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Hurricane::ExtensionGo \par
}}{
Referenced by GCell::checkDensity().}\par
}
{\xe \v isSaturated\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:isSaturated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isSaturated () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if at least one layer exceed a saturation of {\f2 1.0}  (more wirelength that it can hold). \par
}{
Referenced by GCell::checkDensity(), GCell::stepDesaturate(), and GCell::updateDensity().}\par
}
{\xe \v isSaturated\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:isSaturated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isSaturated (unsigned int  {\i depth}) const}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the saturation ratio of layer {\f2 depth}  is over the threshold defined for the GCells. \par
}{
References GCell::getDensity(), and Session::getSaturateRatio().}\par
}
{\xe \v isValid\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:isValid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isValid () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if all the AutoContact/AutoSegment of the {\b GCell} are valids. \par
}{
Referenced by GCell::checkDensity(), GCell::getCDensity(), GCell::getDensity(), GCell::getFeedthroughs(), GCell::getFragmentation(), GCell::getGlobalsCount(), GCell::getWDensity(), GCell::hasFreeTrack(), GCell::isAboveDensity(), and GCell::updateDensity().}\par
}
{\xe \v isAboveDensity\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:isAboveDensity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isAboveDensity (float  {\i threshold}) const}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the overall saturation ratio greater than {\f2 threshold} . \par
}{
References GCell::getDensity(), GCell::isValid(), and GCell::updateDensity().}\par
}
{\xe \v hasFreeTrack\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:hasFreeTrack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool hasFreeTrack (size_t  {\i depth}, float  {\i reserve}) const}}
\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if there should be enough wire length to pass a wire completly trough this {\b GCell}. \par
}{
References GCell::getHCapacity(), GCell::getIndex(), RoutingGauge::getLayerDepth(), Layer::getName(), Session::getRoutingGauge(), RoutingGauge::getRoutingLayer(), GCell::getVCapacity(), GCell::isValid(), Katabatic::KbHorizontal, Katabatic::KbVertical, and GCell::updateDensity().}\par
}
{\xe \v getGCellGrid\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getGCellGrid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GCellGrid} * getGCellGrid () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b Grid} of which {\b GCell} is part of. \par
}{
Referenced by GCell::checkEdgeSaturation(), GCell::getDensity(), GCell::getDown(), GCell::getLeft(), GCell::getRight(), GCell::getUp(), and GCell::stepNetDesaturate().}\par
}
{\xe \v getDepth\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getDepth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getDepth () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The depth (i.e. number of routing layers) of the {\b GCell}. \par
}}
{\xe \v getIndex\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getIndex () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The linear index of the {\b GCell} in the {\b GCellGrid} vector.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GCellGrid} for the meaning of the index. \par
}}{
Referenced by AutoSegment::canMoveUp(), GCell::hasFreeTrack(), and GCell::stepDesaturate().}\par
}
{\xe \v getRow\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getRow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getRow () const}}
\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The row of the {\b GCell} in the {\b GCellGrid}. \par
}{
References BaseGrid::getRow().}\par
{
Referenced by GCell::checkDensity(), and AutoSegment::computeOptimal().}\par
}
{\xe \v getColumn\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getColumn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getColumn () const}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The Column of the {\b GCell} in the {\b GCellGrid}. \par
}{
References BaseGrid::getColumn().}\par
{
Referenced by GCell::checkDensity(), and AutoSegment::computeOptimal().}\par
}
{\xe \v getLeft\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GCell} * getLeft () const}}
\par
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The left neighbor of the {\b GCell} ({\f2 NULL}  if it is the leftmost {\b GCell}). \par
}{
References GCell::getGCellGrid(), and Grid< GCellT >::getGCellLeft().}\par
{
Referenced by AutoVertical::canMoveULeft(), and AutoVertical::moveULeft().}\par
}
{\xe \v getRight\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GCell} * getRight () const}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The right neighbor of the {\b GCell} ({\f2 NULL}  if it is the rightmost {\b GCell}). \par
}{
References GCell::getGCellGrid(), and Grid< GCellT >::getGCellRight().}\par
{
Referenced by AutoHorizontal::_makeDogleg(), AutoHorizontal::_postCreate(), AutoHorizontal::_preDestroy(), AutoHorizontal::canMoveULeft(), AutoHorizontal::canMoveURight(), AutoVertical::canMoveURight(), GCell::checkEdgeSaturation(), AutoHorizontal::getGCells(), AutoSegment::makeDogleg(), AutoHorizontal::moveULeft(), AutoHorizontal::moveURight(), and AutoVertical::moveURight().}\par
}
{\xe \v getUp\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getUp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GCell} * getUp () const}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The top neighbor of the {\b GCell} ({\f2 NULL}  if it is the topmost {\b GCell}). \par
}{
References GCell::getGCellGrid(), and Grid< GCellT >::getGCellUp().}\par
{
Referenced by AutoVertical::_makeDogleg(), AutoVertical::_postCreate(), AutoVertical::_preDestroy(), AutoVertical::canMoveULeft(), AutoHorizontal::canMoveURight(), AutoVertical::canMoveURight(), GCell::checkEdgeSaturation(), AutoVertical::getGCells(), AutoSegment::makeDogleg(), AutoVertical::moveULeft(), AutoHorizontal::moveURight(), and AutoVertical::moveURight().}\par
}
{\xe \v getDown\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getDown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GCell} * getDown () const}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The bottom neighbor of the {\b GCell} ({\f2 NULL}  if it is the bottommost {\b GCell}). \par
}{
References Grid< GCellT >::getGCellDown(), and GCell::getGCellGrid().}\par
{
Referenced by AutoHorizontal::canMoveULeft(), and AutoHorizontal::moveULeft().}\par
}
{\xe \v translate\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:translate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void translate (const {\b DbU::Unit} & , const {\b DbU::Unit} & ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Required to exists as a {\b Hurricane::Go} derived class. But must never be used... \par
}}
{\xe \v getBoundingBox\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getBoundingBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Box} getBoundingBox () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The bounding box of the {\b GCell}, with the top right shrink applied. \par
}{
Referenced by AutoSegment::AutoSegment(), AutoSegment::computeOptimal(), and AutoContactTerminal::getNativeConstraintBox().}\par
}
{\xe \v getX\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getX () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The lower left X coordinate of the {\b GCell} box. \par
}{
References Box::getXMin().}\par
{
Referenced by AutoHorizontal::_makeDogleg(), AutoHorizontal::_postCreate(), AutoHorizontal::_preDestroy(), AutoContact::getCBXMax(), AutoContact::getCBXMin(), AutoSegment::getOrigin(), AutoContact::setCBXMax(), and AutoContact::setCBXMin().}\par
}
{\xe \v getY\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getY () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The lower left Y coordinate of the {\b GCell} box. \par
}{
References Box::getYMin().}\par
{
Referenced by AutoVertical::_makeDogleg(), AutoVertical::_postCreate(), AutoVertical::_preDestroy(), AutoContact::getCBYMax(), AutoContact::getCBYMin(), AutoSegment::getOrigin(), AutoContact::setCBYMax(), and AutoContact::setCBYMin().}\par
}
{\xe \v getXMax\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getXMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getXMax () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The upper right X coordinate of the {\b GCell} box (top right shrink applied). \par
}{
References Box::getXMax().}\par
{
Referenced by AutoHorizontal::_makeDogleg(), AutoSegment::getExtremity(), and AutoContact::setCBXMax().}\par
}
{\xe \v getYMax\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getYMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getYMax () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The upper right Y coordinate of the {\b GCell} box (top right shrink applied). \par
}{
References Box::getYMax().}\par
{
Referenced by AutoVertical::_makeDogleg(), AutoSegment::getExtremity(), and AutoContact::setCBYMax().}\par
}
{\xe \v getSide\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getSide}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getSide (unsigned int  {\i direction}) const}}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The interval corresponding to the side position of the {\b GCell} box, in {\f2 direction} . \par
}{
References Box::getXMax(), Box::getXMin(), Box::getYMax(), Box::getYMin(), Katabatic::KbHorizontal, and Katabatic::KbVertical.}\par
{
Referenced by AutoHorizontal::_canSlacken(), AutoVertical::_canSlacken(), AutoSegment::makeDogleg(), AutoHorizontal::moveULeft(), AutoVertical::moveULeft(), AutoHorizontal::moveURight(), AutoVertical::moveURight(), and AutoSegment::toConstraintAxis().}\par
}
{\xe \v getHCapacity\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getHCapacity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float getHCapacity () const}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The number of track that can go through the {\b GCell} in the horizontal direction. For a detailed explanation of the computation see {\b Track Computation}. \par
}}{
References Box::getHeight().}\par
{
Referenced by GCell::hasFreeTrack(), and GCell::updateDensity().}\par
}
{\xe \v getVCapacity\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getVCapacity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float getVCapacity () const}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The number of track that can go through the {\b GCell} in the vertical direction. For a detailed explanation of the computation see {\b Track Computation}. \par
}}{
References Box::getWidth().}\par
{
Referenced by GCell::hasFreeTrack(), and GCell::updateDensity().}\par
}
{\xe \v getDensity\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getDensity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float getDensity (unsigned int  {\i flags} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The average density of the {\b GCell}, for all the depths.\par
{\b Saturation & Density Computation}, {\b GCell Lazy Evaluation}. \par
}{
References GCellGrid::AverageHDensity, GCellGrid::AverageHVDensity, GCellGrid::AverageVDensity, GCellGrid::getDensityMode(), GCell::getGCellGrid(), GCell::isValid(), GCellGrid::MaxDensity, GCellGrid::MaxHDensity, GCellGrid::MaxHVDensity, GCellGrid::MaxVDensity, and GCell::updateDensity().}\par
{
Referenced by GCell::isAboveDensity(), and GCell::isSaturated().}\par
}
{\xe \v getCDensity\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getCDensity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float getCDensity (unsigned int  {\i flags} = {\f2 0}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The density of contacts.\par
{\b Saturation & Density Computation}, {\b GCell Lazy Evaluation}. \par
}{
References GCell::isValid(), and GCell::updateDensity().}\par
}
{\xe \v getWDensity\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getWDensity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float getWDensity (unsigned int  {\i depth}, unsigned int  {\i flags} = {\f2 0}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The density of wires at {\f2 depth} .\par
{\b Saturation & Density Computation}, {\b GCell Lazy Evaluation}. \par
}{
References GCell::isValid(), and GCell::updateDensity().}\par
{
Referenced by AutoHorizontal::canMoveULeft(), AutoVertical::canMoveULeft(), AutoHorizontal::canMoveURight(), and AutoVertical::canMoveURight().}\par
}
{\xe \v getBlockage\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getBlockage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getBlockage (unsigned int  {\i depth}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The total length of blockage wire on layer at {\f2 depth} . \par
}}
{\xe \v getFragmentation\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getFragmentation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float getFragmentation (unsigned int  {\i depth}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The longest free fragment size on layer {\f2 depth}  (in percent). \par
}{
References GCell::isValid(), and GCell::updateDensity().}\par
{
Referenced by AutoSegment::canMoveUp().}\par
}
{\xe \v getFeedthroughs\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getFeedthroughs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float getFeedthroughs (unsigned int  {\i depth}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The estimate number of {\i occupied}  tracks on layer {\f2 depth} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Feedthrough Computation} \par
}}{
References GCell::isValid(), and GCell::updateDensity().}\par
}
{\xe \v getGlobalsCount\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getGlobalsCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float getGlobalsCount (unsigned int  {\i depth}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The number of global wires that go completly through the {\b GCell} at layer {\f2 depth} . This do not includes the global wires that begins or ends in the {\b GCell}. \par
}{
References GCell::isValid(), and GCell::updateDensity().}\par
}
{\xe \v getHSegments\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getHSegments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const vector< {\b AutoSegment} * > & getHSegments () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The vector of all horizontal AutoSegments that completly goes through the {\b GCell}. \par
}}}
{\xe \v getVSegments\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getVSegments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const vector< {\b AutoSegment} * > & getVSegments () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The vector of all vertical AutoSegments that completly goes through the {\b GCell}. \par
}}}
{\xe \v getContacts\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getContacts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const vector< {\b AutoContact} * > & getContacts () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The vector of all AutoContacts owned by the {\b GCell}. \par
}}}
{\xe \v getHStartSegments\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getHStartSegments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegments} getHStartSegments ()}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A Collection of the horizontal AutoSegments that starts from this {\b GCell}. \par
}}{
References Katabatic::KbHorizontal, and Katabatic::KbSource.}\par
{
Referenced by GCell::getStartSegments().}\par
}
{\xe \v getVStartSegments\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getVStartSegments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegments} getVStartSegments ()}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A Collection of the vertical AutoSegments that starts from this {\b GCell}. \par
}}{
References Katabatic::KbSource, and Katabatic::KbVertical.}\par
{
Referenced by GCell::getStartSegments().}\par
}
{\xe \v getHStopSegments\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getHStopSegments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegments} getHStopSegments ()}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A Collection of the horizontal AutoSegments that stops in this {\b GCell}. \par
}}{
References Katabatic::KbHorizontal, and Katabatic::KbTarget.}\par
{
Referenced by GCell::getStopSegments().}\par
}
{\xe \v getVStopSegments\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getVStopSegments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegments} getVStopSegments ()}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A Collection of the vertical AutoSegments that stops in this {\b GCell}. \par
}}{
References Katabatic::KbTarget, and Katabatic::KbVertical.}\par
{
Referenced by GCell::getStopSegments().}\par
}
{\xe \v getStartSegments\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getStartSegments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegments} getStartSegments (unsigned int  {\i direction}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A Collection of the horizontal or vertical AutoSegments that starts from this {\b GCell} according to {\f2 direction} . \par
}}{
References GCell::getHStartSegments(), GCell::getVStartSegments(), and Katabatic::KbHorizontal.}\par
}
{\xe \v getStopSegments\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getStopSegments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegments} getStopSegments (unsigned int  {\i direction}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A Collection of the horizontal or vertical AutoSegments that stops in this {\b GCell} according to {\f2 direction} . \par
}}{
References GCell::getHStopSegments(), GCell::getVStopSegments(), and Katabatic::KbHorizontal.}\par
}
{\xe \v getRoutingPads\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getRoutingPads}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getRoutingPads (set< {\b RoutingPad} *> &  {\i rps})}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The size of the RoutingPad set.\par
}Fills the {\f2 rps}  set with all the RoutingPads that appears in this {\b GCell}. (looks at all the anchors of the owned {\b AutoContact}) \par
}{
Referenced by GCell::rpDesaturate().}\par
}
{\xe \v getKey\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:getKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Key} & getKey () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The sorting key of the {\b GCell}.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GCell Sorting Key} \par
}}}
{\xe \v checkDensity\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:checkDensity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t checkDensity () const}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 1}  if the {\b GCell} is saturated, 0 otherwise.\par
}Check, if the {\b GCell} is saturated, layer by layer. Issue a warning if that is the case. \par
}{
References Session::doWarnGCellOverload(), GCell::getColumn(), GCell::getName(), Session::getRoutingGauge(), GCell::getRow(), Session::isInDemoMode(), GCell::isSaturated(), GCell::isValid(), and GCell::updateDensity().}\par
{
Referenced by GCell::updateDensity().}\par
}
{\xe \v checkEdgeSaturation\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:checkEdgeSaturation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool checkEdgeSaturation (size_t  {\i hreserved}, size_t  {\i vreserved}) const}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b true}  if the Up/Right edge is over the {\f2 threshold} .\par
}Check if the number of AutoSegments crossing the Up & Right edges of the {\b GCell} exceed {\f2 threshold} . The {\f2 thresold}  must be expressed as a percentage of the full capacity of the edges. The overload is computed as a whole and not depth by depth. \par
}{
References GCell::getGCellGrid(), GCellGrid::getHEdgeCapacity(), GCell::getRight(), GCell::getUp(), GCellGrid::getVEdgeCapacity(), AutoSegment::isLocal(), and Session::lookup().}\par
}
{\xe \v addBlockage\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:addBlockage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void addBlockage (unsigned int  {\i depth}, {\b DbU::Unit}  {\i length})}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds {\f2 length}  of wire blockage to layer {\f2 depth} . \par
}{
References DbU::getValueString().}\par
}
{\xe \v addHSegment\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:addHSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void addHSegment ({\b AutoSegment} *  {\i segment}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds {\f2 segment}  to the list of horizontal feedthroughs. \par
}{
Referenced by AutoHorizontal::_postCreate(), AutoVertical::moveULeft(), and AutoVertical::moveURight().}\par
}
{\xe \v addVSegment\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:addVSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void addVSegment ({\b AutoSegment} *  {\i segment}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds {\f2 segment}  to the list of vertical feedthroughs. \par
}{
Referenced by AutoVertical::_postCreate(), AutoHorizontal::moveULeft(), and AutoHorizontal::moveURight().}\par
}
{\xe \v addContact\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:addContact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void addContact ({\b AutoContact} *  {\i contact}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds {\f2 contact}  to the list of contacts owned by this {\b GCell}. \par
}{
Referenced by AutoContact::setGCell().}\par
}
{\xe \v removeVSegment\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:removeVSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void removeVSegment ({\b AutoSegment} *  {\i segment})}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes {\f2 segment}  to the list of vertical feedthroughs. \par
}{
Referenced by AutoVertical::_makeDogleg(), AutoVertical::_preDestroy(), AutoHorizontal::moveULeft(), and AutoHorizontal::moveURight().}\par
}
{\xe \v removeHSegment\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:removeHSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void removeHSegment ({\b AutoSegment} *  {\i segment})}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes {\f2 segment}  to the list of horizontal feedthroughs. \par
}{
Referenced by AutoHorizontal::_makeDogleg(), AutoHorizontal::_preDestroy(), AutoVertical::moveULeft(), and AutoVertical::moveURight().}\par
}
{\xe \v removeContact\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:removeContact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void removeContact ({\b AutoContact} *  {\i contact})}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes {\f2 contact}  to the list of contacts owned by this {\b GCell}. \par
}{
References AutoContact::base().}\par
}
{\xe \v updateContacts\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:updateContacts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateContacts ()}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Force a geometry update on all the {\b AutoContact} of the {\b GCell}. \par
}}
{\xe \v updateDensity\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:updateDensity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t updateDensity ()}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the {\b GCell} is saturated.\par
Update the various densities of the {\b GCell}. No actual computation is performed if the {\b GCell} is {\i not}  invalidated. \par
}{
References GCell::checkDensity(), GCell::getHCapacity(), Box::getHeight(), RoutingGauge::getLayerDepth(), Session::getRoutingGauge(), GCell::getVCapacity(), Box::getWidth(), Box::getXMax(), Box::getXMin(), Box::getYMax(), Box::getYMin(), GCell::isSaturated(), GCell::isValid(), Katabatic::KbHorizontal, and Katabatic::KbVertical.}\par
{
Referenced by GCell::checkDensity(), GCell::getCDensity(), GCell::getDensity(), GCell::getFeedthroughs(), GCell::getFragmentation(), GCell::getGlobalsCount(), GCell::getWDensity(), GCell::hasFreeTrack(), GCell::isAboveDensity(), GCell::stepDesaturate(), and GCell::stepNetDesaturate().}\par
}
{\xe \v updateKey\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:updateKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateKey (unsigned int  {\i depth}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update the {\b GCell} key with the new density at layer {\f2 depth} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GCell Sorting Key}. \par
}}{
References GCell::Key::update().}\par
}
{\xe \v rpDesaturate\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:rpDesaturate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool rpDesaturate (set< {\b Net} *> &  {\i nets})}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the number of RoutingPad in the first routing layer exceed the {\b Session::getSaturateRp()} threshold, force a desaturation of layer {\f2 depth}  1 until it is below 0.5.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GCell Desaturation / Layer Assignment} \par
}}{
References Session::getRoutingLayer(), GCell::getRoutingPads(), Session::getSaturateRp(), Katabatic::KbForceMove, and GCell::stepDesaturate().}\par
}
{\xe \v stepDesaturate\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:stepDesaturate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool stepDesaturate (unsigned int  {\i depth}, set< {\b Net} *> &  {\i globalNets}, {\b AutoSegment} *&  {\i moved}, unsigned int  {\i flags} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i depth} \cell }{The depth to desaturate. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i globalNets} \cell }{The set of Nets of which at least one segment has been moved up. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i moved} \cell }{The moved up {\b AutoSegment}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i flags} \cell }{If KbForceMove is set, force one {\b AutoSegment} to move up, event if the {\b GCell} is not saturated in the relevant depth.\cell }
{\row }
}
{\b Returns:}  {\b true}  if an {\b AutoSegment} has actually been moved up.\par
Perform the atomic desaturation, that is move up one {\b AutoSegment} from layer {\f2 depth}  to layer {\f2 depth+2} , longuests AutoSegments are moved first. Only global feedthrough AutoSegments are candidates to be moved up. The Net owning the moved up segment is added to the {\f2 globalNets}  set. If the {\b GCell} is not saturated on layer {\f2 depth} , nothing is done. If the {\f2 forced}  flag is set, one global {\b AutoSegment} is moved up regardless of the saturation status.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GCell Desaturation / Layer Assignment} \par
}}{
References GCell::getIndex(), RoutingGauge::getLayerDepth(), Session::getRoutingGauge(), GCell::isSaturated(), Katabatic::KbForceMove, Katabatic::KbHorizontal, Katabatic::KbVertical, and GCell::updateDensity().}\par
{
Referenced by GCell::rpDesaturate().}\par
}
{\xe \v stepNetDesaturate\:Katabatic::GCell}
{\xe \v Katabatic::GCell\:stepNetDesaturate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool stepNetDesaturate (unsigned int  {\i depth}, set< {\b Net} *> &  {\i globalNets}, {\b GCell::SetIndex} &  {\i invalidateds})}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i depth} \cell }{The depth to desaturate. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i globalNets} \cell }{The set of Nets of which at least one segment has been moved up. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalidateds} \cell }{The set of {\b GCell} ids that have been invalidateds.\cell }
{\row }
}
{\b Returns:}  {\b true}  if a Net has been moved up.\par
Perform a desaturation by whole Net trunk. Select the longest feedthrough {\b AutoSegment} in layer {\f2 depth} , then attempt to move up the whole Net (all it's global AutoSegments are moved up).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GCell Desaturation / Layer Assignment} \par
}}{
References GCell::getGCellGrid(), RoutingGauge::getLayerDepth(), Session::getRoutingGauge(), Katabatic::KbHorizontal, Katabatic::KbVertical, and GCell::updateDensity().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
GCell.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
GCell.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
GCell.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GCellDensitySet Class Reference\par \pard\plain 
{\tc\tcl2 \v GCellDensitySet}
{\xe \v GCellDensitySet}
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} Set, sorted by density. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GCellDensitySet} (unsigned int depth)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GCellDensitySet} (unsigned int depth, const std::vector< {\b GCell} *> &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~GCellDensitySet} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b empty} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::set< {\b GCell} *, GCell::CompareByKey > & {\b getGCells} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insert} ({\b GCell} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b erase} ({\b GCell} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b unqueue} ({\b GCell} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b requeue} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} Set, sorted by density. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A small container helper to manage a set of {\b GCell} sorted by density on a specific layer {\f2 depth} .\par
The helper is implemented in term of a set. Once inserted in a set an element must not have is sorting key changed. But {\b GCell} density may change due to {\b AutoSegment} modifications during the lifetime of the set. To circumvent this problem, the {\b GCell} provide a key attribute to be used specifically with {\b GCellDensitySet}. This key act as a cached copy of the {\b GCell} density which is updated {\i only}  by a call to {\b GCell::updateKey()} (and {\i not}  {\b GCell::updateDensity()}). {\b GCell} which density have changed and key has to be updated must be signaled to set with the GCellDensityQueue::unqueue() method. When we want to update the sorting of the set on the new densities, we call {\b GCellDensitySet::requeue()} which, for each invalidated {\b GCell} do:{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Remove the {\b GCell} from the set.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Update the key (call {\b GCell::updateKey()}).\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Reinsert the {\b GCell} in the set (thus with the updated key).\par}
Typical usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid GCellDensitySet gcells ( 2, *(getGCellGrid()->getGCellVector()) );\par
\par
while ( true ) \{\par
    bool optimized = false;\par
\par
    std::set<GCell*,GCell::CompareByKey>::const_iterator igcell = gcells.getGCells().begin();\par
    for ( ; igcell != gcells.getGCells().end() ; ++igcell ) \{\par
        if ( doSomeOptimization(*igcell) ) \{\par
          optimized = true;\par
          gcells.unqueue( *igcell );\par
        \}\par
    \}\par
\par
    if (not optimized) break;\par
\par
    gcells.requeue();\par
\}\par
}
 \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v GCellDensitySet\:Katabatic::GCellDensitySet}
{\xe \v Katabatic::GCellDensitySet\:GCellDensitySet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GCellDensitySet} (unsigned int  {\i depth})}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a new empty {\b GCellDensitySet}, sorting on density of layer {\f2 depth} . \par
}}
{\xe \v GCellDensitySet\:Katabatic::GCellDensitySet}
{\xe \v Katabatic::GCellDensitySet\:GCellDensitySet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GCellDensitySet} (unsigned int  {\i depth}, const std::vector< {\b GCell} *> &  {\i gcells})}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a new empty {\b GCellDensitySet}, sorting on density of layer {\f2 depth} . Load the queue with the GCells supplied in the {\f2 gcells}  vector. \par
}{
References GCellDensitySet::requeue().}\par
}
{\xe \v ~GCellDensitySet\:Katabatic::GCellDensitySet}
{\xe \v Katabatic::GCellDensitySet\:~GCellDensitySet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
~{\b GCellDensitySet} ()}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Delete a {\b GCellDensitySet}, if the queue is not empty, issue a warning. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v empty\:Katabatic::GCellDensitySet}
{\xe \v Katabatic::GCellDensitySet\:empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool empty () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the queue is empty. \par
}}
{\xe \v size\:Katabatic::GCellDensitySet}
{\xe \v Katabatic::GCellDensitySet\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  the numbers of elements in the queue. \par
}}
{\xe \v getGCells\:Katabatic::GCellDensitySet}
{\xe \v Katabatic::GCellDensitySet\:getGCells}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::set< {\b GCell} *, GCell::CompareByKey > & getGCells () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  the list of GCells currently in the queue. \par
}}
{\xe \v insert\:Katabatic::GCellDensitySet}
{\xe \v Katabatic::GCellDensitySet\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t insert ({\b GCell} *  {\i gcell}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Insert {\f2 gcell}  into the set. \par
}}
{\xe \v erase\:Katabatic::GCellDensitySet}
{\xe \v Katabatic::GCellDensitySet\:erase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t erase ({\b GCell} *  {\i gcell}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove {\f2 gcell}  from the set. \par
}}
{\xe \v unqueue\:Katabatic::GCellDensitySet}
{\xe \v Katabatic::GCellDensitySet\:unqueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void unqueue ({\b GCell} *  {\i gcell}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Invalidate {\f2 gcell} . The density of {\f2 gcell}  may have changed and needs to be reinserted into the queue. It is temporarily set asides until the next call to {\b GCellDensitySet::requeue()}. \par
}}
{\xe \v requeue\:Katabatic::GCellDensitySet}
{\xe \v Katabatic::GCellDensitySet\:requeue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void requeue ()}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reinsert in the queue all the GCells that have been previously invalidated by a call to {\b GCellDensitySet::unqueue()}. This function calls {\b GCell::updateKey()} before reinserting the {\b GCell}. \par
}{
Referenced by GCellDensitySet::GCellDensitySet().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
GCell.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
GCell.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
GCell.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GCellGrid Class Reference\par \pard\plain 
{\tc\tcl2 \v GCellGrid}
{\xe \v GCellGrid}
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} {\b Grid}. }}\par
Inheritance diagram for GCellGrid:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKatabatic_1_1GCellGrid__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b DensityMode} \{ {\b AverageHVDensity} =1, 
{\b AverageHDensity} =2, 
{\b AverageVDensity} =3, 
{\b MaxHVDensity} =4, 
{\b MaxVDensity} =5, 
{\b MaxHDensity} =6, 
{\b MaxDensity} =7
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Cell} * {\b getCell} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b KatabaticEngine} * {\b getKatabatic} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getDensityMode} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getHEdgeCapacity} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getVEdgeCapacity} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Interval} {\b getUSide} (unsigned int) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b checkDensity} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b updateDensity} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateContacts} (unsigned int flags={\b KbOpenSession})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setDensityMode} (unsigned int)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _postCreate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _preDestroy} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b GCellGrid} * {\b create} ({\b KatabaticEngine} *)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} {\b Grid}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b GCell} {\b Grid} of {\b Katabatic}. Although the base template class {\b Grid} support irregular grid, the {\b GCellGrid} is regular, following the Knik global router GCells. Only the topmost row and leftmost column may have different height or width to cope with the design real size.\par
Due to the regular nature of the grid, the horizontal & vertical edges capacities are all identical, and initialized from the {\b Katabatic} Configuration.\par
The grid is build from the Knik global routing, so obviously a KnikEngine must be attached to the Cell when building the {\b GCellGrid}. An error is thrown otherwise. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v DensityMode\:Katabatic::GCellGrid}
{\xe \v Katabatic::GCellGrid\:DensityMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b DensityMode}}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Various ways of computing the overall density of a {\b GCell}. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v AverageHVDensity\:Katabatic::GCellGrid}
{\xe \v Katabatic::GCellGrid\:AverageHVDensity}
{\qr AverageHVDensity{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The average density all depths accounted. \par
}\cell }{\row }
{\xe \v AverageHDensity\:Katabatic::GCellGrid}
{\xe \v Katabatic::GCellGrid\:AverageHDensity}
{\qr AverageHDensity{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The average density of horizontal layers. \par
}\cell }{\row }
{\xe \v AverageVDensity\:Katabatic::GCellGrid}
{\xe \v Katabatic::GCellGrid\:AverageVDensity}
{\qr AverageVDensity{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The average density of horizontal layers. \par
}\cell }{\row }
{\xe \v MaxHVDensity\:Katabatic::GCellGrid}
{\xe \v Katabatic::GCellGrid\:MaxHVDensity}
{\qr MaxHVDensity{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The maximum of the average horizontal & vertical densities taken as a whole. \par
}\cell }{\row }
{\xe \v MaxVDensity\:Katabatic::GCellGrid}
{\xe \v Katabatic::GCellGrid\:MaxVDensity}
{\qr MaxVDensity{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The maximum of the average vertical densities taken depth by depth. \par
}\cell }{\row }
{\xe \v MaxHDensity\:Katabatic::GCellGrid}
{\xe \v Katabatic::GCellGrid\:MaxHDensity}
{\qr MaxHDensity{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The maximum of the average horizontal densities taken depth by depth. \par
}\cell }{\row }
{\xe \v MaxDensity\:Katabatic::GCellGrid}
{\xe \v Katabatic::GCellGrid\:MaxDensity}
{\qr MaxDensity{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The maximum of the average horizontal & vertical densities taken depth by depth. \par
}\cell }{\row }
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getCell\:Katabatic::GCellGrid}
{\xe \v Katabatic::GCellGrid\:getCell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Cell} * getCell () const}}
\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The associated Cell. \par
}{
Referenced by GCellGrid::_postCreate().}\par
}
{\xe \v getKatabatic\:Katabatic::GCellGrid}
{\xe \v Katabatic::GCellGrid\:getKatabatic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b KatabaticEngine} * getKatabatic () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The associated {\b KatabaticEngine}. \par
}}
{\xe \v getDensityMode\:Katabatic::GCellGrid}
{\xe \v Katabatic::GCellGrid\:getDensityMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getDensityMode () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The computation mode of the {\b GCell} densities. \par
}{
Referenced by GCell::getDensity().}\par
}
{\xe \v getHEdgeCapacity\:Katabatic::GCellGrid}
{\xe \v Katabatic::GCellGrid\:getHEdgeCapacity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getHEdgeCapacity () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The horizontal edge capacity. As the matrix is regular it is identical for all horizontal edges. \par
}{
Referenced by GCell::checkEdgeSaturation().}\par
}
{\xe \v getVEdgeCapacity\:Katabatic::GCellGrid}
{\xe \v Katabatic::GCellGrid\:getVEdgeCapacity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getVEdgeCapacity () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The vertical edge capacity. As the matrix is regular it is identical for all vertical edges. \par
}{
Referenced by GCell::checkEdgeSaturation().}\par
}
{\xe \v getUSide\:Katabatic::GCellGrid}
{\xe \v Katabatic::GCellGrid\:getUSide}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getUSide (unsigned int  {\i direction}) const}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The side of the whole grid in {\f2 direction} . \par
}{
References Box::getXMax(), Box::getXMin(), Box::getYMax(), Box::getYMin(), Katabatic::KbHorizontal, and Katabatic::KbVertical.}\par
}
{\xe \v checkDensity\:Katabatic::GCellGrid}
{\xe \v Katabatic::GCellGrid\:checkDensity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t checkDensity () const}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The number of {\b GCell} saturateds.\par
Check all GCells for saturations. \par
}{
References Grid< GCell >::getGCells().}\par
}
{\xe \v updateDensity\:Katabatic::GCellGrid}
{\xe \v Katabatic::GCellGrid\:updateDensity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t updateDensity ()}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The number of {\b GCell} saturateds.\par
Force a density update on all the GCells. \par
}{
References Grid< GCell >::getGCells().}\par
}
{\xe \v updateContacts\:Katabatic::GCellGrid}
{\xe \v Katabatic::GCellGrid\:updateContacts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateContacts (unsigned int  {\i flags} = {\f2 {\b KbOpenSession}})}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Force an update on all {\b AutoContact} on all the GCells. if {\f2 openSession}  is {\b true} , enclose the update in a {\b Session}. \par
}{
References Session::close(), Grid< GCell >::getGCells(), Katabatic::KbOpenSession, and Session::open().}\par
{
Referenced by KatabaticEngine::refresh().}\par
}
{\xe \v setDensityMode\:Katabatic::GCellGrid}
{\xe \v Katabatic::GCellGrid\:setDensityMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setDensityMode (unsigned int  {\i mode}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the density computation mode. \par
}}
{\xe \v _postCreate\:Katabatic::GCellGrid}
{\xe \v Katabatic::GCellGrid\:_postCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _postCreate (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform the {\b GCell} & {\b GCell} vector allocation.{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Read the horizontal and vertical cut lines from Knik and translate them into {\b BaseGrid::Axis}.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
From the {\b BaseGrid::Axis}, deduces the exact positions of the GCells and allocate them.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The {\b GCell} allocation is done in a "row by row" fashion consistent with {\b BaseGrid} implicit assumptions. \par}
}{
Reimplemented from {\b BaseGrid} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
References BaseGrid::Axis::addGraduation(), GCellGrid::getCell(), BaseGrid::getColumns(), BaseGrid::getRows(), BaseGrid::Axis::getSize(), and BaseGrid::Axis::sort().}\par
}
{\xe \v _preDestroy\:Katabatic::GCellGrid}
{\xe \v Katabatic::GCellGrid\:_preDestroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _preDestroy (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The GCells are deleted at this point. \par
}{
Reimplemented from {\b BaseGrid} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v create\:Katabatic::GCellGrid}
{\xe \v Katabatic::GCellGrid\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GCellGrid} * create ({\b KatabaticEngine} *  {\i ktbt}){\f2 [static]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
API-space contructor. \par
}{
References grid().}\par
{
Referenced by KatabaticEngine::createDetailedGrid().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
GCellGrid.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
GCellGrid.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
GCellGrid.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GCellTopology Class Reference\par \pard\plain 
{\tc\tcl2 \v GCellTopology}
{\xe \v GCellTopology}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Build the wiring for a Net inside a GCell ({\b internal} ). }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b doRp_AutoContacts} ({\b GCell} *, {\b Component} *, {\b AutoContact} *&source, {\b AutoContact} *&target, unsigned int flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b AutoContact} * {\b doRp_Access} ({\b GCell} *, {\b Component} *, unsigned int flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b AutoContact} * {\b doRp_AccessPad} ({\b RoutingPad} *, unsigned int flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b doRp_StairCaseH} ({\b GCell} *, {\b Component} *rp1, {\b Component} *rp2)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b doRp_StairCaseV} ({\b GCell} *, {\b Component} *rp1, {\b Component} *rp2)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _do_xG} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _do_xG_1Pad} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _do_1G_1M1} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _do_1G_xM1} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _do_xG_xM1_xM3} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _do_xG_1M1_1M2} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _do_xG_xM2} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _do_1G_1M3} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _do_xG_xM3} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Build the wiring for a Net inside a GCell ({\b internal} ). \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
As this class is called to initially construct the {\b Katabatic} wiring, it must build a {\b connex}  wiring. That is without gaps in layer depth, because the topology restauration mechanism ({\b AutoContact::updateTopology()}) of the AutoContact cannot work until all AutoSegments are revalidated at least once. The topology restauration work by creating doglegs which in turn, call the canonization, which needs all the caches to be up to date. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
LoadGrByNet.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Grid< GCellT > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v Grid< GCellT >}
{\xe \v Grid< GCellT >}
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template Class for Regular {\b Grid}. }}\par
Inheritance diagram for Grid< GCellT >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKatabatic_1_1Grid__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GCellT * {\b getGCell} (unsigned int index) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GCellT * {\b getGCell} (const {\b Point} p) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GCellT * {\b getGCell} (const {\b Point} p1, const {\b Point} p2) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GCellT * {\b getGCellLeft} (const GCellT *gcell) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GCellT * {\b getGCellRight} (const GCellT *gcell) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GCellT * {\b getGCellUp} (const GCellT *gcell) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GCellT * {\b getGCellDown} (const GCellT *gcell) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GenericCollection}< GCellT * > {\b getGCells} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GenericCollection}< GCellT * > {\b getGCellsColumn} (unsigned int column, unsigned int rowStart, unsigned int rowStop)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GenericCollection}< GCellT * > {\b getGCellsRow} (unsigned int row, unsigned int columnStart, unsigned int columnStop)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Grid} (const {\b Box} &)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename GCellT>\par
class Katabatic::Grid< GCellT >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template Class for Regular {\b Grid}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains all general purpose methods depending on the {\b GCell} type and geometrical computations. The internal storage is still not implemented in this class. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Grid\:Katabatic::Grid}
{\xe \v Katabatic::Grid\:Grid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Grid} (const {\b Box} &  {\i bb}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Grid} constructor. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getGCell\:Katabatic::Grid}
{\xe \v Katabatic::Grid\:getGCell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CGellT * getGCell (unsigned int  {\i index}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The grid object at linear index {\f2 index}  in the vector. If {\f2 index}  is out of bounds, return {\f2 NULL} . \par
}{
Referenced by GCellTopology::doRp_AccessPad(), GCellTopology::doRp_AutoContacts(), and anonymous_namespace\{LoadGrByNet.cpp\}::singleGCell().}\par
}
{\xe \v getGCell\:Katabatic::Grid}
{\xe \v Katabatic::Grid\:getGCell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CGellT * getGCell (const {\b Point}  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The grid object which is under position {\f2 p} . \par
}}
{\xe \v getGCell\:Katabatic::Grid}
{\xe \v Katabatic::Grid\:getGCell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CGellT * getGCell (const {\b Point}  {\i p1}, const {\b Point}  {\i p2}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The grid object which is under position {\f2 p1}  and {\f2 p2} . Not very clear though. \par
}}
{\xe \v getGCellLeft\:Katabatic::Grid}
{\xe \v Katabatic::Grid\:getGCellLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CGellT * getGCellLeft (const GCellT *  {\i gcell}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The left neighbor of {\f2 gcell} , {\f2 NULL}  if it is the leftmost one. \par
}{
Referenced by GCell::getLeft().}\par
}
{\xe \v getGCellRight\:Katabatic::Grid}
{\xe \v Katabatic::Grid\:getGCellRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CGellT * getGCellRight (const GCellT *  {\i gcell}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The rigth neighbor of {\f2 gcell} , {\f2 NULL}  if it is the rightmost one. \par
}{
Referenced by GCell::getRight().}\par
}
{\xe \v getGCellUp\:Katabatic::Grid}
{\xe \v Katabatic::Grid\:getGCellUp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CGellT * getGCellUp (const GCellT *  {\i gcell}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The upper neighbor of {\f2 gcell} , {\f2 NULL}  if it is the uppermost one. \par
}{
Referenced by GCell::getUp().}\par
}
{\xe \v getGCellDown\:Katabatic::Grid}
{\xe \v Katabatic::Grid\:getGCellDown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CGellT * getGCellDown (const GCellT *  {\i gcell}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The down neighbor of {\f2 gcell} , {\f2 NULL}  if it is the downmost one. \par
}{
Referenced by GCell::getDown().}\par
}
{\xe \v getGCells\:Katabatic::Grid}
{\xe \v Katabatic::Grid\:getGCells}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GenericCollection}< CGellT * > getGCells (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  A GCellT Hurricane collection built upon the linear GCellT vector of the grid. \par
}}
{\xe \v getGCellsColumn\:Katabatic::Grid}
{\xe \v Katabatic::Grid\:getGCellsColumn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GenericCollection}< CGellT * > getGCellsColumn (unsigned int  {\i column}, unsigned int  {\i rowStart}, unsigned int  {\i rowStop}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  A GCellT Hurricane collection that contains the part of {\f2 column}  starting from {\f2 rowStart}  to {\f2 rowStop}  inclusive. \par
}{
Referenced by KatabaticEngine::createDetailedGrid().}\par
}
{\xe \v getGCellsRow\:Katabatic::Grid}
{\xe \v Katabatic::Grid\:getGCellsRow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GenericCollection}< CGellT * > getGCellsRow (unsigned int  {\i row}, unsigned int  {\i columnStart}, unsigned int  {\i columnStop}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  A GCellT Hurricane collection that contains the part of {\f2 row}  starting from {\f2 columnStart}  to {\f2 columnStop}  inclusive. \par
}{
Referenced by KatabaticEngine::createDetailedGrid().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Grid.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Grid.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
KatabaticEngine Class Reference\par \pard\plain 
{\tc\tcl2 \v KatabaticEngine}
{\xe \v KatabaticEngine}
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Katabatic} Tool. }}\par
Inheritance diagram for KatabaticEngine:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKatabatic_1_1KatabaticEngine__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef set< {\b Net} *, NetCompareByName > {\b NetSet}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isGMetal} (const {\b Layer} *) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isChip} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInDemoMode} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b doWarnOnGCellOverload} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b doDestroyBaseContact} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b doDestroyBaseSegment} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b doDestroyTool} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const {\b Name} & {\b getName} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EngineState} {\b getState} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getFlags} (unsigned int mask) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Configuration * {\b getKatabaticConfiguration} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual Configuration * {\b getConfiguration} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RoutingGauge} * {\b getRoutingGauge} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RoutingLayerGauge} * {\b getLayerGauge} (size_t depth) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Layer} * {\b getRoutingLayer} (size_t depth) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Layer} * {\b getContactLayer} (size_t depth) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GCellGrid} * {\b getGCellGrid} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b NetSet} & {\b getRoutingNets} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getGlobalThreshold} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getSaturateRatio} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getSaturateRp} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getExtensionCap} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b ChipTools} & {\b getChipTools} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b xmlWriteGCellGrid} (ostream &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b xmlWriteGCellGrid} (const string &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setState} ({\b EngineState} state)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFlags} (unsigned int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b unsetFlags} (unsigned int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setGlobalThreshold} ({\b DbU::Unit})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSaturateRatio} (float)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSaturateRp} (size_t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printMeasures} (const string &) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b refresh} (unsigned int flags={\b KbOpenSession})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b createDetailedGrid} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b makePowerRails} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b loadGlobalRouting} (unsigned int method)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b slackenBorder} ({\b Box} bb, {\b Layer::Mask}, unsigned int flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b slackenBlockIos} ({\b Instance} *core)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b moveUpNetTrunk} ({\b AutoSegment} *, set< {\b Net} *> &globalNets, {\b GCell::SetIndex} &invalidateds)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b layerAssign} (unsigned int method)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b computeNetConstraints} ({\b Net} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b toOptimals} ({\b Net} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b finalizeLayout} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b KatabaticEngine} * {\b create} ({\b Cell} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b Name} & {\b staticGetName} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Katabatic} Tool. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
States of KatabaticEngine
\par}
{\tc\tcl2 \v States of KatabaticEngine}
During it's lifecycle, the engine go through a serie of states. It only can go forward between states.{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EngineCreation}  : just after C++ object creation until the global routing is loaded.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EngineGlobalLoaded}  : {\i after}  the global routing has been done. This state must be set by an external tool, {\b Katabatic} cannot know by itself when the global routing has been done (see Kite).\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EngineActive}  : {\i after}  the global routing has been converted into the {\b Katabatic} data structure. At this point the tool is ready to run.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EngineDriving}  : {\i during}  the stage of stripping all the decorations the tool has added over the Hurricane data structure (mostly: {\b AutoContact} & {\b AutoSegment}).\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EngineGutted}  : {\i after}  the tool decorations have been removed. The tool is now useless and can only be destroyed.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EnginePreDestroying}  : this special state is reached when going straight from EngineActive to the destructor, that is, skipping the EngineDriving state. That means we {\i do not}  want to save whatever routing has been done. In that case, not only the tool decorations are destroyeds, but also the Hurricane data-structures they relies on (Contact, Segments).\par}
\par}
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
KatabaticEngine Implementation Details
\par}
{\tc\tcl2 \v KatabaticEngine Implementation Details}
Due to the size of the code and the fact that the main body of some methods do not need to be present in the class, the implementation of {\b KatabaticEngine} is split in several files. The list below summarize them:{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 KatabaticEngine.cpp}  : the core of the class, methods that really need their bodies here.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 PowerRails.cpp}  : utilities to construct an abstract from all the power rails through the hierarchy.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 LayerAssign.cpp}  : layer assignement related methods and helpers.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 LoadGrByNet.cpp}  : global routing loader, transform global routing into {\b Katabatic} data-structure.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 NetConstraints.cpp}  : compute the topological constraints of all AutoSegment/AutoContact of a Net.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 NetOptimals.cpp}  : compute the optimal positions of all {\b AutoSegment} of a Net. \par}
\par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v NetSet\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:NetSet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
set< {\b Net} *, NetCompareByName > {\b NetSet}}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set of Net to be routed, alphabetically sorteds. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v create\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b KatabaticEngine} * create ({\b Cell} *  {\i cell}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a {\b KatabaticEngine} on {\f2 cell} . \par
}}
{\xe \v staticGetName\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:staticGetName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Name} & staticGetName (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The unique string identifier for the {\b KatabaticEngine} class of ToolEngine. \par
}}
{\xe \v isGMetal\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:isGMetal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isGMetal (const {\b Layer} *  {\i layer}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if {\f2 layer}  is one of the special (fake) metals used to build the global routing. \par
}{
Referenced by AutoSegment::create().}\par
}
{\xe \v isChip\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:isChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isChip () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the hierarchy top-level of the Cell matches the one of a complete design (i.e. pads and one core instance). \par
}{
References ChipTools::isChip().}\par
}
{\xe \v isInDemoMode\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:isInDemoMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isInDemoMode () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the tool is in demo mode, that is suppress almost all warning and debug messages. \par
}{
Referenced by Session::isInDemoMode().}\par
}
{\xe \v doWarnOnGCellOverload\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:doWarnOnGCellOverload}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool doWarnOnGCellOverload () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the tool should issue a warning when a {\b GCell} is overloaded (overload could be transient). \par
}{
Referenced by Session::doWarnGCellOverload().}\par
}
{\xe \v doDestroyBaseContact\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:doDestroyBaseContact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool doDestroyBaseContact () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the EngineDestroyBaseContact is set, meaning that when an {\b AutoContact} is destroyed, the Contact it decorates is destroyed altogether. \par
}}
{\xe \v doDestroyBaseSegment\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:doDestroyBaseSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool doDestroyBaseSegment () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the EngineDestroyBaseSegment is set, meaning that when an {\b AutoSegment} is destroyed, the Segment it decorates is destroyed altogether. \par
}}
{\xe \v doDestroyTool\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:doDestroyTool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool doDestroyTool () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the tool state is beyond EngineStateGutted, that is, only waits for {\f2 {\b destroy()}}  to be called. \par
}{
References Katabatic::EngineGutted.}\par
}
{\xe \v getName\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:getName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Name} & getName () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The unique string identifier for the {\b KatabaticEngine} class of ToolEngine. \par
}{
Implements {\b ToolEngine}.}\par
}
{\xe \v getState\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:getState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EngineState} getState () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The state the tool is currently in. \par
}}
{\xe \v getFlags\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:getFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getFlags (unsigned int  {\i mask}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\i anded}  combination of the tool flags and {\f2 mask} . \par
}}
{\xe \v getKatabaticConfiguration\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:getKatabaticConfiguration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Configuration * getKatabaticConfiguration (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The Configuration of {\b Katabatic}. In this class it is redundant with {\b getConfiguration()}, but may be useful in derived classes. \par
}}
{\xe \v getConfiguration\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:getConfiguration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Configuration * getConfiguration (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The Configuration of the current ToolEngine. \par
}}
{\xe \v getRoutingGauge\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:getRoutingGauge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingGauge} * getRoutingGauge () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The RoutingGauge (Configuration shortcut). \par
}}
{\xe \v getLayerGauge\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:getLayerGauge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingLayerGauge} * getLayerGauge (size_t  {\i depth}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The RoutingLayerGauge associated to {\f2 depth}  (Configuration shortcut). \par
}}
{\xe \v getRoutingLayer\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:getRoutingLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Layer} * getRoutingLayer (size_t  {\i depth}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The routing Layer associated to {\f2 depth}  (Configuration shortcut). \par
}}
{\xe \v getContactLayer\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:getContactLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Layer} * getContactLayer (size_t  {\i depth}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The contact Layer associated to {\f2 depth}  (Configuration shortcut). \par
}}
{\xe \v getGCellGrid\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:getGCellGrid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GCellGrid} * getGCellGrid () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b GCellGrid}. \par
}{
Referenced by GCellTopology::doRp_AccessPad(), GCellTopology::doRp_AutoContacts(), and anonymous_namespace\{LoadGrByNet.cpp\}::singleGCell().}\par
}
{\xe \v getRoutingNets\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:getRoutingNets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b NetSet} & getRoutingNets () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The set of nets to be routeds. \par
}}
{\xe \v getGlobalThreshold\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:getGlobalThreshold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getGlobalThreshold () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The length above which a global wire is moved up in the layer assignment stage (Configuration shortcut). \par
}}
{\xe \v getSaturateRatio\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:getSaturateRatio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float getSaturateRatio () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The ratio above which a {\b GCell} is considered to be saturated (Configuration shortcut). \par
}{
Referenced by Session::getSaturateRatio().}\par
}
{\xe \v getSaturateRp\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:getSaturateRp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getSaturateRp () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The number of RoutingPad above which a {\b GCell} is saturated, causing extras global segments to be moved up. (Configuration shortcut). \par
}{
Referenced by Session::getSaturateRp().}\par
}
{\xe \v getExtensionCap\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:getExtensionCap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getExtensionCap () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The wires extension cap, same for all layers for the time beeing (Configuration shortcut). \par
}}
{\xe \v getChipTools\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:getChipTools}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b ChipTools} & getChipTools () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The chip tools (for whole designs). \par
}{
Referenced by KatabaticEngine::createDetailedGrid().}\par
}
{\xe \v xmlWriteGCellGrid\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:xmlWriteGCellGrid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void xmlWriteGCellGrid (ostream &  {\i o})}}
\par
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write in a stream all informations on the GCells in XML format. \par
}{
Referenced by KatabaticEngine::xmlWriteGCellGrid().}\par
}
{\xe \v xmlWriteGCellGrid\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:xmlWriteGCellGrid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void xmlWriteGCellGrid (const string &  {\i fileName})}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write in a file all informations on the GCells in XML format. \par
}{
References KatabaticEngine::xmlWriteGCellGrid().}\par
}
{\xe \v setState\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:setState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setState ({\b EngineState}  {\i state}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Force the state of the tool. Must be used with caution, as no sanity checks are performeds. This method is normally invoked from inside the {\b KatabaticEngine} various methods. \par
}}
{\xe \v setFlags\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:setFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setFlags (unsigned int  {\i flags}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the flags given in {\f2 flags} . \par
}{
Referenced by Session::setKatabaticFlags().}\par
}
{\xe \v unsetFlags\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:unsetFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void unsetFlags (unsigned int  {\i flags}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset the flags given in {\f2 flags} . \par
}}
{\xe \v setGlobalThreshold\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:setGlobalThreshold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setGlobalThreshold ({\b DbU::Unit}  {\i threshold}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Configuration shortcut). \par
}}
{\xe \v setSaturateRatio\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:setSaturateRatio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setSaturateRatio (float  {\i ratio}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Configuration shortcut). \par
}}
{\xe \v setSaturateRp\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:setSaturateRp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setSaturateRp (size_t  {\i threshold}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Configuration shortcut). \par
}}
{\xe \v printMeasures\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:printMeasures}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void printMeasures (const string &  {\i tag}) const}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print memory & time measurement on ``cmess1``. If {\f2 tag}  is not empty, also adds the measurement to the internal table (with {\f2 tag}  as label). \par
}{
Referenced by KatabaticEngine::finalizeLayout().}\par
}
{\xe \v refresh\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:refresh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void refresh (unsigned int  {\i flags} = {\f2 {\b KbOpenSession}})}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In case the tool is associated with a graphic display, trigger a full redraw of the Cell. Slow the router but allow to see work in progress... If {\f2 flags}  {\i do not}  contains {\f2 KbOpenSession}  the refresh operation will not be enclosed inside it's own session. This assumes that a session is already opened. \par
}{
References GCellGrid::updateContacts().}\par
}
{\xe \v createDetailedGrid\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:createDetailedGrid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void createDetailedGrid (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocate the {\b GCellGrid}. \par
}{
References GCellGrid::create(), KatabaticEngine::getChipTools(), BaseGrid::getColumns(), Grid< GCellT >::getGCellsColumn(), Grid< GCellT >::getGCellsRow(), BaseGrid::getRows(), ChipTools::isChip(), and Session::revalidate().}\par
}
{\xe \v makePowerRails\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:makePowerRails}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void makePowerRails ()}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detect all the aligned segments of same width that compose power rails, unificate them and copy them at the design top level. \par
}}
{\xe \v loadGlobalRouting\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:loadGlobalRouting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void loadGlobalRouting (unsigned int  {\i method}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i method} \cell }{the loading algorithm \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i nets} \cell }{the set of nets to route.\cell }
{\row }
}
Convert the global routing into the initial detailed routing. For the time beeing, only one loading algorithm is available: {\i net by net}  (EngineLoadGrByNet). Only Net given in {\f2 nets}  are routeds. If {\f2 nets}  is empty then all ordinary nets are routeds. In either cases the set of nets to route is pruned from any power, ground or clock signals.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: The tool state must be {\b EngineGlobalLoaded}  {\i before}  calling this method\par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid and will be set to {\b EngineActive}  on exit. \par
}}{
References Katabatic::EngineActive, and Katabatic::EngineGlobalLoaded.}\par
}
{\xe \v slackenBorder\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:slackenBorder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void slackenBorder ({\b Box}  {\i bb}, {\b Layer::Mask}  {\i mask}, unsigned int  {\i flags})}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bb} \cell }{The bounding box, defines the edges. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mask} \cell }{Consider only layers that are fully included in that mask. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i flags} \cell }{Consider only segment in that direction.\cell }
{\row }
}
Perform a preventive break on all global segments going through the {\i vertical}  left and right edges of the {\f2 bb}  box. The set of global segments to be broken could be further restricted using {\f2 mask}  and {\f2 flags} .\par
The Semantic of {\f2 flags}  is not clear, must review the code more closely. \par
}{
References Box::getXMax(), Box::getXMin(), Box::getYMax(), and Box::getYMin().}\par
}
{\xe \v slackenBlockIos\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:slackenBlockIos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void slackenBlockIos ({\b Instance} *  {\i core})}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform a preventive break on horizontal segments in the {\b GCell} immediatly {\i outside}  the instance {\f2 core}  area in the routing layer of index {\f2 1} .\par
This method is too much hardwired to the {\f2 SxLib}  gauge. It's effect is to break all {\b METAL2}  outside the core (in a chip). \par
}{
References Entity::getBoundingBox(), Instance::getName(), Constant::Horizontal, and Box::inflate().}\par
}
{\xe \v moveUpNetTrunk\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:moveUpNetTrunk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool moveUpNetTrunk ({\b AutoSegment} *  {\i seed}, set< {\b Net} *> &  {\i globalNets}, {\b GCell::SetIndex} &  {\i invalidateds})}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i seed} \cell }{The {\b AutoSegment} to take the net from. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i globalNets} \cell }{The set of nets that has been moved up. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalidateds} \cell }{The set of GCells that have been invalidated. {\b Returns:}  {\b true}  if the net trunk have been moved up.\cell }
{\row }
}
Try to move up a whole net trunk. The net is supplied through the {\f2 seed}  argument (the segment that triggers the move). If the net is actually moved up, it is added to {\f2 globalNets}  and all GCells that have been invalidateds are added to {\f2 invalidateds} .\par
An individual {\b AutoSegment} of the net is moved up if it's length is greater that {\f2 150}  lambdas, that is, three times the side of a {\b GCell}. This is hard-wired and should be parametrized in the future. \par
}}
{\xe \v layerAssign\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:layerAssign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void layerAssign (unsigned int  {\i method})}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform the layer assignment. The global routing loading stage uses only the two bottom most layers, this method spread them on all the availables routing layers, according to {\b GCell} and RoutingPad density criterions.\par
Two algorithms are availables:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b EngineLayerAssignByLength}  : the global wires are moved up one by one.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b EngineLayerAssignByTrunk}  : if one global wire of a net is to be moved up, then all the global trunk of the net is moved along. This methods gives the best results for now. \par}
}}
{\xe \v computeNetConstraints\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:computeNetConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void computeNetConstraints ({\b Net} *  {\i net})}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute the box constraints on AutoContacts (and therefore those applied to AutoSegments). Constraints comes from AutoContacts anchoreds on RoutingPads and transmitted through {\b AutoContactHTee} or {\b AutoContactVTee}. Constraints are applied to all AutoContacts of an aligned set.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: The {\f2 net}  must have been canonized before this function to be called. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}}
{\xe \v toOptimals\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:toOptimals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toOptimals ({\b Net} *  {\i net})}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Move all {\b AutoSegment} of {\f2 net}  so that their axis are inside their optimals interval. If a {\b AutoSegment} is already inside the interval is not moved, otherwise it is put on the nearest bound of the optimal interval. \par
}}
{\xe \v finalizeLayout\:Katabatic::KatabaticEngine}
{\xe \v Katabatic::KatabaticEngine\:finalizeLayout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void finalizeLayout (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Transform the {\b Katabatic} wires into the Hurricane data-structure. Mostly by removing the AutoSegment/AutoContact {\i without}  removing their Hurricane conterparts. May also fill gaps that may have appeared.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: The tool state must be {\b EngineActive}  {\i before}  calling this method\par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid and will be set to {\b EngineGutted}  on exit. \par
}}{
References Katabatic::EngineDriving, Katabatic::EngineGutted, and KatabaticEngine::printMeasures().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
KatabaticEngine.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
ChipTools.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
LoadGrByNet.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
KatabaticEngine.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
KatabaticEngine.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GCell::Key Class Reference\par \pard\plain 
{\tc\tcl2 \v GCell::Key}
{\xe \v GCell::Key}
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} {\b Key} - Density Cache. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Key} ({\b GCell} *, unsigned int depth)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getDensity} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GCell} * {\b getGCell} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} (unsigned int depth)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GCell} {\b Key} - Density Cache. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is used to create a {\b GCell} internal cache on density, mainly to be used by {\b GCellDensitySet}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Key\:Katabatic::GCell::Key}
{\xe \v Katabatic::GCell::Key\:Key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Key} ({\b GCell} *  {\i owner}, unsigned int  {\i depth}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i owner} \cell }{The {\b GCell} owning the key. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i depth} \cell }{The layer {\f2 depth}  of the density to use.\cell }
{\row }
}
{\b Key} constructor, with an initial value for the cached density. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getDensity\:Katabatic::GCell::Key}
{\xe \v Katabatic::GCell::Key\:getDensity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float getDensity () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The value of the cached density. \par
}}
{\xe \v getGCell\:Katabatic::GCell::Key}
{\xe \v Katabatic::GCell::Key\:getGCell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GCell} * getGCell () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The owning {\b GCell}. \par
}}
{\xe \v update\:Katabatic::GCell::Key}
{\xe \v Katabatic::GCell::Key\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void update (unsigned int  {\i depth}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  Update the density \par
}{
Referenced by GCell::updateKey().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
GCell.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
GCell.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LocatorHelper Class Reference\par \pard\plain 
{\tc\tcl2 \v LocatorHelper}
{\xe \v LocatorHelper}
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Locator Helper Collection's Locators. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LocatorHelper} ({\b AutoContact} *, unsigned int flags=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isValid} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoSegment} * {\b getSegment} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b progress} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Locator Helper Collection's Locators. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Provide a small uniform walktough over the AutoSegments anchored on AutoContacts. The {\f2 flags}  argument allows to choose between direction and include perpandiculars (in that case all segments are processeds).\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Implementation Details
\par}
{\tc\tcl2 \v Implementation Details}
As, at most, two horizontals and two verticals may be anchored on any {\b AutoContact} subtype, the locator helper perform a walk through a virtual table of 4 elements. The two first are the horizontals, the two last the verticals. The meaning of this index is consistent whith the {\f2 index}  argument of {\b AutoContact::getSegment()}. When a segment is not present in an {\b AutoContact}, the {\f2 {\b getSegment()}}  returns {\f2 NULL}  and the {\b LocatorHelper::progress()} function will skip it.\par
The private methods:{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 LocatorHelper::_min()}  \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 LocatorHelper::_max()}  \par}
Computes the bounds of {\f2 _index}  according to the value of {\f2 _flags:}  {
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 KbHorizontal}  : {\f2 0}  to less than {\f2 2} .\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 KbVertical}  : {\f2 2}  to less than {\f2 4} .\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 KbHorizontal|KbVertical}  : {\f2 0}  to less than {\f2 4} . \par}
\par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v LocatorHelper\:Katabatic::LocatorHelper}
{\xe \v Katabatic::LocatorHelper\:LocatorHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LocatorHelper} ({\b AutoContact} *  {\i contact}, unsigned int  {\i flags} = {\f2 0}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a helper to iterate over the AutoSegments anchored on {\f2 contact} . The {\f2 flags}  arguments allow to select:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The direction: {\b Katabatic::KbHorizontal} or {\b Katabatic::KbVertical}.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Perpandicular inclusion: {\b Katabatic::KbWithPerpands}.\par}
When setting KbWithPerpands, all the segments will be iterated over. It may seems a somewhat contorted way of doing things, the reason is the ability to share (an pass) flags directly between different functions. \par
}{
References AutoContact::getSegment(), and LocatorHelper::progress().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v isValid\:Katabatic::LocatorHelper}
{\xe \v Katabatic::LocatorHelper\:isValid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isValid () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if there is an {\b AutoSegment} to be processed. \par
}}
{\xe \v getSegment\:Katabatic::LocatorHelper}
{\xe \v Katabatic::LocatorHelper\:getSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * getSegment () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The current {\b AutoSegment}. {\f2 NULL}  if the loop is over. \par
}{
References AutoContact::getSegment().}\par
}
{\xe \v progress\:Katabatic::LocatorHelper}
{\xe \v Katabatic::LocatorHelper\:progress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void progress (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  Go to the next {\b AutoSegment}. \par
}{
References AutoContact::getSegment().}\par
{
Referenced by LocatorHelper::LocatorHelper().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoContact.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
AutoContact.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Observable Class Reference\par \pard\plain 
{\tc\tcl2 \v Observable}
{\xe \v Observable}
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Observer} Design Pattern, Subject part. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Observable} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > T * {\b getObserver} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addObserver} ({\b BaseObserver} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeObserver} ({\b BaseObserver} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b notify} (unsigned int flags)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Observer} Design Pattern, Subject part. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Observable} is the implementation of the {\i subject}  part of the {\b Observer} design pattern. For the time beeing it's a simplificated version that allows only one {\b Observer} to watch the subject.\par
{\b Observable} is designed to be an attribute of the subject, not one of it's base class.\par
This implantation is completly generic and has nothing specific to {\b Katabatic}. It may be moved sometimes in Hurricane at Property level in {\b Hurricane::DBo}.\par
{\b Note to Myself:}  {\b Observer} pattern is the one behind signal/slots. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Observable\:Katabatic::Observable}
{\xe \v Katabatic::Observable\:Observable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Observable} (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default and only constructor. The copy constructor is disabled (made private and unimplemented). \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getObserver\:Katabatic::Observable}
{\xe \v Katabatic::Observable\:getObserver}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
T * getObserver (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The (only) observer, {\f2 NULL}  if there is none. It is the object of which the {\b Observer} is an attribute, that is, it's {\i owner} , and not the {\b Observer} itself which is returned. \par
}}
{\xe \v addObserver\:Katabatic::Observable}
{\xe \v Katabatic::Observable\:addObserver}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void addObserver ({\b BaseObserver} *  {\i observer}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds an observer. If more than one is added, throw an error. \par
}}
{\xe \v removeObserver\:Katabatic::Observable}
{\xe \v Katabatic::Observable\:removeObserver}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void removeObserver ({\b BaseObserver} *  {\i observer}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes an observer. If the observer do not belong to this observable, throw an exception. \par
}}
{\xe \v notify\:Katabatic::Observable}
{\xe \v Katabatic::Observable\:notify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void notify (unsigned int  {\i flags}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used by the subject to signal a change in it's state to the observers. The {\f2 flags}  parameter can be used to indicates what kind of change is occuring. Values for {\f2 flags}  are defined between the subject and the observers. \par
}{
References BaseObserver::notify().}\par
{
Referenced by AutoSegment::_invalidate(), AutoSegment::_postCreate(), AutoSegment::_preDestroy(), and AutoSegment::revalidate().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Observer.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Observer.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Observer< T > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v Observer< T >}
{\xe \v Observer< T >}
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Observer} Design Pattern, {\b Observer} part. }}\par
Inheritance diagram for Observer< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKatabatic_1_1Observer__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Observer} (const T *owner)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T * {\b getOwner} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
class Katabatic::Observer< T >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Observer} Design Pattern, {\b Observer} part. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b First, a warning about names:}  although this class is named {\b Observer}, it is intended to be an attribute nested inside the whole object which is indeed, the true {\b Observer}. This nesting object is called, most of the time the {\b owner}  in the following. But sometimes, for simplification it may also be called the {\b Observer}.\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Observer Implementation Notes
\par}
{\tc\tcl2 \v Observer Implementation Notes}
To retrieve the {\i owner}  from the {\b Observer} attribute, we uses the offset from the attribute in the {\i owner} . This offset is computed once and for all the first time the template constructor is called. \par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Observer\:Katabatic::Observer}
{\xe \v Katabatic::Observer\:Observer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Observer} (const T *  {\i owner}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The owner of the oberver is needed to compute, on the first creation only, the offset of the {\b Observer} attribute inside the {\f2 owner}  complete object. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getOwner\:Katabatic::Observer}
{\xe \v Katabatic::Observer\:getOwner}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
T * getOwner () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The owner of the observer. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Observer.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Observer.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Session Class Reference\par \pard\plain 
{\tc\tcl2 \v Session}
{\xe \v Session}
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Modification {\b Session} for {\b Katabatic}. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b isInDemoMode} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b doWarnGCellOverload} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Session} * {\b get} (const char *message=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Technology} * {\b getTechnology} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b KatabaticEngine} * {\b getKatabatic} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const Configuration * {\b getConfiguration} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static float {\b getSaturateRatio} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static size_t {\b getSaturateRp} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b DbU::Unit} {\b getExtensionCap} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b RoutingGauge} * {\b getRoutingGauge} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b Layer} * {\b getRoutingLayer} (size_t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b Layer} * {\b getContactLayer} (size_t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static size_t {\b getSegmentStackSize} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static size_t {\b getContactStackSize} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const vector< {\b AutoSegment} * > & {\b getInvalidateds} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const vector< {\b AutoSegment} * > & {\b getRevalidateds} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const vector< {\b AutoSegment} * > & {\b getDoglegs} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const set< {\b Net} * > & {\b getNetsModificateds} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Session} * {\b open} ({\b KatabaticEngine} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b close} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b setKatabaticFlags} (unsigned int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b dogleg} ({\b AutoSegment} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b revalidateTopology} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b setInvalidateMask} (unsigned int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b invalidate} ({\b Net} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b invalidate} ({\b AutoContact} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b invalidate} ({\b AutoSegment} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static size_t {\b revalidate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b link} ({\b AutoContact} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b link} ({\b AutoSegment} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b unlink} ({\b AutoContact} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b unlink} ({\b AutoSegment} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b AutoContact} * {\b lookup} ({\b Contact} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b AutoSegment} * {\b lookup} ({\b Segment} *)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Modification {\b Session} for {\b Katabatic}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To perform modifications, the {\b Katabatic} data structure uses a session mechanism built on top of the {\b Hurricane::UpdateSession} one. Sessions obeys very simples rules:{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Only one {\b Session} can be opened at a time with {\b Session::open()}.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Subsequent calls to {\b Session::open()} returns the currently opened session until {\b Session::close()} is called.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Revalidation can take place whithout closing the {\b Session} by calling {\b Session::revalidate()}.\par}
The task of a {\b Session} is to keep track of the {\b AutoContact} and {\b AutoSegment} that have been modificateds (i.e. invalidated) and, to restore connexity and/or topology when closed.\par
Two kinds of revalidation could be performed: {
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Geometrical}  : only positions of AutoContacts and AutoSegments extensions are recomputed. \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Topological}  : a whole net have been invalidated because of a dogleg creation or a move up/move down of a segment. {
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Dogleg}  : needs to insert the newly created AutoSegments and AutoContacts. \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Move up/Move down}  : may needs to create additional dogleg to restore connexity (gaps), and then insert them like above. \par}
After a topological mofication has been done, the net needs to be re-canonized then the geometrical step takes place. \par}
The kind of revalidation needed is automatically detected by the {\b Session}.\par
In addition to it's main purpose, {\b Session} also provides cached access to frequently needed variables either from Hurricane or {\b Katabatic} Configuration and access to the {\b AutoContact} & {\b AutoSegment} LUTs of {\b KatabaticEngine}.\par
From a software point of view, {\b Session} is a singleton object.\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Session Algorithm
\par}
{\tc\tcl2 \v Session Algorithm}
Main attributes of a {\b Session}:{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 _netInvalidateds} , nets on which topology has changed.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 _autoSegments} , that have been moved or createds.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 _autoContacts} , that have been created or one of their slave segment has moved.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 _revalidateds} , the list of AutoSegments that have just been revalidated (after calling {\f2 {\b revalidate()}} ).\par}
Schematic description of how a {\b Session} works:\par
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If at least one net has been invalidated, meaning that it's topology has changed, perform {\f2 _revalidateTopology()} . {
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Update net topology: correct the topology of each contacts, making dogleg when needed. The {\b AutoContact} segment caching is updated at this point. \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Compute net constraints (on AutoContacts & AutoSegments). \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Compute net optimal positions (on AutoSegments). \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Compute the state of the segments regarding to terminals. \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Canonize sets of aligneds segments. The canonical segment is the one with the lowest {\f2 id} . \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
If the segments has just been created, put it on its optimal axis. \par}
This stage can add itself more invalidated AutoSegments and AutoContacts as it create doglegs.\par
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Revalidate geometry of AutoContacts. That is, expand or shrink the extremities of the invalidated AutoSegments. Note that AutoSegments are already at on their final axis position.\par
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Revalidate AutoSegments. Just before this stage, they are on the correct axis and their extensions are also correct, so we may update the caching of their characteristics (mostly the extension). \par}
\par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v isInDemoMode\:Katabatic::Session}
{\xe \v Katabatic::Session\:isInDemoMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isInDemoMode (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Katabatic} shortcut. \par
}{
References KatabaticEngine::isInDemoMode().}\par
{
Referenced by GCell::checkDensity().}\par
}
{\xe \v doWarnGCellOverload\:Katabatic::Session}
{\xe \v Katabatic::Session\:doWarnGCellOverload}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool doWarnGCellOverload (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Katabatic} shortcut. \par
}{
References KatabaticEngine::doWarnOnGCellOverload().}\par
{
Referenced by GCell::checkDensity().}\par
}
{\xe \v get\:Katabatic::Session}
{\xe \v Katabatic::Session\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Session} * get (const char *  {\i message} = {\f2 NULL}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the {\b Session} singleton, if no session is currently open throw an exception carrying {\f2 message} . \par
}}
{\xe \v getTechnology\:Katabatic::Session}
{\xe \v Katabatic::Session\:getTechnology}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Technology} * getTechnology (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Hurricane shortcut. \par
}}
{\xe \v getKatabatic\:Katabatic::Session}
{\xe \v Katabatic::Session\:getKatabatic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b KatabaticEngine} * getKatabatic (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Katabatic} shortcut. \par
}{
Referenced by AutoSegment::create(), GCellTopology::doRp_AccessPad(), GCellTopology::doRp_AutoContacts(), AutoSegment::makeDogleg(), and Session::open().}\par
}
{\xe \v getConfiguration\:Katabatic::Session}
{\xe \v Katabatic::Session\:getConfiguration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const Configuration * getConfiguration (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Katabatic} shortcut. \par
}{
Referenced by AutoHorizontal::_makeDogleg(), AutoVertical::_makeDogleg(), and AutoSegment::canMoveUp().}\par
}
{\xe \v getSaturateRatio\:Katabatic::Session}
{\xe \v Katabatic::Session\:getSaturateRatio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float getSaturateRatio (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Katabatic} shortcut. \par
}{
References KatabaticEngine::getSaturateRatio().}\par
{
Referenced by GCell::isSaturated().}\par
}
{\xe \v getSaturateRp\:Katabatic::Session}
{\xe \v Katabatic::Session\:getSaturateRp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getSaturateRp (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Katabatic} shortcut. \par
}{
References KatabaticEngine::getSaturateRp().}\par
{
Referenced by GCell::rpDesaturate().}\par
}
{\xe \v getExtensionCap\:Katabatic::Session}
{\xe \v Katabatic::Session\:getExtensionCap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getExtensionCap (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Katabatic} shortcut. \par
}{
Referenced by AutoHorizontal::checkPositions(), AutoVertical::checkPositions(), AutoHorizontal::updatePositions(), and AutoVertical::updatePositions().}\par
}
{\xe \v getRoutingGauge\:Katabatic::Session}
{\xe \v Katabatic::Session\:getRoutingGauge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingGauge} * getRoutingGauge (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Katabatic} shortcut. \par
}{
Referenced by AutoHorizontal::_makeDogleg(), AutoVertical::_makeDogleg(), AutoHorizontal::canMoveULeft(), AutoVertical::canMoveULeft(), AutoSegment::canMoveUp(), AutoHorizontal::canMoveURight(), AutoVertical::canMoveURight(), AutoSegment::canPivotDown(), AutoSegment::canPivotUp(), GCell::checkDensity(), Session::getContactLayer(), Session::getRoutingLayer(), GCell::hasFreeTrack(), AutoSegment::makeDogleg(), anonymous_namespace\{LoadGrByNet.cpp\}::singleGCell(), GCell::stepDesaturate(), GCell::stepNetDesaturate(), GCell::updateDensity(), AutoContactVTee::updateTopology(), AutoContactTurn::updateTopology(), AutoContactHTee::updateTopology(), and AutoContactTerminal::updateTopology().}\par
}
{\xe \v getRoutingLayer\:Katabatic::Session}
{\xe \v Katabatic::Session\:getRoutingLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Layer} * getRoutingLayer (size_t  {\i depth}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Katabatic} shortcut. \par
}{
References Session::getRoutingGauge(), and RoutingGauge::getRoutingLayer().}\par
{
Referenced by GCellTopology::_do_xG_1M1_1M2(), GCellTopology::_do_xG_xM1_xM3(), AutoSegment::create(), GCellTopology::doRp_AccessPad(), AutoSegment::reduceDoglegLayer(), and GCell::rpDesaturate().}\par
}
{\xe \v getContactLayer\:Katabatic::Session}
{\xe \v Katabatic::Session\:getContactLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Layer} * getContactLayer (size_t  {\i depth}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Katabatic} shortcut. \par
}{
References RoutingGauge::getContactLayer(), and Session::getRoutingGauge().}\par
{
Referenced by GCellTopology::_do_1G_1M3(), GCellTopology::_do_1G_xM1(), GCellTopology::_do_xG(), GCellTopology::_do_xG_1M1_1M2(), GCellTopology::_do_xG_1Pad(), GCellTopology::_do_xG_xM1_xM3(), GCellTopology::_do_xG_xM2(), GCellTopology::_do_xG_xM3(), GCellTopology::doRp_Access(), GCellTopology::doRp_AccessPad(), GCellTopology::doRp_AutoContacts(), GCellTopology::doRp_StairCaseH(), GCellTopology::doRp_StairCaseV(), and anonymous_namespace\{LoadGrByNet.cpp\}::singleGCell().}\par
}
{\xe \v getSegmentStackSize\:Katabatic::Session}
{\xe \v Katabatic::Session\:getSegmentStackSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getSegmentStackSize (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The number of {\b AutoSegment} in the invalidated stack. \par
}}
{\xe \v getContactStackSize\:Katabatic::Session}
{\xe \v Katabatic::Session\:getContactStackSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getContactStackSize (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The number of {\b AutoSegment} in the invalidated stack. \par
}}
{\xe \v getInvalidateds\:Katabatic::Session}
{\xe \v Katabatic::Session\:getInvalidateds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const vector< {\b AutoSegment} * > & getInvalidateds (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The stack (vector) of invalidateds AutoSegments. \par
}}
{\xe \v getRevalidateds\:Katabatic::Session}
{\xe \v Katabatic::Session\:getRevalidateds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const vector< {\b AutoSegment} * > & getRevalidateds (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The stack (vector) of AutoSegments that have been revalidateds. \par
}}
{\xe \v getDoglegs\:Katabatic::Session}
{\xe \v Katabatic::Session\:getDoglegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const vector< {\b AutoSegment} * > & getDoglegs (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The vector of AutoSegments part of a newly created dogleg. The dogleg creation functions in {\b AutoHorizontal} and {\b AutoVertical} put a triplet (for example in horizontal direction {\f2 } (h1,v1,h2) ) for each dogleg composed of:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b h1}  the segment {\i before}  the dogleg (which is also the original one).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b v1}  the segment {\b perpandicular}  (new).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b h2}  the segment {\b after}  (new). \par}
}{
Referenced by AutoSegment::makeDogleg().}\par
}
{\xe \v getNetsModificateds\:Katabatic::Session}
{\xe \v Katabatic::Session\:getNetsModificateds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const set< {\b Net} * > & getNetsModificateds (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The set of Nets that needs either a topological update or a new canonization. \par
}}
{\xe \v open\:Katabatic::Session}
{\xe \v Katabatic::Session\:open}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Session} * open ({\b KatabaticEngine} *  {\i ktbt}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Opens a new session or returns the already opened one, if any. \par
}{
References Session::getKatabatic().}\par
{
Referenced by GCellGrid::updateContacts().}\par
}
{\xe \v close\:Katabatic::Session}
{\xe \v Katabatic::Session\:close}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Close the {\b Session}, triggering the revalidation of the AutoSegemnts and AutoContacts. If no {\b Session} is opened, throws an execption. \par
}{
Referenced by GCellGrid::updateContacts().}\par
}
{\xe \v setKatabaticFlags\:Katabatic::Session}
{\xe \v Katabatic::Session\:setKatabaticFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setKatabaticFlags (unsigned int  {\i flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Katabatic} shortcut. \par
}{
References KatabaticEngine::setFlags().}\par
}
{\xe \v dogleg\:Katabatic::Session}
{\xe \v Katabatic::Session\:dogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dogleg ({\b AutoSegment} *  {\i autoSegment}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds an {\b AutoSegment} to the dogleg vector. \par
}{
Referenced by AutoHorizontal::_makeDogleg(), and AutoVertical::_makeDogleg().}\par
}
{\xe \v revalidateTopology\:Katabatic::Session}
{\xe \v Katabatic::Session\:revalidateTopology}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void revalidateTopology (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Revalidate Net that have been invalidateds and re-canonize them. \par
}}
{\xe \v setInvalidateMask\:Katabatic::Session}
{\xe \v Katabatic::Session\:setInvalidateMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setInvalidateMask (unsigned int  {\i flags}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tells what kind of revalidation must be performed. \par
}}
{\xe \v invalidate\:Katabatic::Session}
{\xe \v Katabatic::Session\:invalidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void invalidate ({\b Net} *  {\i net}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Schedule {\f2 net}  for a full revalidation, topological correction and canonization. \par
}{
Referenced by AutoSegment::_invalidate(), and AutoSegment::_postCreate().}\par
}
{\xe \v invalidate\:Katabatic::Session}
{\xe \v Katabatic::Session\:invalidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void invalidate ({\b AutoContact} *  {\i contact}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Schedule {\f2 contact}  for revalidation. \par
}}
{\xe \v invalidate\:Katabatic::Session}
{\xe \v Katabatic::Session\:invalidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void invalidate ({\b AutoSegment} *  {\i segment}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Schedule {\f2 segment}  for revalidation. \par
}}
{\xe \v revalidate\:Katabatic::Session}
{\xe \v Katabatic::Session\:revalidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t revalidate (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform the revalidation. Returns the sum of AutoContacts and AutoSegemnts that have been revalidated. \par
}{
Referenced by KatabaticEngine::createDetailedGrid().}\par
}
{\xe \v link\:Katabatic::Session}
{\xe \v Katabatic::Session\:link}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void link ({\b AutoContact} *  {\i ac}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds {\f2 ac}  in the {\b AutoContact} lookup table (allow to retrieve an {\b AutoContact} by it's base Contact). \par
}{
Referenced by AutoSegment::_postCreate().}\par
}
{\xe \v link\:Katabatic::Session}
{\xe \v Katabatic::Session\:link}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void link ({\b AutoSegment} *  {\i as}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds {\f2 as}  in the {\b AutoSegment} lookup table (allow to retrieve an {\b AutoSegment} by it's base Segment). \par
}}
{\xe \v unlink\:Katabatic::Session}
{\xe \v Katabatic::Session\:unlink}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void unlink ({\b AutoContact} *  {\i ac}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes {\f2 ac}  from the {\b AutoContact} lookup table. \par
}{
Referenced by AutoSegment::_preDestroy().}\par
}
{\xe \v unlink\:Katabatic::Session}
{\xe \v Katabatic::Session\:unlink}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void unlink ({\b AutoSegment} *  {\i as}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes {\f2 as}  from the {\b AutoSegment} lookup table. \par
}}
{\xe \v lookup\:Katabatic::Session}
{\xe \v Katabatic::Session\:lookup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoContact} * lookup ({\b Contact} *  {\i contact}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lookup the {\b AutoContact} associated with {\f2 contact} . {\f2 NULL}  if not found. \par
}{
Referenced by AutoSegment::AutoSegment(), GCell::checkEdgeSaturation(), AutoSegment::create(), AutoSegment::getAutoSource(), AutoSegment::getAutoTarget(), AutoSegment::getOppositeAnchor(), and AutoSegment::getPerpandicularsBound().}\par
}
{\xe \v lookup\:Katabatic::Session}
{\xe \v Katabatic::Session\:lookup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AutoSegment} * lookup ({\b Segment} *  {\i segment}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lookup the {\b AutoSegment} associated with {\f2 segment} . {\f2 NULL}  if not found. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Session.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Session.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Session.dox\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
.TH "RoutingEventHistory" 3 "Sun Nov 21 2021" "Version 1.0" "Kite - Detailed Router" \" -*- nroff -*-
.ad l
.nh
.SH NAME
RoutingEventHistory \- History of \fBRoutingEvent\fP\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBRoutingEventHistory\fP ()"
.br
.ti -1c
.RI "\fB~RoutingEventHistory\fP ()"
.br
.ti -1c
.RI "bool \fBempty\fP () const"
.br
.ti -1c
.RI "size_t \fBsize\fP () const"
.br
.ti -1c
.RI "\fBRoutingEvent\fP * \fBgetNth\fP (size_t) const"
.br
.ti -1c
.RI "\fBRoutingEvent\fP * \fBgetRNth\fP (size_t) const"
.br
.ti -1c
.RI "void \fBpush\fP (\fBRoutingEvent\fP *)"
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 
History of \fBRoutingEvent\fP\&. 

An history of all the routing events\&. We can afford to keep an history because while one event is a relatively big object, there is not that much of them (their number is roughly proportional to the number of TrackSegments)\&.
.PP
One event is likely to appear more than one time in the history, in fact it will apprears each time it is ripped up\&.
.PP
Lastly, it is a way to keep track of all the allocated RoutingEvents\&. When history is deleted it will deleted all the events that it knows of\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBRoutingEventHistory\fP ()"
Construct an empty \fBRoutingEventHistory\fP\&. 
.SS "~\fBRoutingEventHistory\fP ()"
Delete a \fBRoutingEventHistory\fP\&.
.PP
\fBRemark: The deletion of this object triggers the deletion of\fP
.RS 4
all the \fBRoutingEvent\fP that are referenced in it\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "bool empty () const\fC [inline]\fP"
\fBReturns:\fP \fBtrue\fP if the history is empty\&. 
.SS "size_t size () const\fC [inline]\fP"
\fBReturns:\fP the number of events in the history\&. 
.PP
Referenced by RoutingEventHistory::getNth(), and RoutingEventHistory::getRNth()\&.
.SS "\fBRoutingEvent\fP * getNth (size_t pos) const"
\fBReturns:\fP The event at index \fCpos\fP from the beginning of the history (\fCNULL\fP if \fCpos\fP exeed the size)\&. 
.SS "\fBRoutingEvent\fP * getRNth (size_t pos) const"
\fBReturns:\fP The event at index \fCpos\fP from the end of the history (\fCNULL\fP if \fCpos\fP exeed the size)\&. 
.PP
Referenced by SegmentFsm::conflictSolveByHistory()\&.
.SS "void push (\fBRoutingEvent\fP * event)"
Push a new \fBRoutingEvent\fP in the history\&. 
.PP
Referenced by RoutingEvent::process()\&.
.SS "void clear ()"
Clear the history, also remove the \fBRoutingEvent\fP that are pointed to\&. 
.PP
Referenced by RoutingEventHistory::~RoutingEventHistory()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Kite - Detailed Router from the source code\&.

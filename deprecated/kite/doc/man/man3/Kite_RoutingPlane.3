.TH "RoutingPlane" 3 "Sun Nov 21 2021" "Version 1.0" "Kite - Detailed Router" \" -*- nroff -*-
.ad l
.nh
.SH NAME
RoutingPlane \- Array of Tracks in one Layer\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "bool \fBisHorizontal\fP () const"
.br
.ti -1c
.RI "bool \fBisVertical\fP () const"
.br
.ti -1c
.RI "\fBKiteEngine\fP * \fBgetKiteEngine\fP () const"
.br
.ti -1c
.RI "\fBRoutingLayerGauge\fP * \fBgetLayerGauge\fP () const"
.br
.ti -1c
.RI "unsigned int \fBgetDirection\fP () const"
.br
.ti -1c
.RI "size_t \fBgetDepth\fP () const"
.br
.ti -1c
.RI "\fBDbU::Unit\fP \fBgetAxisMin\fP () const"
.br
.ti -1c
.RI "\fBDbU::Unit\fP \fBgetAxisMax\fP () const"
.br
.ti -1c
.RI "\fBDbU::Unit\fP \fBgetTrackMin\fP () const"
.br
.ti -1c
.RI "\fBDbU::Unit\fP \fBgetTrackMax\fP () const"
.br
.ti -1c
.RI "\fBRoutingPlane\fP * \fBgetTop\fP () const"
.br
.ti -1c
.RI "\fBRoutingPlane\fP * \fBgetBottom\fP () const"
.br
.ti -1c
.RI "const \fBLayer\fP * \fBgetLayer\fP () const"
.br
.ti -1c
.RI "const \fBLayer\fP * \fBgetBlockageLayer\fP () const"
.br
.ti -1c
.RI "size_t \fBgetTracksSize\fP () const"
.br
.ti -1c
.RI "size_t \fBcomputeTracksSize\fP () const"
.br
.ti -1c
.RI "\fBDbU::Unit\fP \fBgetTrackPosition\fP (size_t index) const"
.br
.ti -1c
.RI "\fBTrack\fP * \fBgetTrackByIndex\fP (size_t index) const"
.br
.ti -1c
.RI "\fBTrack\fP * \fBgetTrackByPosition\fP (\fBDbU::Unit\fP axis, unsigned int mode=\fBKtNearest\fP) const"
.br
.ti -1c
.RI "bool \fB_check\fP (unsigned int &overlaps) const"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBRoutingPlane\fP * \fBcreate\fP (\fBKiteEngine\fP *, size_t depth)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Array of Tracks in one Layer\&. 

A \fBRoutingPlane\fP is an array of \fBTrack\fP covering a rectangular area\&. For now the area is the abutment box of the to be routed Cell\&. Tracks are spaced evenly and according to the configuration of the relevant RoutingLayerGauge\&.
.PP
Fig 1: Horizontal RoutingPlane
.SH "Member Function Documentation"
.PP 
.SS "\fBRoutingPlane\fP * create (\fBKiteEngine\fP * engine, size_t depth)\fC [static]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIengine\fP The associated engine\&. 
.br
\fIdepth\fP The Layer depth of the plane\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The newly created \fBRoutingPlane\fP\&.
.RE
.PP
The \fBRoutingPlane\fP public constructor\&. The \fCdepth\fP is in the sense of the RoutingGauge\&. 
.SS "bool isHorizontal () const\fC [inline]\fP"
\fBReturns:\fP \fBtrue\fP if the preferred routing direction is horizontal (the actual direction of the tracks)\&. 
.SS "bool isVertical () const\fC [inline]\fP"
\fBReturns:\fP \fBtrue\fP if the preferred routing direction is vertical (the actual direction of the tracks)\&. 
.SS "\fBKiteEngine\fP * getKiteEngine () const\fC [inline]\fP"
\fBReturns:\fP The associated \fBKiteEngine\fP\&. 
.PP
Referenced by Track::getKiteEngine()\&.
.SS "\fBRoutingLayerGauge\fP * getLayerGauge () const\fC [inline]\fP"
\fBReturns:\fP The RoutingLayerGauge of the plane\&. 
.PP
Referenced by RoutingPlane::getBlockageLayer(), and RoutingPlane::getLayer()\&.
.SS "unsigned int getDirection () const\fC [inline]\fP"
\fBReturns:\fP The preferred routing direction (Katabatic::KbHorizontal or Katabatic::KbVertical)\&. 
.PP
Referenced by RoutingPlane::create(), RoutingPlane::isHorizontal(), and RoutingPlane::isVertical()\&.
.SS "size_t getDepth () const\fC [inline]\fP"
\fBReturns:\fP The depth of the associated layer (as defined by the RoutingLayerGauge)\&. 
.PP
Referenced by Track::getDepth()\&.
.SS "size_t getAxisMin () const\fC [inline]\fP"
\fBReturns:\fP The axis coordinate of the first/lowest track\&. 
.SS "size_t getAxisMax () const\fC [inline]\fP"
\fBReturns:\fP The axis coordinate of the last/highest track\&. 
.SS "size_t getTrackMin () const\fC [inline]\fP"
\fBReturns:\fP The minimum bound of all track\&. 
.SS "size_t getTrackMax () const\fC [inline]\fP"
\fBReturns:\fP The maximum bound of all track\&. 
.SS "\fBRoutingPlane\fP * getTop () const"
\fBReturns:\fP The \fBRoutingPlane\fP immediatly above this one\&. 
.SS "\fBRoutingPlane\fP * getBottom () const"
\fBReturns:\fP The \fBRoutingPlane\fP immediatly below this one\&. 
.SS "const \fBLayer\fP * getLayer () const\fC [inline]\fP"
\fBReturns:\fP The associated routing layer\&. 
.PP
Referenced by Track::getLayer()\&.
.SS "const \fBLayer\fP * getBlockageLayer () const\fC [inline]\fP"
\fBReturns:\fP The blockage layer associated to the routing layer\&. 
.PP
Referenced by Track::getBlockageLayer()\&.
.SS "size_t getTracksSize () const\fC [inline]\fP"
\fBReturns:\fP The number of tracks in the array\&. 
.SS "size_t computeTracksSize () const\fC [inline]\fP"
\fBReturns:\fP The number of tracks \fIto create\fP in the array\&.
.PP
Helper method that compute the number of tracks in the array from the area of the Cell to be routed and the RoutingLayerGauge characteristics (the Cell is accessible through the \fBKiteEngine\fP)\&. 
.PP
Referenced by RoutingPlane::create()\&.
.SS "\fBDbU::Unit\fP getTrackPosition (size_t index) const\fC [inline]\fP"
\fBReturns:\fP The axis of the track at \fCindex\fP in the array\&. 
.SS "\fBTrack\fP * getTrackByIndex (size_t index) const"
\fBReturns:\fP The track at \fCindex\fP in the array\&. 
.PP
Referenced by Track::getNextTrack(), and Track::getPreviousTrack()\&.
.SS "\fBTrack\fP * getTrackByPosition (\fBDbU::Unit\fP axis, unsigned int mode = \fC\fBKtNearest\fP\fP) const"
\fBReturns:\fP The track which position is nearest from \fCaxis\fP\&. The meaning of \fInearest\fP is defined by \fCmode\fP (classic rouding options)\&. 
.PP
Referenced by SegmentFsm::conflictSolveByPlaceds(), NegociateWindow::createTrackSegment(), RoutingEvent::revalidate(), Manipulator::ripupPerpandiculars(), and SegmentFsm::SegmentFsm()\&.
.SS "bool _check (unsigned int & overlaps) const"
\fBReturns:\fP \fBtrue\fP if no errors have been found (i\&.e\&. the database is coherent)\&.
.PP
Perform a coherency check on all tracks part of the array\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Kite - Detailed Router from the source code\&.

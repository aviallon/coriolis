{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\info 
{\title {\comment Kite - Detailed Router  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0 \par
}}Kite - Detailed Router}
{\comment Generated byDoxgyen. }
{\creatim \yr2021\mo11\dy21\hr22\min10\sec21}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt Kite - Detailed Router}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 1.0\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Sun Nov 21 2021 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Detailed Router Documentation\par \pard\plain 
{\tc \v Detailed Router Documentation}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This documentation adresses two level of explanations :\par
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The {\b API}  description which explains how to use {\b Kite}, thoses parts as flagged as {\b API} . \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The internal description which details how {\b Kite} do things. It's mostly intended for myself to help me not to forget how I've done things when debug time will come... It may also be valuable to people who may want to use or patch {\b Kite} for their own purpose (my secret hope). \par}
Additionnal documents:{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Synthetic Hierarchy (API)} \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Notes{\tc \v Notes}\par \pard\plain 
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Summary
\par}
{\tc\tcl2 \v Summary}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Various Things to Remeber}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pending Modifications}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Modifications History}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Changes in the general architecture}{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Changes in KiteEngine class design}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Changes in DataNegociate class design}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Changes in TrackElement class design}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Changes in TrackSegment class design}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Changes in AutoSegment class design}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Changes in AutoContact class design}\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Bug Solving Memento}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Evaluation with Cadence NanoRoute}\par}
\par}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Various Things to Remember
\par}
{\tc\tcl2 \v Various Things to Remember}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Determinism checking.}  The trace level to get only determinism related log is {\f2 500} . Each line for the determinism is prepended with 'Deter|', possible with some leading spaces.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The router only sees/manages the aligned segment sets (through a pseudo- decorator on their canonical segment). So the non-canonical segments and the contacts should not be handled at all at this level.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Do do confuse the Session::Event, events that modificate the state of the {\b Kite} database (insert, move or remove {\b TrackSegment} in {\b Track}) and the {\b RoutingEvent} class which request that a segment must be processed.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
In the various processing method of {\b RoutingEvent}, when a {\b TrackSegment} can be inserted inside a {\b Track} a Session::Event is generated but no further {\b RoutingEvent}, this end the placement processus of segment (until it is ripped-up).\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
AutoSegment do not invalidate their S/T anchor contacts.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
AutoContact invalidate their anchored upon AutoSegment.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Now that the Hurricane database is deterministic, the router seems to be likewise.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Reduce/raise mechanism} . To manage {\i same layer}  dogleg this mechanism has been implemented. When a candidate dogleg perpandicular segment length shrink below one pitch it is removed from any track to become {\i invisible} . Conversely, when a reduced segment length expand over one pitch generate a new {\b RoutingEvent} to insert it. All this is managed in the {\b Session::revalidate()} method.\par}
\par}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Pending Modifications
\par}
{\tc\tcl2 \v Pending Modifications}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
In {\b SegmentAction::doAction()}, completly disable the movement of {\b TrackSegment} on it's target {\b Track} axis. This should not be needed as, if the algorithm as worked correctly, the next time it's {\b RoutingEvent} is processed, the target {\b Track} will have a free space to insert into. Then the {\b Track} insertion will set the {\b TrackSegment} axis.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Has to complete the lazy evaluation of the {\b TrackSegment} / {\b DataNegociate} / {\b RoutingEvent}. There is still some redundancy when the key of the {\b RoutingEvent} is updated.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
In {\b AutoContact::updateTopology()} & {\b AutoContact::updateGeometry()} we could avoid to systematically run through the Hooks to cache the connected segments. This can be done once at the first call of either method (whichever comes first) on the first revalidate. Afterwards the cache can be updated only by {\b AutoContact::updateTopology()}.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The canonization is done in two places, directly on a set of aligneds AutoSegments through {\b AutoSegment::canonize()} and for the whole net Session::_canonize(), which is called after the initial creation and each time the topology is modificated. The later may be suppressed if we uses more intelligently the former, and gain some more speedup.\par}
\par}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Modifications History
\par}
{\tc\tcl2 \v Modifications History}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Changes in the general architecture
\par}
{\tc\tcl3 \v Changes in the general architecture}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Lazy Update.}  Update of {\b DataNegociate} and {\b RoutingEvent} are now delayed until the event is processed, and systematically done at this point. Thus, the explicit invalidation of those objects is no longer needed. The revalidation is no longer triggered by the revalidation of {\b TrackSegment}.\par}
\par}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Changes in KiteEngine class design
\par}
{\tc\tcl3 \v Changes in KiteEngine class design}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Suppress the lookup table of {\b Hurricane::Segment} toward {\b TrackSegment}. Instead uses the Observer mecanism between {\b Katabatic::AutoSegment} and {\b TrackSegment}.\par}
\par}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Changes in DataNegociate class design
\par}
{\tc\tcl3 \v Changes in DataNegociate class design}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Merge in the separate class {\f2 Cost} .\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Suppress the {\f2 SlackState::Desalignate} , due to the simplificated structure of the AutoSegment/AutoContacts (no more collapseds, or forced alignements).\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Displace the computation and caching of the perpandiculars and perpandicular free interval from {\b RoutingEvent} into {\b DataNegociate}. Allows code factorization with the attractors computation, and data size reduction as there is exaclty one {\b DataNegociate} but there may be more than one {\b RoutingEvent} for the same {\b TrackSegment}.\par}
\par}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Changes in TrackElement class design
\par}
{\tc\tcl3 \v Changes in TrackElement class design}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Due to the simplificated structure of the Katabatic contacts (terminal, turn, vtee & htee), there's no longer collapsed AutoSegment or {\i expandable}  contacts. The {\b desalignate}  feature, relaxing constraints due to collapsed segments or contacts with more than three segments, is no longer implemented. {\b Have to redevelop a method to break long segments linked}  {\b by HTee or VTee.} \par}
\par}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Changes in TrackSegment class design
\par}
{\tc\tcl3 \v Changes in TrackSegment class design}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The method {\f2 TrackSegment::_postModify()}  is merged with {\b TrackSegment::_postDoglegs()} as, in the context of {\b TrackSegment} the only used topological modifications goes through the creation of one or more dogleg.\par}
\par}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Changes in AutoSegment class design
\par}
{\tc\tcl3 \v Changes in AutoSegment class design}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
In {\b AutoSegment::_makeDogleg()}, update the local/global status of the involved AutoSegment and re-canonize only what is necessary. Thus, guarantee that the net's topology is still valid after this method call and no topological update is needed at {\b Session} level (should be {\i much}  faster). In this method, the code sharing between AutoHorizontal and AutoVertical can still be increased (update mechanisms are identicals).\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The {\f2 id}  support is now also implemented at Hurricane level. We may choose to use as a replacement of the one already present in AutoSegment. But in that case, we at least must cache the id in the AutoSegment. So we will not gain in memory footprint, the only benefit would be to have coherent id number throughout all the tools, but the sequentiality will be lost (this may not be a big issue).\par}
\par}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Changes in AutoContact class design
\par}
{\tc\tcl3 \v Changes in AutoContact class design}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
In {\b AutoSegment::invalidate()}, no longer uses collection to walk through attached AutoSegment, directly uses the cache. Much simple and efficient as we exactly know what is attached on every kind of contact.\par}
\par}
\par}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Bug Solving Memento
\par}
{\tc\tcl2 \v Bug Solving Memento}
{\b LUT lookup change:}  When breaking a {\b TrackSegment}, the break may not occurs in the associated canonical AutoSegment. In that case the {\f2 dogleg[O]}  will not match the one that is looked up for the broken (canonical) segment. Thus it was not a bug but a misunderstanding...\par
{\b Overlap of perpandiculars after a dogleg creation:}  The axis of the new parallel was not set to the axis of it's parent. This was due to the uses of {\b AutoSegment::setAxis()} in AutoHorizontal::_makeDogleg() which silently do nothing on non-canonical AutoSegment, and at this point, the re-canonisation did not yet take place. Now Uses AutoSegment::_setAxis() the atomic variant wich works inconditionnaly.\par}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Evaluation with Cadence NanoRoute
\par}
{\tc\tcl2 \v Evaluation with Cadence NanoRoute}
To perform a comparison with NanoRoute the procedure is as follow:\par
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Export the design in Alliance {\f2 DEF}  format. It will generate both {\f2 DEF}  file and the supporting {\f2 LEF}  file containing the technology and the abstract of all the standard cell of the design. As Alliance uses symbolic units (lambda), they are translated with the simple rule: {\b 1 lambda == 1 micron} .\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Run the commands in NanoRoute:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 loadLefFile design.lef} \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 loadDefFile design.def} \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 generateTracks} \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 generateVias} \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 setNanoRouteMode -quiet -drouteFixAntenna 0} \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 setNanoRouteMode -quiet -drouteStartIteration default} \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 setNanoRouteMode -quiet -routeTopRoutingLayer default} \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 setNanoRouteMode -quiet -routeBottomRoutingLayer 2} \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 setNanoRouteMode -quiet -drouteEndIteration default} \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 setNanoRouteMode -quiet -routeWithTimingDriven false} \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 setNanoRouteMode -quiet -routeWithSiDriven false} \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 routeDesign -globalDetail} \par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
To perform as fair a comparison as possible, those commands disable antenna effect protection and disable the use of the {\f2 M1}  as a routing layer ({\f2 -routeBottomRoutingLayer 2} ). Those commands are issued through the graphical interface of NanoRoute.\par}
{\i To see the resulting layout, do not forget to switch the view mode.}  \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Module Index\par \pard\plain 
{\tc \v Module Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Modules\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all modules:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Synthetic Hierarchy (API)\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Algorithm Overview\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Generalities
{\f2  [external]}\par
\par
JSON Support
{\f2  [external]}\par
\par
DbU/Unit description
{\f2  [external]}\par
\par
Graphics
{\f2  [external]}\par
\par
Global Routing Loading
{\f2  [external]}\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Index\par \pard\plain 
{\tc \v Namespace Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Namespace List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all documented namespaces with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b anonymous_namespace\{AutoSegment.cpp\}} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b anonymous_namespace\{ChipTools.cpp\}} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b anonymous_namespace\{GCell.cpp\}} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b anonymous_namespace\{KatabaticEngine.cpp\}} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b anonymous_namespace\{LoadGrByNet.cpp\}} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b anonymous_namespace\{Manipulator.cpp\}} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b anonymous_namespace\{NegociateWindow.cpp\}} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b anonymous_namespace\{RoutingPlane.cpp\}} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b anonymous_namespace\{SegmentFsm.cpp\}} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b anonymous_namespace\{Session.cpp\}} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b anonymous_namespace\{Track.cpp\}} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b anonymous_namespace\{TrackElement.cpp\}} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Kite} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace dedicated to {\b Kite} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
BaseObserver
{\f2  [external]}{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Observer< class >
{\f2  [external]}{
\par
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SegmentObserver\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
DataNegociate\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DBo
{\f2  [external]}{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
ToolEngine
{\f2  [external]}{
\par
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
KatabaticEngine
{\f2  [external]}{
\par
\pard\plain \s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
KiteEngine\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
}\par
RoutingEvent::Key\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Manipulator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NegociateWindow\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
RoutingEvent\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
RoutingEventHistory\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
RoutingEventLoop\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAII \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
RoutingEventQueue\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
RoutingPlane\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SegmentAction\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SegmentFsm\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Session
{\f2  [external]}{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Session\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Track\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANP \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
HorizontalTrack\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
VerticalTrack\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
TrackElement\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQC \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
TrackFixedSegment\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
TrackSegment\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
TrackMarker\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b DataNegociate} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Algorimthmic datas associated the {\b TrackSegment} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b HorizontalTrack} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Horizontal track managment })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b RoutingEvent::Key} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b RoutingEvent} cached key for maps })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b KiteEngine} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Kite} Tool })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Manipulator} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle {\b TrackElement} ripup & topological modifications })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NegociateWindow} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform the routing, main {\b RoutingEvent} manager })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b RoutingEvent} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Atomic Placement Request for a {\b TrackSegment} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b RoutingEventHistory} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
History of {\b RoutingEvent} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b RoutingEventLoop} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simple loop dectector for {\b RoutingEvent} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAII \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b RoutingEventQueue} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The priority Queue of {\b RoutingEvent} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b RoutingPlane} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Array of Tracks in one Layer })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SegmentAction} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Store request for an event to be generated on a {\b TrackElement} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SegmentFsm} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pseudo-decorator to process a {\b RoutingEvent} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SegmentObserver} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Observer on the base AutoSegment })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Session} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Kite} update {\b Session} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Track} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure managing one routing track })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TrackElement} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract Class for all Elements inserted inside a {\b Track} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TrackFixedSegment} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Track} elements for fixed wires })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TrackMarker} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tag part of {\b Track} with a weight })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TrackSegment} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Derived {\b Katabatic::AutoSegment} for the router })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b VerticalTrack} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vertical track managment })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Module Documentation{\tc \v Module Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Synthetic Hierarchy (API)\par \pard\plain 
{\tc\tcl2 \v Synthetic Hierarchy (API)}
{\xe \v Synthetic Hierarchy (API)}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simplificated class hierarchy. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simplificated class hierarchy. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
 \par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Algorithm Overview\par \pard\plain 
{\tc\tcl2 \v Algorithm Overview}
{\xe \v Algorithm Overview}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Description of the algorithm. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Description of the algorithm. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The algorithm top-level is implemented in the {\f2 {\b NegociateWindow}} .\par
{\b First step\~:}  NegociateWindow::_loadRouting() {
\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab Load routing wires ({\f2 AutoSegment} ) from {\f2 KatabaticEngine}  inside the {\b Kite} {\f2 GCell's} . Then update the {\f2 GCell's}  density. \par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
2.\tab Sort the {\f2 GCell's}  according to decreasing density (denser {\f2 GCell's}  are to be routed first). \par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
3.\tab Agglomerate clusters of contiguous GCell's whose density is superior to 0.7 to the seed GCell. See {\f2 GCellRoutingSet}  for the mechanism.\par
GCellRoutingSet receive an increasing order number. The higher the order the lower the density. This order is transmitted to the {\f2 {\b TrackSegment}}  of the {\f2 GCellRoutingSet}  to be taken into account by the track cost function. \par}
{\b Second step\~:}  {\f2 NegociateWindow::_runOnGCellRoutingSet()}  \par
For each {\f2 GCellRoutingSet}  in decreasing density, negociate the set of associated {\f2 {\b TrackSegment}} . {
\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab Build a {\f2 {\b RoutingEventQueue}}  from the list of {\f2 {\b TrackSegment}} . The queue is responsible for allocating the {\f2 {\b RoutingEvent}}  associated to each {\f2 {\b TrackSegment}} . \par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
2.\tab The queue is sorted according to the "event level" then to the priority, which is for now the slack of the {\f2 {\b TrackSegment}} . That is, constrained {\f2 {\b TrackSegment}}  are routed first. \par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
3.\tab The queue is processed till it's empty (no unprocessed {\f2 {\b RoutingEvent}}  remains).\par
Processing a {\f2 {\b RoutingEvent}}  is trying to insert a {\f2 {\b TrackSegment}}  in a suitable {\b Track}. We proceed as follow\~: {
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The maximum ripup count for the to be inserted segment has been reached. Issue a severe warning and left unrouted this {\f2 {\b TrackSegment}}  (for now). \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Compute the Tracks in which the {\f2 {\b TrackSegment}}  can be inserted, then compute the insertion cost in each one. The candidates are ordered by the insertion cost. \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Now consider the lower cost {\f2 {\b Track}} . If there is a free interval for the {\f2 {\b TrackSegment}} . Issue a {\f2 Session::addInsertEvent()}  then finish.\par
If there is a {\i "soft overlap"} , that is the overlaping {\f2 {\b TrackSegment}}  already in the {\f2 {\b Track}}  could be shrunk either to the left or the right so the new {\f2 {\b TrackSegment}}  can be inserted. This is managed by {\f2 RoutingEvent::_setAside()} , for each soft overlaping {\f2 {\b TrackSegment}} , gets its perpandiculars and issue a displacement request for all of them. That is, re-post a {\f2 {\b RoutingEvent}}  with updated constraints and remove the perpandicular from it's {\b Track} if it has already been routed. Note that no request is issued for the overlaping {\f2 {\b TrackSegment}}  itself has it do not change of {\b Track}.\par
If there is a {\i "hard overlap"} , that is the two {\f2 {\b TrackSegment}}  cannot share the same {\f2 {\b Track}} , remove the previous one from the {\f2 {\b Track}}  and re-post a {\f2 {\b RoutingEvent}} . Note that, the cost object should have selected a {\f2 {\b TrackSegment}}  which could be ripped-up. Otherwise the {\f2 {\b Track}}  would'nt even be a candidate. \par}
When a {\b TrackSegment} is riped up, it is re-routed immediately afterward. This is done by increasing his event level. \par}
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Documentation\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
anonymous_namespace\{AutoSegment.cpp\} Namespace Reference\par \pard\plain 
{\tc\tcl2 \v anonymous_namespace\{AutoSegment.cpp\}}
{\xe \v anonymous_namespace\{AutoSegment.cpp\}}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
anonymous_namespace\{ChipTools.cpp\} Namespace Reference\par \pard\plain 
{\tc\tcl2 \v anonymous_namespace\{ChipTools.cpp\}}
{\xe \v anonymous_namespace\{ChipTools.cpp\}}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
anonymous_namespace\{GCell.cpp\} Namespace Reference\par \pard\plain 
{\tc\tcl2 \v anonymous_namespace\{GCell.cpp\}}
{\xe \v anonymous_namespace\{GCell.cpp\}}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
anonymous_namespace\{KatabaticEngine.cpp\} Namespace Reference\par \pard\plain 
{\tc\tcl2 \v anonymous_namespace\{KatabaticEngine.cpp\}}
{\xe \v anonymous_namespace\{KatabaticEngine.cpp\}}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
anonymous_namespace\{LoadGrByNet.cpp\} Namespace Reference\par \pard\plain 
{\tc\tcl2 \v anonymous_namespace\{LoadGrByNet.cpp\}}
{\xe \v anonymous_namespace\{LoadGrByNet.cpp\}}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GCellTopology}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
anonymous_namespace\{Manipulator.cpp\} Namespace Reference\par \pard\plain 
{\tc\tcl2 \v anonymous_namespace\{Manipulator.cpp\}}
{\xe \v anonymous_namespace\{Manipulator.cpp\}}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
anonymous_namespace\{NegociateWindow.cpp\} Namespace Reference\par \pard\plain 
{\tc\tcl2 \v anonymous_namespace\{NegociateWindow.cpp\}}
{\xe \v anonymous_namespace\{NegociateWindow.cpp\}}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
anonymous_namespace\{RoutingPlane.cpp\} Namespace Reference\par \pard\plain 
{\tc\tcl2 \v anonymous_namespace\{RoutingPlane.cpp\}}
{\xe \v anonymous_namespace\{RoutingPlane.cpp\}}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
anonymous_namespace\{SegmentFsm.cpp\} Namespace Reference\par \pard\plain 
{\tc\tcl2 \v anonymous_namespace\{SegmentFsm.cpp\}}
{\xe \v anonymous_namespace\{SegmentFsm.cpp\}}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
anonymous_namespace\{Session.cpp\} Namespace Reference\par \pard\plain 
{\tc\tcl2 \v anonymous_namespace\{Session.cpp\}}
{\xe \v anonymous_namespace\{Session.cpp\}}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
anonymous_namespace\{Track.cpp\} Namespace Reference\par \pard\plain 
{\tc\tcl2 \v anonymous_namespace\{Track.cpp\}}
{\xe \v anonymous_namespace\{Track.cpp\}}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
anonymous_namespace\{TrackElement.cpp\} Namespace Reference\par \pard\plain 
{\tc\tcl2 \v anonymous_namespace\{TrackElement.cpp\}}
{\xe \v anonymous_namespace\{TrackElement.cpp\}}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Kite Namespace Reference\par \pard\plain 
{\tc\tcl2 \v Kite}
{\xe \v Kite}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace dedicated to {\b Kite}. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DataNegociate}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Algorimthmic datas associated the {\b TrackSegment}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b HorizontalTrack}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Horizontal track managment. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b KiteEngine}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Kite} Tool. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Manipulator}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle {\b TrackElement} ripup & topological modifications. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b NegociateWindow}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform the routing, main {\b RoutingEvent} manager. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RoutingEvent}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Atomic Placement Request for a {\b TrackSegment}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RoutingEventHistory}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
History of {\b RoutingEvent}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RoutingEventLoop}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simple loop dectector for {\b RoutingEvent}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RoutingEventQueue}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The priority Queue of {\b RoutingEvent}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RoutingPlane}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Array of Tracks in one Layer. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SegmentAction}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Store request for an event to be generated on a {\b TrackElement}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SegmentFsm}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pseudo-decorator to process a {\b RoutingEvent}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SegmentObserver}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Observer on the base AutoSegment. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Session}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Kite} update {\b Session}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Track}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure managing one routing track. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TrackElement}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract Class for all Elements inserted inside a {\b Track}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TrackFixedSegment}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Track} elements for fixed wires. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TrackMarker}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tag part of {\b Track} with a weight. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TrackSegment}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Derived {\b Katabatic::AutoSegment} for the router. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VerticalTrack}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vertical track managment. }\par}}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void() {\b SegmentOverlapCostCB}(const {\b TrackElement} *, TrackCost &)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b FunctionFlags} \{ , {\b KtLoadGlobalRouting} = 0x00000001, 
{\b KtBuildGlobalRouting} = 0x00000002, 
{\b KtAllowDoglegReuse} = 0x00000004, 
{\b KtDataSelf} = 0x00000008, 
{\b KtNearest} = 0x00000010, 
{\b KtForce} = 0x00000020, 
{\b KtResetCount} = 0x00000040, 
{\b KtWithPerpands} = 0x00000080, 
{\b KtWithConstraints} = 0x00000100
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The namespace dedicated to {\b Kite}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v SegmentOverlapCostCB\:Kite}
{\xe \v Kite\:SegmentOverlapCostCB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SegmentOverlapCostCB}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prototype of overlap cost callback functions.\par
{\b See also:} \~ {\b TrackSegment::setOverlapCostCB()}, TrackSegment::getOverlapCost(). \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v FunctionFlags\:Kite}
{\xe \v Kite\:FunctionFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b FunctionFlags}}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v KtLoadGlobalRouting\:Kite}
{\xe \v Kite\:KtLoadGlobalRouting}
{\qr KtLoadGlobalRouting{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reload the global routing from a preciously saved run ({\f2 } .kgr file). \par
}\cell }{\row }
{\xe \v KtBuildGlobalRouting\:Kite}
{\xe \v Kite\:KtBuildGlobalRouting}
{\qr KtBuildGlobalRouting{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run the global router Knik. \par
}\cell }{\row }
{\xe \v KtAllowDoglegReuse\:Kite}
{\xe \v Kite\:KtAllowDoglegReuse}
{\qr KtAllowDoglegReuse{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allow sharing of dogleg. \par
}\cell }{\row }
{\xe \v KtDataSelf\:Kite}
{\xe \v Kite\:KtDataSelf}
{\qr KtDataSelf{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To be documented. \par
}\cell }{\row }
{\xe \v KtNearest\:Kite}
{\xe \v Kite\:KtNearest}
{\qr KtNearest{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Round the position to the nearest track axis. \par
}\cell }{\row }
{\xe \v KtForce\:Kite}
{\xe \v Kite\:KtForce}
{\qr KtForce{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Force to perform an action ignoring the "up to date" state. \par
}\cell }{\row }
{\xe \v KtResetCount\:Kite}
{\xe \v Kite\:KtResetCount}
{\qr KtResetCount{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tells to reset a counter. \par
}\cell }{\row }
{\xe \v KtWithPerpands\:Kite}
{\xe \v Kite\:KtWithPerpands}
{\qr KtWithPerpands{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ripup perpandiculars alongside the current segment. \par
}\cell }{\row }
{\xe \v KtWithConstraints\:Kite}
{\xe \v Kite\:KtWithConstraints}
{\qr KtWithConstraints{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Force constraints recomputation. \par
}\cell }{\row }
}
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DataNegociate Class Reference\par \pard\plain 
{\tc\tcl2 \v DataNegociate}
{\xe \v DataNegociate}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Algorimthmic datas associated the {\b TrackSegment}. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b SlackState} \{ {\b RipupPerpandiculars} = 1, 
{\b Minimize} = 2, 
{\b Dogleg} = 3, 
{\b Slacken} = 4, 
{\b ConflictSolveByHistory} = 5, 
{\b ConflictSolveByPlaceds} = 6, 
{\b LocalVsGlobal} = 7, 
{\b MoveUp} = 8, 
{\b MaximumSlack} = 9, 
{\b Unimplemented} =10, 
{\b Repair} =11
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasRoutingEvent} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RoutingEvent} * {\b getRoutingEvent} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TrackElement} * {\b getTrackSegment} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Track} * {\b getTrack} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getLeftMinExtend} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getRightMinExtend} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getTerminals} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Net} * {\b getNet} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getState} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getStateCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getRipupCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getStateAndRipupCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getWiringDelta} ({\b DbU::Unit} axis) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Interval} & {\b getPerpandicularFree} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setState} (unsigned int, unsigned int flags=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRoutingEvent} ({\b RoutingEvent} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRipupCount} (unsigned int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b incRipupCount} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b decRipupCount} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetRipupCount} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetStateCount} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Algorimthmic datas associated the {\b TrackSegment}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b DataNegociate} object contains all the informations the negociation algorithm needs to know about a {\b TrackSegment}. Those informations mostly describe the slackening and ripup state of that segment.\par
{\b State related datas:} {
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The ripup count in the current state. The count is reset to zero at each state transition.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The slackening state (see {\b DataNegociate::SlackState}). The state indicate the {\b next}  topological modification to be applied on the segment should the ripup count reach it's maximal value.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The associated {\b RoutingEvent}. If no {\b RoutingEvent} is present, it means the segment has been either successufully placed or the algorithm has given up trying to. If present, it is a {\i pending}  request for placement.\par}
{\b Topological related datas:} {
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 leftMinExtend} , the potential minimal position of the segment left extension. May not be reachable due to other topological constraints.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 rightMinExtend} , the potential minimal position of the segment right extension.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 terminals} , the number of terminals attached to this segment.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 attractors} , a table of coordinates of the end points of the perpandiculars to this segment. Used to compute the wiring delta if we move the axis of the segment.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 perpandiculars} , a {\f2 vector}  of the perpandicular {\b TrackElement}. This is a fast-access cache. It must be updated each time the topology of the net is modificated.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 perpandicularFree} , the free interval defined by the perpandiculars, that is for the sgement axis.\par}
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Perpandiculars, Free, Attractors & Wiring Delta
\par}
{\tc\tcl2 \v Perpandiculars, Free, Attractors & Wiring Delta}
All those informations are computed and updated by the {\b DataNegociate::update()} method, which relies on:{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
AutoSegment::getTopologicalInfos()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
AutoSegment::getTerminalCount()\par}
They must be reviewed as they do not take advantage of the new AutoSegment structuration.\par
For every perpandicular set of AutoSegment to the {\b TrackSegment} we want to place, get the coordinates of the extremity not connected to the segment and put that coordinate into a table associated with it's {\i spin} . The {\i spin}  tells if the extremity is attracting the segment {\i up}  or {\i down}  (for an horizontal segment). The {\i spin}  is incremented for up and decremented for down. After all the extremities have been processeds, we took into account only the coordinates with a non-zero spin, which means they truly attract the segment (whatever the direction).\par
 The {\i wiring delta}  is the total wire length needed to connect from the attractors to the segment, should it be placed on {\f2 axis} .\par
\par}
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Modifications History
\par}
{\tc\tcl2 \v Modifications History}
Main changes in {\b DataNegociate} class design:{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Merge in the separate class {\f2 Cost} .\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Suppress the {\f2 SlackState::Desalignate} , due to the simplificated structure of the AutoSegment/AutoContacts (no more collapseds, or forced alignements). \par}
\par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v SlackState\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:SlackState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b SlackState}}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Describe the various stages of a {\b TrackSegment} slackening. The numerical values are choosen so we can increment them as a counter. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v RipupPerpandiculars\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:RipupPerpandiculars}
{\qr RipupPerpandiculars{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Force perpandiculars to be riped up as well as the {\b TrackSegment}, then schedule the placement of the {\b TrackSegment} {\i before}  it's perpandiculars. \par
}\cell }{\row }
{\xe \v Minimize\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:Minimize}
{\qr Minimize{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the {\b TrackSegment} is made of multiple TrackSegments with a forced alignement, suppress the alignement constraint.\par
This should be deprecated now. Try to displace the perpandiculars so the {\b TrackSegment} is reduced to it's minimal length. \par
}\cell }{\row }
{\xe \v Dogleg\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:Dogleg}
{\qr Dogleg{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Break the segment into two smaller ones. \par
}\cell }{\row }
{\xe \v Slacken\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:Slacken}
{\qr Slacken{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create additional wiring so threre is no more contraints transmitted by the perpandiculars or the terminal contacts. \par
}\cell }{\row }
{\xe \v ConflictSolveByHistory\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:ConflictSolveByHistory}
{\qr ConflictSolveByHistory{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Try to solve a conflict between a set of global segments by analysing the event/ripup history. See {\b SegmentFsm::conflictSolveByHistory()}. \par
}\cell }{\row }
{\xe \v ConflictSolveByPlaceds\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:ConflictSolveByPlaceds}
{\qr ConflictSolveByPlaceds{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Try to solve a conflict between a set of global segments by analysing the current track context. See {\b SegmentFsm::conflictSolveByPlaceds()}. \par
}\cell }{\row }
{\xe \v LocalVsGlobal\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:LocalVsGlobal}
{\qr LocalVsGlobal{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To be reviewed. \par
}\cell }{\row }
{\xe \v MoveUp\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:MoveUp}
{\qr MoveUp{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The segment is to be moved up (if possible). \par
}\cell }{\row }
{\xe \v MaximumSlack\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:MaximumSlack}
{\qr MaximumSlack{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The final state, topological modifications are exhausteds, if it cannot place at this point, it never will. \par
}\cell }{\row }
{\xe \v Unimplemented\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:Unimplemented}
{\qr Unimplemented{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used only during the development stage, telling that the state is not available yet. \par
}\cell }{\row }
{\xe \v Repair\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:Repair}
{\qr Repair{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The router is in repair mode. \par
}\cell }{\row }
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v hasRoutingEvent\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:hasRoutingEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool hasRoutingEvent () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if there is a pending {\b RoutingEvent} for this {\b TrackSegment}. \par
}{
Referenced by NegociateWindow::addRoutingEvent(), and TrackSegment::reschedule().}\par
}
{\xe \v getRoutingEvent\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:getRoutingEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingEvent} * getRoutingEvent () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The pending {\b RoutingEvent}. {\f2 NULL}  will be returned if there is no pending event, meaning that the segment has been placed. \par
}{
Referenced by SegmentAction::doAction(), Manipulator::makeDogleg(), Manipulator::relax(), TrackSegment::reschedule(), RoutingEvent::reschedule(), and TrackSegment::swapTrack().}\par
}
{\xe \v getTrackSegment\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:getTrackSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackSegment} * getTrackSegment () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The associated {\b TrackSegment}. \par
}}
{\xe \v getTrack\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:getTrack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Track} * getTrack () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  A proxy accessor for the segment's track. \par
}}
{\xe \v getLeftMinExtend\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:getLeftMinExtend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getLeftMinExtend () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The minimum extend possible of the segment's source (left) ending. Computed by {\b DataNegociate::update()}. \par
}{
Referenced by Manipulator::insertInTrack().}\par
}
{\xe \v getRightMinExtend\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:getRightMinExtend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getRightMinExtend () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The minimum extend possible of the segment's target (right) ending. Computed by {\b DataNegociate::update()}. \par
}{
Referenced by Manipulator::insertInTrack().}\par
}
{\xe \v getTerminals\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:getTerminals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getTerminals () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The number of terminal to which this segment is connected Computed by {\b DataNegociate::update()}.\par
Must be refined: direct or indirect?. \par
}}
{\xe \v getNet\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:getNet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Net} * getNet () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  A cached accessor to the segment's net (for faster access). \par
}}
{\xe \v getState\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:getState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getState () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The current state (see {\b DataNegociate::SlackState}). \par
}{
Referenced by RoutingEvent::getState(), Manipulator::insertInTrack(), and Manipulator::ripupPerpandiculars().}\par
}
{\xe \v getStateCount\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:getStateCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getStateCount () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The number of times we have reached the ripup limit while in this stage. \par
}{
Referenced by SegmentFsm::conflictSolveByPlaceds().}\par
}
{\xe \v getRipupCount\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:getRipupCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getRipupCount () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The number of times the segment has been riped up in this stage. \par
}{
Referenced by Manipulator::canRipup(), SegmentAction::doAction(), and RoutingEvent::process().}\par
}
{\xe \v getStateAndRipupCount\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:getStateAndRipupCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getStateAndRipupCount () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A composite number combining the state and the ripup count: {\f2 (state<<4)+ripup} . \par
}}}
{\xe \v getWiringDelta\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:getWiringDelta}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getWiringDelta ({\b DbU::Unit}  {\i axis}) const}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The wiring length needed to connect to the attractors if the segment is put on {\f2 axis} . The lower, the better... \par
}}
{\xe \v getPerpandicularFree\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:getPerpandicularFree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Interval} & getPerpandicularFree () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The range of legal positions generated only by the perpandiculars. \par
}}
{\xe \v setState\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:setState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setState (unsigned int  {\i state}, unsigned int  {\i flags} = {\f2 0}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set or reset the slacking state (see SlackState). If the {\f2 state}  is the same as the current one, the state count is incremented. If the new state changes or {\f2 flags}  contain KtReset, the state count is reset to one. \par
}{
Referenced by SegmentAction::doAction(), Manipulator::relax(), Manipulator::repackPerpandiculars(), RoutingEvent::reschedule(), Manipulator::ripupPerpandiculars(), and RoutingEvent::setState().}\par
}
{\xe \v setRoutingEvent\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:setRoutingEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setRoutingEvent ({\b RoutingEvent} *  {\i event}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Associate {\f2 event}  to this {\b TrackSegment}. \par
}{
Referenced by RoutingEvent::reschedule(), and RoutingEvent::setSegment().}\par
}
{\xe \v setRipupCount\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:setRipupCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setRipupCount (unsigned int  {\i count}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Directly sets the ripup count to {\f2 count} . \par
}{
Referenced by SegmentAction::doAction().}\par
}
{\xe \v incRipupCount\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:incRipupCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void incRipupCount (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Increment the ripup count. No check is performed for bound limit. \par
}}
{\xe \v decRipupCount\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:decRipupCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void decRipupCount (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Decrement the ripup count (will never go below zero). \par
}}
{\xe \v resetRipupCount\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:resetRipupCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void resetRipupCount (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset the ripup count to zero. \par
}{
Referenced by SegmentAction::doAction().}\par
}
{\xe \v resetStateCount\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:resetStateCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void resetStateCount (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset the state count to zero. \par
}}
{\xe \v update\:Kite::DataNegociate}
{\xe \v Kite::DataNegociate\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void update ()}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Recompute {\f2 leftMinExtend} , {\f2 righMinExtend} , number of terminals and attractors positions.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: The constructor do not calls it. It is to the algorithm responsability\par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid to call it before using the computed datas. \par
}}{
Referenced by NegociateWindow::setGCells().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
DataNegociate.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
DataNegociate.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
DataNegociate.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
HorizontalTrack Class Reference\par \pard\plain 
{\tc\tcl2 \v HorizontalTrack}
{\xe \v HorizontalTrack}
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Horizontal track managment. }}\par
Inheritance diagram for HorizontalTrack:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKite_1_1HorizontalTrack__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isHorizontal} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isVertical} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b getDirection} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Point} {\b getPosition} ({\b DbU::Unit} coordinate) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Horizontal track managment. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v isHorizontal\:Kite::HorizontalTrack}
{\xe \v Kite::HorizontalTrack\:isHorizontal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isHorizontal () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true} . \par
}{
Implements {\b Track} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v isVertical\:Kite::HorizontalTrack}
{\xe \v Kite::HorizontalTrack\:isVertical}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isVertical () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b false} . \par
}{
Implements {\b Track} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getDirection\:Kite::HorizontalTrack}
{\xe \v Kite::HorizontalTrack\:getDirection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getDirection () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  Katabatic::KbHorizontal. \par
}{
Implements {\b Track} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getPosition\:Kite::HorizontalTrack}
{\xe \v Kite::HorizontalTrack\:getPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Point} getPosition ({\b DbU::Unit}  {\i position}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  the point at {\f2 } (position,{\b getAxis()}). \par
}{
Implements {\b Track} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
HorizontalTrack.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
HorizontalTrack.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
HorizontalTrack.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RoutingEvent::Key Class Reference\par \pard\plain 
{\tc\tcl2 \v RoutingEvent::Key}
{\xe \v RoutingEvent::Key}
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b RoutingEvent} cached key for maps. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} (const {\b RoutingEvent} *)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b RoutingEvent} cached key for maps. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The key is used as a cache in {\b RoutingEvent}, that is, the {\b RoutingEvent} attributes could be modificated without the key changing. It is important for the key to remain stable as it used in the various event queue as the sorting attribute. The key should be updated only when the {\b RoutingEvent} is temporarily whidrawn from the queue.\par
Cached attributes: (used in that lexicographical order for sorting){
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b 1}  \'96 {\f2 eventLevel} .\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b 2}  \'96 {\f2 canRipple} .\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b 3}  \'96 {\f2 priority} .\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b 4}  \'96 {\f2 length} .\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b 5}  \'96 {\f2 isHorizontal} .\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b 6}  \'96 {\f2 axis} .\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b 7}  \'96 {\f2 sourceU} .\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b 8}  \'96 {\f2 net}  (name).\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b 9}  \'96 {\f2 id} .\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b X}  \'96 {\f2 slackenStrap}  {\b unused} .\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b X}  \'96 {\f2 tracksNb}  {\b unused} .\par}
It is internally managed by {\b RoutingEvent} and the queue. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v update\:Kite::RoutingEvent::Key}
{\xe \v Kite::RoutingEvent::Key\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
update (const {\b RoutingEvent} *  {\i event})}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Cache the value of the key from {\f2 event} . \par
}{
Referenced by RoutingEvent::updateKey().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
RoutingEvent.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
RoutingEvent.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
RoutingEvent.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
KiteEngine Class Reference\par \pard\plain 
{\tc\tcl2 \v KiteEngine}
{\xe \v KiteEngine}
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Kite} Tool. }}\par
Inheritance diagram for KiteEngine:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKite_1_1KiteEngine__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b KatabaticEngine} * {\b base} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Configuration * {\b getKiteConfiguration} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual Configuration * {\b getConfiguration} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Net} * {\b getBlockageNet} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getToolSuccess} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b getEventsLimit} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getRipupLimit} (unsigned int type) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getRipupCost} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b Name} & {\b staticGetName} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b KiteEngine} * {\b create} ({\b Cell} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b KiteEngine} * {\b get} (const {\b Cell} *)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Kite} Tool. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Lookup Mechanism} \par
Please look at {\b Kite::Session} for an explanation of the lookup mechanism from {\b Hurricane::Segment} or {\b Katabatic::AutoSegment} to {\b TrackSegment}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v staticGetName\:Kite::KiteEngine}
{\xe \v Kite::KiteEngine\:staticGetName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Name} & staticGetName (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The unique string identifier for the {\b KiteEngine} class of ToolEngine. \par
}}
{\xe \v create\:Kite::KiteEngine}
{\xe \v Kite::KiteEngine\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b KiteEngine} * create ({\b Cell} *  {\i cell}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a {\b KiteEngine} on {\f2 cell} . \par
}}
{\xe \v get\:Kite::KiteEngine}
{\xe \v Kite::KiteEngine\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b KiteEngine} * get (const {\b Cell} *  {\i cell}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b KiteEngine} associated to {\f2 cell} . {\f2 NULL}  if there isn't. \par
}}
{\xe \v base\:Kite::KiteEngine}
{\xe \v Kite::KiteEngine\:base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b KatabaticEngine} * base (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b KiteEngine}, casted as it's base class (KatabaticEngine). \par
}}
{\xe \v getKiteConfiguration\:Kite::KiteEngine}
{\xe \v Kite::KiteEngine\:getKiteConfiguration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Configuration * getKiteConfiguration (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b KiteEngine} configuration. The {\b Kite} Configuration is a derived class of KatabaticConfiguration. \par
}}
{\xe \v getConfiguration\:Kite::KiteEngine}
{\xe \v Kite::KiteEngine\:getConfiguration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Configuration * getConfiguration (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b KiteEngine} configuration. \par
}{
Reimplemented from {\b KatabaticEngine}.}\par
}
{\xe \v getBlockageNet\:Kite::KiteEngine}
{\xe \v Kite::KiteEngine\:getBlockageNet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Net} * getBlockageNet (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The Net which is used to mark the blockage segments. It's not part of the Configuration {\i per se}  but an isolated attribute. \par
}}
{\xe \v getToolSuccess\:Kite::KiteEngine}
{\xe \v Kite::KiteEngine\:getToolSuccess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool getToolSuccess () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the tool was successful, that is, all the Net were routeds. \par
}}
{\xe \v getEventsLimit\:Kite::KiteEngine}
{\xe \v Kite::KiteEngine\:getEventsLimit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long getEventsLimit () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The maximal number of allowed routing events. This limit is a security against infinite looping, be sure that it is great enough not to prevent normal routing completion. \par
}}
{\xe \v getRipupLimit\:Kite::KiteEngine}
{\xe \v Kite::KiteEngine\:getRipupLimit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long getRipupLimit (unsigned int  {\i type}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  the maximum ripup allowed of a segment of {\f2 type} . \par
}{
Referenced by Manipulator::canRipup(), and SegmentAction::doAction().}\par
}
{\xe \v getRipupCost\:Kite::KiteEngine}
{\xe \v Kite::KiteEngine\:getRipupCost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long getRipupCost () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  the differential used while comparing two ripup costs. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
KiteEngine.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
KiteEngine.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Manipulator Class Reference\par \pard\plain 
{\tc\tcl2 \v Manipulator}
{\xe \v Manipulator}
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle {\b TrackElement} ripup & topological modifications. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b FunctionFlag} \{ {\b ToRipupLimit} = 0x0001, 
{\b AllowExpand} = 0x0002, 
{\b NoExpand} = 0x0004, 
{\b PerpandicularsFirst} = 0x0008, 
{\b ToMoveUp} = 0x0010, 
{\b AllowLocalMoveUp} = 0x0020, 
{\b AllowTerminalMoveUp} = 0x0040, 
{\b AllowShortPivotUp} = 0x0080, 
{\b NoDoglegReuse} = 0x0100, 
{\b LeftAxisHint} = 0x0200, 
{\b RightAxisHint} = 0x0400, 
{\b NotOnLastRipup} = 0x0800
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Manipulator} ({\b TrackElement} *, {\b SegmentFsm} &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TrackElement} * {\b getSegment} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DataNegociate} * {\b getData} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RoutingEvent} * {\b getEvent} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b canRipup} (unsigned int flags=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isCaged} ({\b DbU::Unit}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ripup} (unsigned int type, {\b DbU::Unit} axisHint=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ripupPerpandiculars} (unsigned int flags=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b repackPerpandiculars} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ripple} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b minimize} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b slacken} (unsigned int flags=KbNoFlags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b pivotUp} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b pivotDown} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b moveUp} (unsigned int flags=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b makeDogleg} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b makeDogleg} ({\b DbU::Unit})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b makeDogleg} ({\b Interval})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b relax} ({\b Interval}, unsigned int flags={\b AllowExpand})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b insertInTrack} (size_t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b shrinkToTrack} (size_t, unsigned int flags=0, {\b DbU::Unit} leftAxisHint=0, {\b DbU::Unit} rightAxisHint=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b forceToTrack} (size_t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b forceOverLocals} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle {\b TrackElement} ripup & topological modifications. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Manipulator Structure
\par}
{\tc\tcl2 \v Manipulator Structure}
A {\b Manipulator} basically binds together a {\b TrackElement}, it's {\b DataNegociate} and {\b RoutingEvent} (cached for fast access), and {\b a}  {\b SegmentFsm}.\par
{\i The {\b TrackElement} may differs from the one of the {\b SegmentFsm}.}  This can occurs when manipulating perpandiculars or segments from other nets in conflict. For example: {\b Manipulator::isCaged()}.\par
In the following documentation, the segment {\i which is associated to the {\b SegmentFsm}}  will be called the {\i reference segment} .\par}
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Delayed Modifications
\par}
{\tc\tcl2 \v Delayed Modifications}
It is important to note that when a {\b Manipulator} is called to modificate a {\b TrackElement}, nothing is actually done by the {\b Manipulator} itself. Instead, the {\b Manipulator} create the relevant {\b SegmentAction} (s) that are stored in the {\b SegmentFsm}. The action themselves are done at the end of the {\b SegmentFsm} lifecycle (wrapped inside a {\b Session}).\par
This is not true! When dogleg are created, the topology is immediatly modificated. That way of doing must be clarified. \par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v FunctionFlag\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:FunctionFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b FunctionFlag}}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The various flags that can be passed to the {\b Manipulator} methods. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v ToRipupLimit\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:ToRipupLimit}
{\qr ToRipupLimit{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The ripup limit must be immediatly to it's limit for the current state. \par
}\cell }{\row }
{\xe \v AllowExpand\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:AllowExpand}
{\qr AllowExpand{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allow break points for dogleg not to be exactly on the requested position. Meaning that they are moved to the least congested GCell. \par
}\cell }{\row }
{\xe \v NoExpand\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:NoExpand}
{\qr NoExpand{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Breakpoints for dogleg are kept right where they are requested. \par
}\cell }{\row }
{\xe \v PerpandicularsFirst\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:PerpandicularsFirst}
{\qr PerpandicularsFirst{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reorder the events so that perpandiculars segments are re-processed before their reference segment. By default this is the other way around. \par
}\cell }{\row }
{\xe \v ToMoveUp\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:ToMoveUp}
{\qr ToMoveUp{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Try to move up ripped up segments. \par
}\cell }{\row }
{\xe \v AllowLocalMoveUp\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:AllowLocalMoveUp}
{\qr AllowLocalMoveUp{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allow local segments to be moved up (forbidden by default). \par
}\cell }{\row }
{\xe \v AllowTerminalMoveUp\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:AllowTerminalMoveUp}
{\qr AllowTerminalMoveUp{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allow terminal segments to be moved up (forbidden by default). \par
}\cell }{\row }
{\xe \v AllowShortPivotUp\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:AllowShortPivotUp}
{\qr AllowShortPivotUp{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allow short segment yo be pivoted up. \par
}\cell }{\row }
{\xe \v NoDoglegReuse\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:NoDoglegReuse}
{\qr NoDoglegReuse{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When creating a dogleg, the default behavior is {\i not}  to create a new one if there's already one in the same GCell. If this flag is set, a second dogleg will be created. \par
}\cell }{\row }
{\xe \v LeftAxisHint\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:LeftAxisHint}
{\qr LeftAxisHint{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An explicit left axis hint has been supplied as argument. \par
}\cell }{\row }
{\xe \v RightAxisHint\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:RightAxisHint}
{\qr RightAxisHint{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An explicit right axis hint has been supplied as argument. \par
}\cell }{\row }
{\xe \v NotOnLastRipup\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:NotOnLastRipup}
{\qr NotOnLastRipup{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The reference segment has still more than one ripup to go for the given state. \par
}\cell }{\row }
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Manipulator\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:Manipulator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Manipulator} ({\b TrackElement} *  {\i segment}, {\b SegmentFsm} &  {\i fsm})}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i segment} \cell }{The {\b TrackElement} to manipulate. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fsm} \cell }{The associated {\b SegmentFsm}.\cell }
{\row }
}
Construct a new {\b Manipulator} on {\f2 segment} . \par
}{
Referenced by Manipulator::forceOverLocals(), Manipulator::forceToTrack(), Manipulator::insertInTrack(), Manipulator::ripupPerpandiculars(), and Manipulator::shrinkToTrack().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getSegment\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:getSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * getSegment () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The working {\b TrackElement}. \par
}}
{\xe \v getData\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:getData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DataNegociate} * getData () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b DataNegociate} of the {\b TrackElement} (act as a cache). \par
}}
{\xe \v getEvent\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:getEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingEvent} * getEvent () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b RoutingEvent} associated to the {\b TrackElement} (act as a cache). \par
}}
{\xe \v canRipup\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:canRipup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool canRipup (unsigned int  {\i flags} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the maximum ripup, for the given {\b SegmentFsm::State} has not been reached. If {\f2 flags}  contains Manipulator::HasNextRipup, return {\b true}  {\b only}  if it still have at least one ripup to go. \par
}{
Referenced by Manipulator::forceToTrack(), and Manipulator::ripup().}\par
}
{\xe \v isCaged\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:isCaged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isCaged ({\b DbU::Unit}  {\i axis}) const}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the segment is enclosed (in it's {\b Track}) by two fixed or blockage segments which at least one is closer than 10 lambdas from {\f2 axis} . Mostly used to know if a perpandicular is actually restricting the axis span of a reference segment. \par
}{
Referenced by Manipulator::ripupPerpandiculars().}\par
}
{\xe \v ripup\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:ripup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ripup (unsigned int  {\i type}, {\b DbU::Unit}  {\i axisHint} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type} \cell }{The type of ripup action. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i axisHint} \cell }{An indication as where to move the riped up segment. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b true}  if the operation has succedeed.\par
}If the {\b TrackElement} can be ripped up, schedule a ripup action, possibly with a hint for the preferred axis position. \par
}{
Referenced by Manipulator::forceOverLocals(), Manipulator::forceToTrack(), Manipulator::insertInTrack(), and Manipulator::ripupPerpandiculars().}\par
}
{\xe \v ripupPerpandiculars\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:ripupPerpandiculars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ripupPerpandiculars (unsigned int  {\i flags} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Schedule a ripup of all the perpandiculars of the reference segment. {\f2 flags}  that modificate the behavior:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Manipulator::PerpandicularsFirst} : the queue will be reordered so that all the perpandiculars are re-processed (placed) before the reference segment.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Manipulator::ToRipupLimit} : the ripup count of the reference segment is set to the limit (i.e. only one more attempt before a slackening occurs).\par}
The method will fails (return {\b false} ) if at least one perpandicular can't be changed of track (i.e. ripped up) {\b and}  none of it's neighbors could be ripped up either. Meaning that the free span on that track cannot be changed. \par
}{
Referenced by SegmentFsm::conflictSolveByPlaceds().}\par
}
{\xe \v repackPerpandiculars\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:repackPerpandiculars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool repackPerpandiculars ()}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ripup all the perpandiculars of the reference segment, except fixed or globals. The reference segment is rescheduled first (before it's perpandicular).\par
This function may be used to find a better placement, maximizing the overlap of the various perpandiculars.\par
Ripup all perpandiculars and the reference segment itself for a complete re-placement. The reference segment will be reprocessed {\i before}  it's perpandiculars. \par
}}
{\xe \v ripple\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:ripple}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ripple ()}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  true if the reference segment is local.\par
Applies only on reference segments that are of local type. Tries to make room for the reference segment by ripping up it's neigbors on the parallels tracks. On a vertical plane, left neigbors are shifted one track left (trough axis hint) and right ones, one track right. Note that they are ripped up and the shift is just a hint, there's no guarantee that the router can honor it. \par
}{
Referenced by Manipulator::ripupPerpandiculars().}\par
}
{\xe \v minimize\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:minimize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool minimize ()}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  true if the reference segment can be mimized in a suitable track hole.\par
Compute the miminal span of the reference segment, summing up contraints from source anchor and target anchors (if any) and perpandiculars. Then find holes in the avalaible tracks, and check if one is suitable for the miminized segment (try first the biggest hole).\par
This operation can only be called once on a segment (a flag is set in the event). \par
}}
{\xe \v slacken\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:slacken}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool slacken (unsigned int  {\i flags} = {\f2 KbNoFlags})}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simple proxy towards TrackElement::slacken().\par
To be reviewed. \par
}}
{\xe \v pivotUp\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:pivotUp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool pivotUp ()}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tries to move up the reference segment. The segment will be moved up only if a half track is free (for a local) or a full track is free (for a global).\par
This function do not modifies/create perpandiculars. \par
}{
Referenced by SegmentFsm::solveFullBlockages().}\par
}
{\xe \v pivotDown\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:pivotDown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool pivotDown ()}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tries to move down the reference segment. The segment will be moved up only if {\i two}  track are free (whether global or local). Is is more restrictive than {\b Manipulator::pivotUp()}.\par
This function do not modifies/create perpandiculars. \par
}}
{\xe \v moveUp\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:moveUp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool moveUp (unsigned int  {\i flags} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tries to move up a segment, if there is enough space in the {\b RoutingPlane} above and in the same direction.\par
This function may modificate perpandiculars in order to maintain connexity.\par
To be reviewed. \par
}{
Referenced by SegmentFsm::solveFullBlockages().}\par
}
{\xe \v makeDogleg\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:makeDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool makeDogleg ()}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b false}  if the segment is {\i not}  local or the dogleg cannot be done.\par
For {\i local}  reference segment only, look in the first track candidate for other segment overlapping and break the reference accordingly. \par
}}
{\xe \v makeDogleg\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:makeDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool makeDogleg ({\b DbU::Unit}  {\i position})}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a dogleg in the GCell under {\f2 position} . \par
}}
{\xe \v makeDogleg\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:makeDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool makeDogleg ({\b Interval}  {\i overlap})}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a dogleg to avoid the obstructed interval {\f2 overlap} . \par
}}
{\xe \v relax\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:relax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool relax ({\b Interval}  {\i overlap}, unsigned int  {\i flags} = {\f2 {\b AllowExpand}})}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Break the reference segment so it can detour around the interval {\f2 overlap} . If {\f2 overlap}  is completly enclosed inside the span of the reference segment two dogleg will be created. If the overlap occurs only on one side of the reference segment, only one dogleg will be created.\par
If {\f2 flags}  contains {\b Manipulator::AllowExpand}, the dogleg are not created exactly at the edges of the overlap but on the lowest density GCell (outside the overlap interval).\par
The axis of the created dogleg are sets so that the broken part of the segment completly enclose {\f2 overlap} . That is, the orignal segment no longer intersect with {\f2 overlap} . So the min dogleg is pushed to the left and the max to the right if they are in the same GCell as the min/max of {\f2 overlap} . Otherwise (they have been expanded), they are put in the center of the GCell.\par
We do not allow to dogleg twice in the same GCell, so if min or max is in respectively the first or last GCell, it is not done. Moreover if there is only one dogleg {\i and}  it is in the first or last GCell, the relax method is cancelled (and returns {\b false} ). It means that this is the segment which is likely to be enclosed inside {\f2 overlap} .\par
{\b Important:}  The doglegs are created immediatly and not in a delayed fashion like the {\b SegmentAction}.\par
    \par
}}
{\xe \v insertInTrack\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:insertInTrack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool insertInTrack (size_t  {\i i})}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Try to insert the reference segment in the track at index {\f2 i}  (in the cost table from {\b SegmentFsm}). The insertion is done by ripping up overlapping segment or shrinking them to left/right if possible.\par
This operation ripup the processed segment neighbors (and their perpandiculars). \par
}}
{\xe \v shrinkToTrack\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:shrinkToTrack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool shrinkToTrack (size_t  {\i i}, unsigned int  {\i flags} = {\f2 0}, {\b DbU::Unit}  {\i leftAxisHint} = {\f2 0}, {\b DbU::Unit}  {\i rightAxisHint} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempt to minimize the reference segment to fit into the track. For this operation to succeed, the minimal span of the segment must not overlap any other segment already in the track. To reach the minimal span the perpandiculars are ripped up with an axis hint which is the center of the minimal span or the explicit value given as arguments {\f2 leftAxisHint}  and {\f2 rightAxisHint}  if {\f2 flags}  contains respectively {\b Manipulator::LeftAxisHint} or {\b Manipulator::RightAxisHint}.\par
This operation ripup the processed segment itself and its perpandiculars. \par
}}
{\xe \v forceToTrack\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:forceToTrack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool forceToTrack (size_t  {\i i})}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Try to insert the reference segment in the track at index {\f2 i}  (in the cost table from {\b SegmentFsm}). The insertion is done by {\i forcibly}  ripping up the overlapping segments {\b and}  their perpandiculars.\par
This operation ripup the processed segment neighbors (and their perpandiculars). \par
}}
{\xe \v forceOverLocals\:Kite::Manipulator}
{\xe \v Kite::Manipulator\:forceOverLocals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool forceOverLocals ()}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Loop over all the candidate tracks and, insert in the first which all conflicting segments are locals (rip them up). \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Manipulator.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Manipulator.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Manipulator.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NegociateWindow Class Reference\par \pard\plain 
{\tc\tcl2 \v NegociateWindow}
{\xe \v NegociateWindow}
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform the routing, main {\b RoutingEvent} manager. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Stage} \{ {\b Negociation} = 1, 
{\b Packing} = 2
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b destroy} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInterrupted} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b KiteEngine} * {\b getKiteEngine} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Hurricane::Cell} * {\b getCell} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const Katabatic::GCellVector & {\b getGCells} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RoutingEventQueue} & {\b getEventQueue} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RoutingEventHistory} & {\b getEventHistory} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RoutingEventLoop} & {\b getEventLoop} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Stage} {\b getStage} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setGCells} (const Katabatic::GCellVector &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setInterrupt} (bool)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setStage} ({\b Stage})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b computeWirelength} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TrackElement} * {\b createTrackSegment} ({\b AutoSegment} *, unsigned int flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addRoutingEvent} ({\b TrackElement} *, unsigned int level)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rescheduleEvent} ({\b RoutingEvent} *, unsigned int level)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b run} (unsigned int flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printStatistics} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b NegociateWindow} * {\b create} ({\b KiteEngine} *)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform the routing, main {\b RoutingEvent} manager. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This object perform the routing. That is creates all the initial {\b RoutingEvent}, load them into the queue and then process the queue until it is empty, that is, the routing is finished.\par
This object is the owner of the {\b RoutingEventQueue}, {\b RoutingEventHistory} and {\b RoutingEventLoop} used all troughout {\b RoutingEvent} and {\b SegmentFsm}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v Stage\:Kite::NegociateWindow}
{\xe \v Kite::NegociateWindow\:Stage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Stage}}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The state under which the router is operating. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Negociation\:Kite::NegociateWindow}
{\xe \v Kite::NegociateWindow\:Negociation}
{\qr Negociation{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The normal mode, priority negociation with ripup. \par
}\cell }{\row }
{\xe \v Packing\:Kite::NegociateWindow}
{\xe \v Kite::NegociateWindow\:Packing}
{\qr Packing{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Try to find a better placement for segment but just by looking for other fully free spaces. No ripup is performed. \par
}\cell }{\row }
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v create\:Kite::NegociateWindow}
{\xe \v Kite::NegociateWindow\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
create ({\b KiteEngine} *  {\i kite}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The publicly avalaible contructor. Route the whole are defined by the {\b Kite} associated Cell abutment box. \par
}}
{\xe \v destroy\:Kite::NegociateWindow}
{\xe \v Kite::NegociateWindow\:destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void destroy ()}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The publicly avalaible destructor. \par
}}
{\xe \v isInterrupted\:Kite::NegociateWindow}
{\xe \v Kite::NegociateWindow\:isInterrupted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isInterrupted () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the {\b NegociateWindow} has received an interrupt request. \par
}}
{\xe \v getKiteEngine\:Kite::NegociateWindow}
{\xe \v Kite::NegociateWindow\:getKiteEngine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b KiteEngine} * getKiteEngine () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The associated {\b KiteEngine}. \par
}{
Referenced by NegociateWindow::printStatistics().}\par
}
{\xe \v getCell\:Kite::NegociateWindow}
{\xe \v Kite::NegociateWindow\:getCell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Hurricane::Cell} * getCell () const}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The associated Cell. \par
}}
{\xe \v getGCells\:Kite::NegociateWindow}
{\xe \v Kite::NegociateWindow\:getGCells}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const Katabatic::GCellVector & getGCells () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  A Copy of the vector of GCell from KatabaticEngine. The vector is copied but not the GCell themselves (shallow copy). \par
}}
{\xe \v getEventQueue\:Kite::NegociateWindow}
{\xe \v Kite::NegociateWindow\:getEventQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingEventQueue} & getEventQueue (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b RoutingEventQueue}. \par
}}
{\xe \v getEventHistory\:Kite::NegociateWindow}
{\xe \v Kite::NegociateWindow\:getEventHistory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingEventHistory} & getEventHistory (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b RoutingEventHistory}. \par
}}
{\xe \v getEventLoop\:Kite::NegociateWindow}
{\xe \v Kite::NegociateWindow\:getEventLoop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingEventLoop} & getEventLoop (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b RoutingEventLoop}. \par
}}
{\xe \v getStage\:Kite::NegociateWindow}
{\xe \v Kite::NegociateWindow\:getStage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Stage} getStage () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The stage (NegicateWindow::Stage) into which the {\b NegociateWindow} is running. \par
}}
{\xe \v setGCells\:Kite::NegociateWindow}
{\xe \v Kite::NegociateWindow\:setGCells}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setGCells (const Katabatic::GCellVector &  {\i v})}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the GCell vector from KatabaticEngine (perform a shallow copy). \par
}}
{\xe \v setInterrupt\:Kite::NegociateWindow}
{\xe \v Kite::NegociateWindow\:setInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setInterrupt (bool  {\i state}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets or unset the interruption flag. \par
}}
{\xe \v setStage\:Kite::NegociateWindow}
{\xe \v Kite::NegociateWindow\:setStage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setStage ({\b Stage}  {\i stage}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the stage ({\b NegociateWindow::Stage}) under which we are running. \par
}}
{\xe \v computeWirelength\:Kite::NegociateWindow}
{\xe \v Kite::NegociateWindow\:computeWirelength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double computeWirelength ()}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute the total wirelength of the circuit. It is not completly accurate because overlaps are not took into accounts. \par
}{
Referenced by NegociateWindow::run().}\par
}
{\xe \v createTrackSegment\:Kite::NegociateWindow}
{\xe \v Kite::NegociateWindow\:createTrackSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * createTrackSegment ({\b AutoSegment} *  {\i autoSegment}, unsigned int  {\i flags})}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Build a {\b TrackSegment} from the {\b Katabatic::AutoSegment}. If {\f2 flags}  contains Kite::KtLoadingStage then assume that we are in the initial loading stage (constructor). \par
}}
{\xe \v addRoutingEvent\:Kite::NegociateWindow}
{\xe \v Kite::NegociateWindow\:addRoutingEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void addRoutingEvent ({\b TrackElement} *  {\i segment}, unsigned int  {\i level})}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a new {\b RoutingEvent} from {\b TrackElement} (if it doesn't already exists) and insert it into the queue with priority {\f2 level} . \par
}{
Referenced by TrackSegment::reschedule().}\par
}
{\xe \v rescheduleEvent\:Kite::NegociateWindow}
{\xe \v Kite::NegociateWindow\:rescheduleEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void rescheduleEvent ({\b RoutingEvent} *  {\i event}, unsigned int  {\i level}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reschedule an event into the queue, with priority {\f2 level} . \par
}{
Referenced by TrackSegment::reschedule().}\par
}
{\xe \v run\:Kite::NegociateWindow}
{\xe \v Kite::NegociateWindow\:run}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void run (unsigned int  {\i flags})}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform the routing.\par
{\f2 slowMotion}  is not implemented yet. \par
}}
{\xe \v printStatistics\:Kite::NegociateWindow}
{\xe \v Kite::NegociateWindow\:printStatistics}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void printStatistics () const}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Display some statistics about the routing, compute the internal complete statistics. \par
}{
Referenced by NegociateWindow::run().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
NegociateWindow.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
NegociateWindow.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
NegociateWindow.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RoutingEvent Class Reference\par \pard\plain 
{\tc\tcl2 \v RoutingEvent}
{\xe \v RoutingEvent}
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Atomic Placement Request for a {\b TrackSegment}. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Key}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b RoutingEvent} cached key for maps. }\par}}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Mode} \{ {\b Negociate} =1, 
{\b Pack} =2, 
{\b Repair} =3
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RoutingEvent} * {\b clone} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b destroy} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isCloned} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isValid} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isUnimplemented} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isProcessed} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isDisabled} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isForcedToHint} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isRipedByLocal} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getMode} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b canMinimize} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getState} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Key} & {\b getKey} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TrackElement} * {\b getSegment} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const vector< {\b TrackElement} * > & {\b getPerpandiculars} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getAxisHint} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getAxisHistory} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
long {\b getAxisWeight} ({\b DbU::Unit}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Interval} & {\b getConstraints} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Interval} & {\b getOptimal} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getPriority} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getTracksNb} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getInsertState} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getEventLevel} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b revalidate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateKey} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b process} ({\b RoutingEventQueue} &, {\b RoutingEventHistory} &, {\b RoutingEventLoop} &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSegment} ({\b TrackElement} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RoutingEvent} * {\b reschedule} ({\b RoutingEventQueue} &, unsigned int eventLevel)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMode} (unsigned int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setState} (unsigned int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAxisHintFromParent} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b incInsertState} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetInsertState} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEventLevel} (unsigned int)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static unsigned int {\b getStage} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static size_t {\b getAllocateds} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static size_t {\b getProcesseds} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b resetProcesseds} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b setStage} (unsigned int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b RoutingEvent} * {\b create} ({\b TrackElement} *, unsigned int mode={\b Negociate})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Atomic Placement Request for a {\b TrackSegment}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The trackFrees attribute has to be reviewed not sure it's still useful.\par
Cached key for stable sorting, see {\b RoutingEvent::Key}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v Mode\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:Mode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Mode}}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The working mode of the router, affect how events are to be handled. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Negociate\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:Negociate}
{\qr Negociate{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the normal mode of operation, topological modifications and ripup are enableds. \par
}\cell }{\row }
{\xe \v Pack\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:Pack}
{\qr Pack{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First post-processing step. For each segment, tries to find a more compact position for a segment, but without riping any others. \par
}\cell }{\row }
{\xe \v Repair\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:Repair}
{\qr Repair{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Second post-processing step, try to find a suitable location for a segment more aggressively. \par
}\cell }{\row }
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getStage\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:getStage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getStage (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The stage the router is in (see {\b RoutingEvent::Mode}). \par
}{
Referenced by SegmentAction::doAction(), Manipulator::repackPerpandiculars(), RoutingEvent::reschedule(), RoutingEvent::revalidate(), SegmentFsm::SegmentFsm(), and RoutingEvent::setAxisHintFromParent().}\par
}
{\xe \v getAllocateds\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:getAllocateds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getAllocateds (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The number of {\b RoutingEvent} currently allocateds. \par
}}
{\xe \v getProcesseds\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:getProcesseds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getProcesseds (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The number of {\b RoutingEvent} that have been processeds since the last call to {\b RoutingEvent::resetProcesseds()}. \par
}{
Referenced by NegociateWindow::printStatistics(), RoutingEvent::process(), and RoutingEventLoop::update().}\par
}
{\xe \v resetProcesseds\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:resetProcesseds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void resetProcesseds (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  Reset the number of processeds events. \par
}{
Referenced by NegociateWindow::run().}\par
}
{\xe \v setStage\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:setStage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int setStage (unsigned int  {\i mode}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the router's stage (see {\b RoutingEvent::Mode}). \par
}}
{\xe \v create\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingEvent} * create ({\b TrackElement} *  {\i element}, unsigned int  {\i mode} = {\f2 {\b Negociate}}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i element} \cell }{The element for which to create the event. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mode} \cell }{The mode into which this event will be valid.\cell }
{\row }
}
{\b RoutingEvent} constructor. \par
}{
Referenced by RoutingEventQueue::add(), and RoutingEventQueue::load().}\par
}
{\xe \v clone\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:clone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingEvent} * clone () const}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A clone of the event.\par
}Cloning an event is slightly different from copying it (which is forbidden). There can be multiple events for one {\f2 element}  but only one must be active at a time. This is a cheap way of implementing the rescheduling mechanism. The original event remains the active one, but it's cloned flag is raised. The cloned event is created inactive and with a null {\i eventLevel} . \par
}{
Referenced by RoutingEvent::reschedule().}\par
}
{\xe \v destroy\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void destroy ()}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The destructor. \par
}}
{\xe \v isCloned\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:isCloned}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isCloned () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if this event has been cloned at least once. \par
}}
{\xe \v isValid\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:isValid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isValid () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the cached informations from the {\i element}  are valid (i.e. the element has not been changed). \par
}}
{\xe \v isUnimplemented\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:isUnimplemented}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isUnimplemented () const}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the event has tried to use an unimplemented feature. \par
}{
Referenced by Manipulator::canRipup(), and RoutingEvent::reschedule().}\par
}
{\xe \v isProcessed\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:isProcessed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isProcessed () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the event has been processed. \par
}{
Referenced by RoutingEvent::process(), and RoutingEvent::reschedule().}\par
}
{\xe \v isDisabled\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:isDisabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isDisabled () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the event is {\b not}  the active one. It should be discarted by the algorithm. \par
}{
Referenced by RoutingEvent::process().}\par
}
{\xe \v isForcedToHint\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:isForcedToHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isForcedToHint () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  the {\i element}  must be placed exacltly on the given axis hint. \par
}}
{\xe \v isRipedByLocal\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:isRipedByLocal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isRipedByLocal () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  the {\i element}  (global) has been riped up to place a local one. \par
}}
{\xe \v getMode\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:getMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getMode () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  the mode the event must be taken into account to. \par
}}
{\xe \v canMinimize\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:canMinimize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool canMinimize () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  the {\i element}  could still be minimized. \par
}{
Referenced by Manipulator::minimize().}\par
}
{\xe \v getState\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:getState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getState () const}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  the mode the router is currently in. \par
}{
Referenced by RoutingEvent::isUnimplemented().}\par
}
{\xe \v getKey\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:getKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Key} & getKey () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\i key}  to use in map & queue for this event. \par
}}
{\xe \v getSegment\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:getSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * getSegment () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The associated segment. \par
}{
Referenced by SegmentFsm::conflictSolveByHistory(), SegmentFsm::conflictSolveByPlaceds(), SegmentFsm::desaturate(), SegmentFsm::doActions(), SegmentFsm::insertInTrack(), Manipulator::ripupPerpandiculars(), SegmentFsm::SegmentFsm(), SegmentFsm::slackenTopology(), and SegmentFsm::solveFullBlockages().}\par
}
{\xe \v getPerpandiculars\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:getPerpandiculars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const vector< {\b TrackElement} * > & getPerpandiculars () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  A vector of cached perpandiculars to the associated segment. \par
}{
Referenced by Manipulator::minimize(), Manipulator::repackPerpandiculars(), and Manipulator::ripupPerpandiculars().}\par
}
{\xe \v getAxisHint\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:getAxisHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getAxisHint () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The preferred position for the segment axis. \par
}{
Referenced by RoutingEvent::getAxisWeight(), RoutingEvent::revalidate(), Manipulator::ripple(), and SegmentFsm::SegmentFsm().}\par
}
{\xe \v getAxisHistory\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:getAxisHistory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getAxisHistory () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The previous position of the segment axis (before it's current position). \par
}}
{\xe \v getAxisWeight\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:getAxisWeight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getAxisWeight ({\b DbU::Unit}  {\i axis}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The distance between {\f2 axis}  and the preferred position. \par
}{
Referenced by SegmentFsm::SegmentFsm().}\par
}
{\xe \v getConstraints\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:getConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Interval} & getConstraints () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The range of legal positions for the axis. \par
}{
Referenced by Manipulator::minimize(), Manipulator::ripupPerpandiculars(), and SegmentFsm::SegmentFsm().}\par
}
{\xe \v getOptimal\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:getOptimal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Interval} & getOptimal () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The range of positions for the optimal axis (cached). \par
}{
Referenced by SegmentFsm::SegmentFsm().}\par
}
{\xe \v getPriority\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:getPriority}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getPriority () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The priority of the event, it quantify the degree of freedom of the segment. Currently it's computed from the length of the segment and it's slack: \[ priority = (slack(segment)+1.0) \times (length(segment)+1.0) \] A high priority means that the segment will be harder to place thus it will be scheduled first. With this function, longer segments will be placed first. \par
}{
Referenced by RoutingEvent::process().}\par
}
{\xe \v getTracksNb\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:getTracksNb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getTracksNb () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The number of tracks avalaibles for the segment to be placed. \par
}{
Referenced by SegmentFsm::SegmentFsm().}\par
}
{\xe \v getInsertState\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:getInsertState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getInsertState () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The kind of track insertion that will be intended. It's a counter whose values have the following meaning:{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b 1}  : normal insert.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b 2}  : shrink the segment to it's minimum before inserting.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b 3}  : attempt to ripup conflicting others before inserting. \par}
}}{
Referenced by SegmentFsm::insertInTrack().}\par
}
{\xe \v getEventLevel\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:getEventLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getEventLevel () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The event level of the event, used to tweak the order inside the event queue. It differs from the priority in the sense that it isn't a topologicaly based value, but manipulated by the algorithm. \par
}{
Referenced by RoutingEvent::process().}\par
}
{\xe \v revalidate\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:revalidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void revalidate ()}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform an event revalidation. \par
}{
Referenced by SegmentFsm::SegmentFsm(), and RoutingEvent::updateKey().}\par
}
{\xe \v updateKey\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:updateKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateKey (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update the key with the new values from the event, the key {\i must}  not be inserted in the queue when this method is called. \par
}}
{\xe \v process\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:process}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void process ({\b RoutingEventQueue} &  {\i queue}, {\b RoutingEventHistory} &  {\i history}, {\b RoutingEventLoop} &  {\i loop})}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i queue} \cell }{The main event queue. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i history} \cell }{The event's history list. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i loop} \cell }{The loop detector.\cell }
{\row }
}
Process the event, that is:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
First, check if there is no looping, if any, do not process the event but dicard it (marked as unimplemented).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Second, attempt to place the associated segment. Pass it to the relevant function, according to the router's mode ({\f2 _processNegociate()} , {\f2 processPack()}  or {\f2 _processRepair()}  ). Once processed, the event is added to both {\f2 history}  (for the record) and {\f2 loop}  to check if we are not looping. \par}
}}
{\xe \v setSegment\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:setSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setSegment ({\b TrackElement} *  {\i element})}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Change the associated {\f2 segment} . Used only by {\b TrackSegment::swapTrack()}. \par
}{
Referenced by TrackSegment::swapTrack().}\par
}
{\xe \v reschedule\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:reschedule}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingEvent} * reschedule ({\b RoutingEventQueue} &  {\i queue}, unsigned int  {\i eventLevel})}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The newly reinserted event. Depending on the cases it could be itself.\par
}Insert or reinsert an event in the scheduler. The {\f2 eventLevel}  parameter only allows to increase the level (if it is less than the current level of the event, it will be ignored).\par
{\b Cloning Management.}  As an event could be cloned, if we try to re-insert a disabled original, we must first lookup the currently cloned active event. This is done through the associated {\f2 segment}  which must always be associated with the active event (if any).\par
{\b Unimplemented Protection.}  If the unimplemented flag is set the reschedule is cancelled ({\f2 NULL}  is returned).\par
{\b Unprocessed Event.}  The event is still in queue, waiting to be processed, then just repush it in the queue with it's new level.\par
{\b Processed Event.}  Clone the already processed one, activate it and push it on the queue.\par
{\b Router's Mode.}  The mode is also updated. \par
}{
Referenced by SegmentAction::doAction(), and RoutingEvent::reschedule().}\par
}
{\xe \v setMode\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:setMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setMode (unsigned int  {\i mode})}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the mode in which the event must be processed (see {\b RoutingEvent::Mode}). \par
}{
Referenced by SegmentAction::doAction(), and RoutingEvent::reschedule().}\par
}
{\xe \v setState\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:setState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setState (unsigned int  {\i state})}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Proxy mutator for {\b DataNegociate::setState()}. \par
}{
Referenced by RoutingEvent::process().}\par
}
{\xe \v setAxisHintFromParent\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:setAxisHintFromParent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setAxisHintFromParent ()}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the axis hint from it's parent segment. The parentage is found through the {\b TrackSegment} parentage. \par
}{
Referenced by RoutingEvent::revalidate().}\par
}
{\xe \v incInsertState\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:incInsertState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void incInsertState (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Increment the insertion state.\par
{\b See also:} \~ {\b RoutingEvent::getInsertState()}. \par
}{
Referenced by SegmentFsm::insertInTrack().}\par
}
{\xe \v resetInsertState\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:resetInsertState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void resetInsertState (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset the insertion state.\par
{\b See also:} \~ {\b RoutingEvent::getInsertState()}. \par
}{
Referenced by SegmentFsm::slackenTopology().}\par
}
{\xe \v setEventLevel\:Kite::RoutingEvent}
{\xe \v Kite::RoutingEvent\:setEventLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setEventLevel (unsigned int  {\i level}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the event level (user-controlled re-ordering). \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
RoutingEvent.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
RoutingEvent.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
RoutingEvent.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RoutingEventHistory Class Reference\par \pard\plain 
{\tc\tcl2 \v RoutingEventHistory}
{\xe \v RoutingEventHistory}
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
History of {\b RoutingEvent}. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RoutingEventHistory} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~RoutingEventHistory} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b empty} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RoutingEvent} * {\b getNth} (size_t) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RoutingEvent} * {\b getRNth} (size_t) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push} ({\b RoutingEvent} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
History of {\b RoutingEvent}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An history of all the routing events. We can afford to keep an history because while one event is a relatively big object, there is not that much of them (their number is roughly proportional to the number of TrackSegments).\par
One event is likely to appear more than one time in the history, in fact it will apprears each time it is ripped up.\par
Lastly, it is a way to keep track of all the allocated RoutingEvents. When history is deleted it will deleted all the events that it knows of. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v RoutingEventHistory\:Kite::RoutingEventHistory}
{\xe \v Kite::RoutingEventHistory\:RoutingEventHistory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingEventHistory} ()}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct an empty {\b RoutingEventHistory}. \par
}}
{\xe \v ~RoutingEventHistory\:Kite::RoutingEventHistory}
{\xe \v Kite::RoutingEventHistory\:~RoutingEventHistory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
~{\b RoutingEventHistory} ()}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Delete a {\b RoutingEventHistory}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: The deletion of this object triggers the deletion of\par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid all the {\b RoutingEvent} that are referenced in it. \par
}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v empty\:Kite::RoutingEventHistory}
{\xe \v Kite::RoutingEventHistory\:empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool empty () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the history is empty. \par
}}
{\xe \v size\:Kite::RoutingEventHistory}
{\xe \v Kite::RoutingEventHistory\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  the number of events in the history. \par
}{
Referenced by RoutingEventHistory::getNth(), and RoutingEventHistory::getRNth().}\par
}
{\xe \v getNth\:Kite::RoutingEventHistory}
{\xe \v Kite::RoutingEventHistory\:getNth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingEvent} * getNth (size_t  {\i pos}) const}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The event at index {\f2 pos}  from the beginning of the history ({\f2 NULL}  if {\f2 pos}  exeed the size). \par
}}
{\xe \v getRNth\:Kite::RoutingEventHistory}
{\xe \v Kite::RoutingEventHistory\:getRNth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingEvent} * getRNth (size_t  {\i pos}) const}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The event at index {\f2 pos}  from the end of the history ({\f2 NULL}  if {\f2 pos}  exeed the size). \par
}{
Referenced by SegmentFsm::conflictSolveByHistory().}\par
}
{\xe \v push\:Kite::RoutingEventHistory}
{\xe \v Kite::RoutingEventHistory\:push}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void push ({\b RoutingEvent} *  {\i event})}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Push a new {\b RoutingEvent} in the history. \par
}{
Referenced by RoutingEvent::process().}\par
}
{\xe \v clear\:Kite::RoutingEventHistory}
{\xe \v Kite::RoutingEventHistory\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void clear ()}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear the history, also remove the {\b RoutingEvent} that are pointed to. \par
}{
Referenced by RoutingEventHistory::~RoutingEventHistory().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
RoutingEventHistory.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
RoutingEventHistory.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
RoutingEventHistory.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RoutingEventLoop Class Reference\par \pard\plain 
{\tc\tcl2 \v RoutingEventLoop}
{\xe \v RoutingEventLoop}
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simple loop dectector for {\b RoutingEvent}. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RoutingEventLoop} (size_t depth=10, int limit=20)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isLooping} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getMaxCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::vector< Element > & {\b getElements} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} (size_t id)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b erase} (size_t id)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simple loop dectector for {\b RoutingEvent}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b RoutingEventLoop} can be roughly understood as a truncated histogram of the {\f2 depth}  last (in the time meaning) greatest riped up elements.\par
The loop detector keep track of the {\f2 depth}  {\b TrackElement} with the greatest processing count. {\b TrackElement} are just identified through the {\f2 id}  of their associated AutoSegment. Each entry in the loop table contains:{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The {\f2 id}  of the associated {\b TrackSegment} ({\b Katabatic::AutoSegment}).\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The {\f2 count}  of times it has been processed\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The {\f2 timestamp}  of the latest time it has been updated.\par}
The table (implemented as {\f2 vector<>} ) it kept sorted on the timestamp (decreasing). Whenever there is more than {\f2 depth}  elements in the table, the oldest one are discarted (regardless of their count). Obviously, there are pathological cases into which a loop cannot be detected, but so far it has not happened so a more robust approach seems not necessary at this time.\par
Whenever the count of an element reaches {\f2 countLimit} , the looping flag is set. It will remains set unless the faulty element is manually removed. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v RoutingEventLoop\:Kite::RoutingEventLoop}
{\xe \v Kite::RoutingEventLoop\:RoutingEventLoop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingEventLoop} (size_t  {\i depth} = {\f2 10}, int  {\i countLimit} = {\f2 20})}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a loop detector that handle {\f2 depth}  differents segments and has a looping threshold of {\f2 countLimit} . \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v isLooping\:Kite::RoutingEventLoop}
{\xe \v Kite::RoutingEventLoop\:isLooping}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isLooping () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the loop threshold has been reached for at least one element. \par
}{
Referenced by RoutingEvent::process().}\par
}
{\xe \v getMaxCount\:Kite::RoutingEventLoop}
{\xe \v Kite::RoutingEventLoop\:getMaxCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int getMaxCount () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The maximal count an element as reached so far. \par
}{
Referenced by RoutingEvent::process().}\par
}
{\xe \v getElements\:Kite::RoutingEventLoop}
{\xe \v Kite::RoutingEventLoop\:getElements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::vector< Element > & getElements () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The complete table elements. \par
}{
Referenced by RoutingEvent::process().}\par
}
{\xe \v update\:Kite::RoutingEventLoop}
{\xe \v Kite::RoutingEventLoop\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void update (size_t  {\i id})}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update the loop, telling that element {\f2 id}  has appreared one more time. \par
}{
Referenced by RoutingEvent::process().}\par
}
{\xe \v erase\:Kite::RoutingEventLoop}
{\xe \v Kite::RoutingEventLoop\:erase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void erase (size_t  {\i id})}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove the entry related to element {\f2 id}  in the table. The state of the table is fully recomputed after the removal (looping flag & maximum count).\par
This method is used when a loop has been encountered, presumably on element {\f2 id} , and we want to continue. To avoid the loop detector yelling at each check, the associated {\b TrackElement} should be invalidated and it's reference removed from the table. \par
}{
Referenced by RoutingEvent::process().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
RoutingEventLoop.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
RoutingEventLoop.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
RoutingEventLoop.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RoutingEventQueue Class Reference\par \pard\plain 
{\tc\tcl2 \v RoutingEventQueue}
{\xe \v RoutingEventQueue}
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The priority Queue of {\b RoutingEvent}. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RoutingEventQueue} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~RoutingEventQueue} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b empty} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getTopEventLevel} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RoutingEvent} * {\b pop} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b load} (const vector< {\b TrackElement} *> &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add} ({\b TrackElement} *, unsigned int level)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push} ({\b RoutingEvent} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b repush} ({\b RoutingEvent} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b repushInvalidateds} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b commit} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The priority Queue of {\b RoutingEvent}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Implementation Details
\par}
{\tc\tcl2 \v Implementation Details}
The {\b RoutingEventQueue} is build upon a STL multiset<> and is sorted according to the {\b RoutingEvent::Key} attribute of the event. The key attribute has been designed specifically to be used with this queue. It provides the features:{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Sort the {\b RoutingEvent} according to their priority. Higher priority mainly means more constrained segment, which must be routed first.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The attributes of {\b RoutingEvent} may change while inserted in the queue. The key provide a cached value of those attributes ensuring a stable sorting order.\par}
For more details about the sorting order, refer to {\b RoutingEvent::Key}.\par
{\b Insertion, Reinsertion & Commit} \par
When pushing a new event into the queue, the actual insertion into the multimap is delayed until the next call to {\f2 RoutingEvent::commit()} . The to be inserted events are stored into a request set which is processed when commit is called. At commit time, the {\b RoutingEvent::Key} cache is updated just before inserting the element.\par
When repushing an event, the event is immediatly withdrawn from the queue and put into the request set.\par
{\b Mutiple Event for one Segment} \par
As {\b RoutingEvent} can be cloned, there may be more than one event pointing to a segment. But there must be {\i only one active event} , the one which is pointed to by the segment. As a result, there maybe multiple events for an unique segment in the queue, but {\i only one active event} , the one that will be processed. \par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v RoutingEventQueue\:Kite::RoutingEventQueue}
{\xe \v Kite::RoutingEventQueue\:RoutingEventQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingEventQueue} ()}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contructor, create an empty queue. \par
}}
{\xe \v ~RoutingEventQueue\:Kite::RoutingEventQueue}
{\xe \v Kite::RoutingEventQueue\:~RoutingEventQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
~{\b RoutingEventQueue} ()}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: The destruction of the queue do not delete the\par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b RoutingEvent} that may still be in it (they shouldn't an a warning is issued). \par
}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v empty\:Kite::RoutingEventQueue}
{\xe \v Kite::RoutingEventQueue\:empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool empty () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if there is the queue is empty. \par
}}
{\xe \v size\:Kite::RoutingEventQueue}
{\xe \v Kite::RoutingEventQueue\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The number of events in the queue. \par
}}
{\xe \v getTopEventLevel\:Kite::RoutingEventQueue}
{\xe \v Kite::RoutingEventQueue\:getTopEventLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getTopEventLevel () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The greatest event level the queue has ever reached (always increasing, starting from zero). \par
}}
{\xe \v pop\:Kite::RoutingEventQueue}
{\xe \v Kite::RoutingEventQueue\:pop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingEvent} * pop ()}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove the top element of the queue (i.e. the one with the highest priority) and return it. If the queue is empty, {\f2 NULL}  is returned. \par
}}
{\xe \v load\:Kite::RoutingEventQueue}
{\xe \v Kite::RoutingEventQueue\:load}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void load (const vector< {\b TrackElement} *> &  {\i segments})}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Load a whole vector of {\b TrackElement} into the queue, for each element:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Create a {\b RoutingEvent} linked to the element. To be reviewed: replace any previous event.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Insert the new {\b RoutingEvent} into the queue.\par}
{\i No commit is needed after this operation.}  \par
}}
{\xe \v add\:Kite::RoutingEventQueue}
{\xe \v Kite::RoutingEventQueue\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void add ({\b TrackElement} *  {\i element}, unsigned int  {\i level})}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a new {\b RoutingEvent} in the queue with {\f2 level} , associated to {\f2 element} . A commit is needed afterwards.\par
To be reviewed: replace any previous event on element. \par
}{
Referenced by NegociateWindow::addRoutingEvent().}\par
}
{\xe \v push\:Kite::RoutingEventQueue}
{\xe \v Kite::RoutingEventQueue\:push}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void push ({\b RoutingEvent} *  {\i event}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Push a {\b RoutingEvent} in the queue. Effective only after the next commit. \par
}{
Referenced by RoutingEventQueue::add(), and RoutingEventQueue::repush().}\par
}
{\xe \v repush\:Kite::RoutingEventQueue}
{\xe \v Kite::RoutingEventQueue\:repush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void repush ({\b RoutingEvent} *  {\i event})}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Force a complete queue re-insertion for {\f2 event} . The event is immediatly withdrawn from the queue and put into the insertion request set.\par
If the {\f2 event}  is not already in the queue, works like {\b RoutingEventQueue::push()}. \par
}{
Referenced by RoutingEventQueue::repushInvalidateds(), and RoutingEvent::reschedule().}\par
}
{\xe \v repushInvalidateds\:Kite::RoutingEventQueue}
{\xe \v Kite::RoutingEventQueue\:repushInvalidateds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void repushInvalidateds ()}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Using the list of invalidated segments from the {\b Session}, repush them if:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
They have an associated event.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The event is not {\i unimplemented} , {\i disabled}  or {\i processed} . \par}
}{
Referenced by RoutingEvent::process().}\par
}
{\xe \v commit\:Kite::RoutingEventQueue}
{\xe \v Kite::RoutingEventQueue\:commit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void commit ()}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the insertion request set and actually insert it's elements into the queue. Perform a RoutingEvent::key update prior to insertion. \par
}{
Referenced by RoutingEvent::process().}\par
}
{\xe \v clear\:Kite::RoutingEventQueue}
{\xe \v Kite::RoutingEventQueue\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void clear ()}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Empty the queue. Issue a warning if the queue is not empty (i.e. some events remains to be processeds). \par
}{
Referenced by RoutingEventQueue::~RoutingEventQueue().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
RoutingEventQueue.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
RoutingEventQueue.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
RoutingEventQueue.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RoutingPlane Class Reference\par \pard\plain 
{\tc\tcl2 \v RoutingPlane}
{\xe \v RoutingPlane}
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Array of Tracks in one Layer. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isHorizontal} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isVertical} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b KiteEngine} * {\b getKiteEngine} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RoutingLayerGauge} * {\b getLayerGauge} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getDirection} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getDepth} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getAxisMin} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getAxisMax} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getTrackMin} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getTrackMax} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RoutingPlane} * {\b getTop} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RoutingPlane} * {\b getBottom} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Layer} * {\b getLayer} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Layer} * {\b getBlockageLayer} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getTracksSize} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b computeTracksSize} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getTrackPosition} (size_t index) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Track} * {\b getTrackByIndex} (size_t index) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Track} * {\b getTrackByPosition} ({\b DbU::Unit} axis, unsigned int mode={\b KtNearest}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _check} (unsigned int &overlaps) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b RoutingPlane} * {\b create} ({\b KiteEngine} *, size_t depth)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Array of Tracks in one Layer. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A {\b RoutingPlane} is an array of {\b Track} covering a rectangular area. For now the area is the abutment box of the to be routed Cell. Tracks are spaced evenly and according to the configuration of the relevant RoutingLayerGauge.\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v create\:Kite::RoutingPlane}
{\xe \v Kite::RoutingPlane\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingPlane} * create ({\b KiteEngine} *  {\i engine}, size_t  {\i depth}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i engine} \cell }{The associated engine. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i depth} \cell }{The Layer depth of the plane. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The newly created {\b RoutingPlane}.\par
}The {\b RoutingPlane} public constructor. The {\f2 depth}  is in the sense of the RoutingGauge. \par
}}
{\xe \v isHorizontal\:Kite::RoutingPlane}
{\xe \v Kite::RoutingPlane\:isHorizontal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isHorizontal () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the preferred routing direction is horizontal (the actual direction of the tracks). \par
}}
{\xe \v isVertical\:Kite::RoutingPlane}
{\xe \v Kite::RoutingPlane\:isVertical}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isVertical () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the preferred routing direction is vertical (the actual direction of the tracks). \par
}}
{\xe \v getKiteEngine\:Kite::RoutingPlane}
{\xe \v Kite::RoutingPlane\:getKiteEngine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b KiteEngine} * getKiteEngine () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The associated {\b KiteEngine}. \par
}{
Referenced by Track::getKiteEngine().}\par
}
{\xe \v getLayerGauge\:Kite::RoutingPlane}
{\xe \v Kite::RoutingPlane\:getLayerGauge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingLayerGauge} * getLayerGauge () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The RoutingLayerGauge of the plane. \par
}{
Referenced by RoutingPlane::getBlockageLayer(), and RoutingPlane::getLayer().}\par
}
{\xe \v getDirection\:Kite::RoutingPlane}
{\xe \v Kite::RoutingPlane\:getDirection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getDirection () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The preferred routing direction (Katabatic::KbHorizontal or Katabatic::KbVertical). \par
}{
Referenced by RoutingPlane::create(), RoutingPlane::isHorizontal(), and RoutingPlane::isVertical().}\par
}
{\xe \v getDepth\:Kite::RoutingPlane}
{\xe \v Kite::RoutingPlane\:getDepth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getDepth () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The depth of the associated layer (as defined by the RoutingLayerGauge). \par
}{
Referenced by Track::getDepth().}\par
}
{\xe \v getAxisMin\:Kite::RoutingPlane}
{\xe \v Kite::RoutingPlane\:getAxisMin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getAxisMin () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The axis coordinate of the first/lowest track. \par
}}
{\xe \v getAxisMax\:Kite::RoutingPlane}
{\xe \v Kite::RoutingPlane\:getAxisMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getAxisMax () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The axis coordinate of the last/highest track. \par
}}
{\xe \v getTrackMin\:Kite::RoutingPlane}
{\xe \v Kite::RoutingPlane\:getTrackMin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getTrackMin () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The minimum bound of all track. \par
}}
{\xe \v getTrackMax\:Kite::RoutingPlane}
{\xe \v Kite::RoutingPlane\:getTrackMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getTrackMax () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The maximum bound of all track. \par
}}
{\xe \v getTop\:Kite::RoutingPlane}
{\xe \v Kite::RoutingPlane\:getTop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingPlane} * getTop () const}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b RoutingPlane} immediatly above this one. \par
}}
{\xe \v getBottom\:Kite::RoutingPlane}
{\xe \v Kite::RoutingPlane\:getBottom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingPlane} * getBottom () const}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b RoutingPlane} immediatly below this one. \par
}}
{\xe \v getLayer\:Kite::RoutingPlane}
{\xe \v Kite::RoutingPlane\:getLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Layer} * getLayer () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The associated routing layer. \par
}{
Referenced by Track::getLayer().}\par
}
{\xe \v getBlockageLayer\:Kite::RoutingPlane}
{\xe \v Kite::RoutingPlane\:getBlockageLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Layer} * getBlockageLayer () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The blockage layer associated to the routing layer. \par
}{
Referenced by Track::getBlockageLayer().}\par
}
{\xe \v getTracksSize\:Kite::RoutingPlane}
{\xe \v Kite::RoutingPlane\:getTracksSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getTracksSize () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The number of tracks in the array. \par
}}
{\xe \v computeTracksSize\:Kite::RoutingPlane}
{\xe \v Kite::RoutingPlane\:computeTracksSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t computeTracksSize () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The number of tracks {\i to create}  in the array.\par
Helper method that compute the number of tracks in the array from the area of the Cell to be routed and the RoutingLayerGauge characteristics (the Cell is accessible through the {\b KiteEngine}). \par
}{
Referenced by RoutingPlane::create().}\par
}
{\xe \v getTrackPosition\:Kite::RoutingPlane}
{\xe \v Kite::RoutingPlane\:getTrackPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getTrackPosition (size_t  {\i index}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The axis of the track at {\f2 index}  in the array. \par
}}
{\xe \v getTrackByIndex\:Kite::RoutingPlane}
{\xe \v Kite::RoutingPlane\:getTrackByIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Track} * getTrackByIndex (size_t  {\i index}) const}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The track at {\f2 index}  in the array. \par
}{
Referenced by Track::getNextTrack(), and Track::getPreviousTrack().}\par
}
{\xe \v getTrackByPosition\:Kite::RoutingPlane}
{\xe \v Kite::RoutingPlane\:getTrackByPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Track} * getTrackByPosition ({\b DbU::Unit}  {\i axis}, unsigned int  {\i mode} = {\f2 {\b KtNearest}}) const}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The track which position is nearest from {\f2 axis} . The meaning of {\i nearest}  is defined by {\f2 mode}  (classic rouding options). \par
}{
Referenced by SegmentFsm::conflictSolveByPlaceds(), NegociateWindow::createTrackSegment(), RoutingEvent::revalidate(), Manipulator::ripupPerpandiculars(), and SegmentFsm::SegmentFsm().}\par
}
{\xe \v _check\:Kite::RoutingPlane}
{\xe \v Kite::RoutingPlane\:_check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool _check (unsigned int &  {\i overlaps}) const}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if no errors have been found (i.e. the database is coherent).\par
Perform a coherency check on all tracks part of the array. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
RoutingPlane.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
RoutingPlane.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
RoutingPlane.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegmentAction Class Reference\par \pard\plain 
{\tc\tcl2 \v SegmentAction}
{\xe \v SegmentAction}
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Store request for an event to be generated on a {\b TrackElement}. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Type} \{ {\b Self} = (1<< 0), 
{\b Other} = (1<< 1), 
{\b Perpandicular} = (1<< 2), 
{\b Insert} = (1<< 3), 
{\b Ripup} = (1<< 4), 
{\b RipedByLocal} = (1<< 5), 
{\b ResetRipup} = (1<< 6), 
{\b ToRipupLimit} = (1<< 7)
, {\b AxisHint} = (1<< 9), 
{\b PackingMode} = (1<<10), 
{\b ToState} = (1<<11), 
{\b EventLevel1} = (1<<12), 
{\b EventLevel2} = (1<<13), 
{\b EventLevel3} = (1<<14), 
{\b EventLevel4} = (1<<15), 
{\b EventLevel5} = (1<<16), 
{\b SelfInsert} = Self |Insert, 
{\b SelfRipup} = Self |Ripup, 
{\b SelfRipupPerpand} = Self |Ripup|Perpandicular, 
{\b SelfRipupPerpandWithAxisHint} = Self |Ripup|Perpandicular|EventLevel4|AxisHint, 
{\b OtherRipup} = Other|Ripup, 
{\b OtherRipupPerpandAndPushAside} = Other|Ripup|Perpandicular|EventLevel3|AxisHint, 
{\b OtherRipupPerpandAndPacking} = Other|Ripup|Perpandicular|EventLevel4|PackingMode
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SegmentAction} ({\b TrackElement} *, unsigned int type, {\b DbU::Unit} axisHint=0, unsigned int toState=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TrackElement} * {\b getSegment} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getType} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAxisHint} ({\b DbU::Unit})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b setFlag} (unsigned int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b doAction} ({\b RoutingEventQueue} &)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Store request for an event to be generated on a {\b TrackElement}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When an event on a {\b Kite::TrackElement} is being processed (with the {\b SegmentFsm} helper), it may generate events on {\b TrackElement} already placed and belonging either to the same net or other ones. Those events are not generated and queued immediatly but instead {\b SegmentAction}, requesting the event generation are created and stored into a simple vector in {\b SegmentFsm}. The last operation of the {\b SegmentFsm} object is to call the {\b SegmentAction::doAction()} method on all the action to actually generate and queue the events. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v Type\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Type}}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Indicates the kind of action to be performed on the segment. In the following {\b flags}  and {\b masks}  descriptions, we uses the term {\i reference segment}  for the {\b TrackElement} which is associated with the currently processed {\b RoutingEvent} (also referenced in {\b SegmentFsm}).\par
Here is the list of the availables actions that can be performed when (re)scheduling a {\b RoutingEvent}. It is here that we uses the {\b RoutingEvent} level feature to perform a local reordering of the top of the queue. Reordering is used to allows perpandiculars to be routed {\i before}  the reference segment (instead of after) or {\i other}  segments in conflict.\par
{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b SegmentAction::SelfInsert}\par
 {\b Action:}  The reference segment is to be inserted in a {\b Track} (placed).\par
 {\b Event Level:}  Unchanged.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b SegmentAction::SelfRipup}\par
 {\b Action:}  The reference segment is to be ripped up.\par
 {\b Event Level:}  Unchanged.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b SegmentAction::SelfRipupPerpand}\par
 {\b Action:}  Ripup a segment which is a perpandicular to the reference segment. Ordering considerations: this perpandicular will be put back into the {\b RoutingEvent} queue with a lower level (priority) than the reference segment, so it will be processed again {\i after}  the reference segment.\par
 {\b Event Level:}  Unchanged.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b SegmentAction::SelfRipupPerpandWithAxisHint}\par
 {\b Action:}  Ripup a segment which is a perpandicular to the reference segment, supplies an axis hint and put it back into the {\b RoutingEvent} queue so that it will be processed {\i before}  the reference segment.\par
 {\b Event Level:}  Increased to {\b SegmentAction::EventLevel4}.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b SegmentAction::OtherRipup}\par
 {\b Action:}  Ripping up a segment from another net and in the same direction as the reference segment.\par
 {\b Event Level:}  Unchanged.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b SegmentAction::OtherRipupPerpandAndPushAside}\par
 {\b Action:}  Ripping up a segment from another net and in perpandicular direction. The level is elevated so it's priority is greater than the reference segment this it will be reprocessed first. An axis hint is also supplied in order to make room for the reference segment.\par
 {\b Event Level:}  Increased to {\b SegmentAction::EventLevel3}.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b SegmentAction::OtherRipupPerpandAndPacking}\par
 {\b Action:}  Ripping up a segment from another net and in perpandicular direction. The level is elevated so it's priority is greater than the reference segment this it will be reprocessed first. The generated event is in packing mode only.\par
 {\b Event Level:}  Increased to {\b SegmentAction::EventLevel4}. \par}
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Self\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:Self}
{\qr Self{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]}  The segment associated to the action is the reference segment {\i or segments from the same net} . \par
}\cell }{\row }
{\xe \v Other\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:Other}
{\qr Other{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]}  The segment associated to the action is {\b not}  from the same net as the reference segment. \par
}\cell }{\row }
{\xe \v Perpandicular\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:Perpandicular}
{\qr Perpandicular{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]}  The action concern a perpandicular to the reference segment. \par
}\cell }{\row }
{\xe \v Insert\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:Insert}
{\qr Insert{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]}  Request that the segment is to be inserted in the given track. It is the task of {\b SegmentFsm} to determine that there is sufficent space to do so. \par
}\cell }{\row }
{\xe \v Ripup\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:Ripup}
{\qr Ripup{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]}  Request that the segment is to be ripped up. \par
}\cell }{\row }
{\xe \v RipedByLocal\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:RipedByLocal}
{\qr RipedByLocal{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]}  Indicate that the segment has been ripped up by a local one. \par
}\cell }{\row }
{\xe \v ResetRipup\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:ResetRipup}
{\qr ResetRipup{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]}  The ripup count is to be reset. \par
}\cell }{\row }
{\xe \v ToRipupLimit\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:ToRipupLimit}
{\qr ToRipupLimit{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]}  The ripup count is directly increased to the ripup limit, triggering a state change the next time the segment will be processed. \par
}\cell }{\row }
{\xe \v AxisHint\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:AxisHint}
{\qr AxisHint{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]}  An axis hint has been supplied, and is to be passed to the generated {\b RoutingEvent}. \par
}\cell }{\row }
{\xe \v PackingMode\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:PackingMode}
{\qr PackingMode{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]}  Whether the {\b RoutingEvent} should be processed in {\i packing}  mode or {\i negociated}  mode (transmitted to the {\b RoutingEvent}). \par
}\cell }{\row }
{\xe \v ToState\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:ToState}
{\qr ToState{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]}  Force the change of state of the {\b RoutingEvent} (i.e. {\b DataNegociate}). Normally the state change is done through the increase of the ripup count in {\b DataNegociate}. \par
}\cell }{\row }
{\xe \v EventLevel1\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:EventLevel1}
{\qr EventLevel1{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]}  Increase the level to {\i at least}  {\b 1} . \par
}\cell }{\row }
{\xe \v EventLevel2\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:EventLevel2}
{\qr EventLevel2{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]}  Increase the level to {\i at least}  {\b 2} . \par
}\cell }{\row }
{\xe \v EventLevel3\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:EventLevel3}
{\qr EventLevel3{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]}  Increase the level to {\i at least}  {\b 3} . \par
}\cell }{\row }
{\xe \v EventLevel4\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:EventLevel4}
{\qr EventLevel4{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]}  Increase the level to {\i at least}  {\b 4} . \par
}\cell }{\row }
{\xe \v EventLevel5\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:EventLevel5}
{\qr EventLevel5{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]}  Increase the level to {\i at least}  {\b 5} . \par
}\cell }{\row }
{\xe \v SelfInsert\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:SelfInsert}
{\qr SelfInsert{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Mask]} , see {\b SegmentAction::Type}. \par
}\cell }{\row }
{\xe \v SelfRipup\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:SelfRipup}
{\qr SelfRipup{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Mask]} , see {\b SegmentAction::Type}. \par
}\cell }{\row }
{\xe \v SelfRipupPerpand\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:SelfRipupPerpand}
{\qr SelfRipupPerpand{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Mask]} , see {\b SegmentAction::Type}. \par
}\cell }{\row }
{\xe \v SelfRipupPerpandWithAxisHint\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:SelfRipupPerpandWithAxisHint}
{\qr SelfRipupPerpandWithAxisHint{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Mask]} , see {\b SegmentAction::Type}. \par
}\cell }{\row }
{\xe \v OtherRipup\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:OtherRipup}
{\qr OtherRipup{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Mask]} , see {\b SegmentAction::Type}. \par
}\cell }{\row }
{\xe \v OtherRipupPerpandAndPushAside\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:OtherRipupPerpandAndPushAside}
{\qr OtherRipupPerpandAndPushAside{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Mask]} , see {\b SegmentAction::Type}. \par
}\cell }{\row }
{\xe \v OtherRipupPerpandAndPacking\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:OtherRipupPerpandAndPacking}
{\qr OtherRipupPerpandAndPacking{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Mask]} , see {\b SegmentAction::Type}. \par
}\cell }{\row }
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SegmentAction\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:SegmentAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SegmentAction} ({\b TrackElement} *  {\i segment}, unsigned int  {\i type}, {\b DbU::Unit}  {\i axisHint} = {\f2 0}, unsigned int  {\i toState} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i segment} \cell }{On what the action is to be performed. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type} \cell }{Defines the type of action, see {\b SegmentAction::Type}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i axisHint} \cell }{Specifies a preferred axis. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i toState} \cell }{The {\b DataNegociate::SlackState} into which the segment is to be set.\cell }
{\row }
}
Create segment action. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getSegment\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:getSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * getSegment () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The associated {\f2 segment} . \par
}}
{\xe \v getType\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:getType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SegmentAction::Type} getType () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The action to be performed. \par
}}
{\xe \v setAxisHint\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:setAxisHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setAxisHint ({\b DbU::Unit}  {\i axis}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The axis preferred position to be transmitted to the generated event. The transmition will be effective {\i only}  if the SegmentAction::Type::AxisHint flag is set. \par
}}
{\xe \v setFlag\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:setFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int setFlag (unsigned int  {\i flags}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allow to change the action type by indivually setting up the flags. \par
}}
{\xe \v doAction\:Kite::SegmentAction}
{\xe \v Kite::SegmentAction\:doAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void doAction ({\b RoutingEventQueue} &  {\i queue})}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Actually perform the action. That is, build and queue the appropriate event for the segment. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
SegmentFsm.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
SegmentFsm.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
SegmentFsm.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegmentFsm Class Reference\par \pard\plain 
{\tc\tcl2 \v SegmentFsm}
{\xe \v SegmentFsm}
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pseudo-decorator to process a {\b RoutingEvent}. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b State} \{ {\b MissingData} = (1<<0), 
{\b EmptyTrackList} = (1<<1), 
{\b Inserted} = (1<<2), 
{\b Self} = (1<<3), 
{\b Other} = (1<<4), 
{\b Ripup} = (1<<5), 
{\b MaximumSlack} = (1<<6), 
{\b SelfInserted} = Self | Inserted, 
{\b OtherRipup} = Other | Ripup, 
{\b SelfMaximumSlack} = Self | MaximumSlack
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SegmentFsm} ({\b RoutingEvent} *, {\b RoutingEventQueue} &, {\b RoutingEventHistory} &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isFullBlocked} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RoutingEvent} * {\b getEvent} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RoutingEventQueue} & {\b getQueue} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RoutingEventHistory} & {\b getHistory} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getState} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DataNegociate} * {\b getData} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Interval} & {\b getConstraint} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Interval} & {\b getOptimal} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< TrackCost > & {\b getCosts} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TrackCost & {\b getCost} (size_t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Track} * {\b getTrack} (size_t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getBegin} (size_t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getEnd} (size_t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< {\b SegmentAction} > & {\b getActions} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setState} (unsigned int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addAction} ({\b TrackElement} *, unsigned int type, {\b DbU::Unit} axisHint=0, unsigned int toState=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b doActions} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clearActions} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b insertInTrack} (size_t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b conflictSolveByHistory} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b conflictSolveByPlaceds} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b desaturate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b slackenTopology} (unsigned int flags=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b solveFullBlockages} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pseudo-decorator to process a {\b RoutingEvent}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b SegmentFsm} class actually perform the placement of the {\b Kite::TrackElement} of the {\b Kite::RoutingEvent}. It structured around three goals:{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Implement the finite state machine for the {\b Kite::DataNegociate} state.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Provide a kind of decoration on the RoutingEvent/TrackElement (it do not abide by the definition from Design Patterns).\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Cache a lot of on-the-fly computed datas needed during the {\b SegmentFsm} lifetime and the Manipulator(s) it may uses.\par}
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Update Mechanism
\par}
{\tc\tcl2 \v Update Mechanism}
The constructor of {\b SegmentFsm} triggers the update of the {\b RoutingEvent} and through it {\b DataNegociate}.\par}
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Slackening / FSM Transitions
\par}
{\tc\tcl2 \v Slackening / FSM Transitions}
A transition occurs in the FSM whenener all the availables ripup methods for a segment have failed. Failure means that the topology of the net itself must be altered to allow a greater level of flexibility. Modifying the net topology means to give the current segment some more slack.\par
Availables slackening operations:{
\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab {\b DataNegociate::RipupPerpandiculars} ({\b Manipulator}) place the segments before any of it's perpandiculars are placed to allow a maximum track choice.\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
2.\tab {\b DataNegociate::Minimize} ({\b Manipulator}) try to fit the segment in a hole in a track, perform a hole detection.\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
3.\tab {\b DataNegociate::Dogleg} ({\b Manipulator}) create a dogleg matching {\i the first track candidate}  with a non-nul overlap.\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
4.\tab {\b DataNegociate::Slacken} ({\b Manipulator}) to be reviewed.\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
5.\tab {\b DataNegociate::ConflictSolveByHistory} ({\b SegmentFsm}) try to find a break point on the segment, based on the ripup history.\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
6.\tab {\b DataNegociate::ConflictSolveByPlaceds} ({\b SegmentFsm}) try to find a break point on the segment, based on the current position of segments on the candidate tracks.\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
7.\tab {\b DataNegociate::MoveUp} ({\b Manipulator}) try to move up the segment.\par}
Simple slackening operations are defined in {\b Manipulator} and complex ones directly in {\b SegmentFsm}.\par}
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Non-Slackening Operations
\par}
{\tc\tcl2 \v Non-Slackening Operations}
In addition, some operation that do not modifies the topology are availables:{
\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab {\b Manipulator::forceOverLocals()} mostly for global segments to ripup a track from all it's locals.\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
2.\tab {\b SegmentFsm::insertInTrack()} automates the three subsequent ripup trials. \par}
\par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v State\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:State}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b State}}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Indicates what the {\b SegmentFsm} has done the processed {\b TrackElement}, possible values are:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b SegmentFsm::MissingData}, this is an error condition, the {\b TrackElement} do not have associated {\b DataNegociate} structure. Nothing is done.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b SegmentFsm::EmptyTrackList}, no {\b Track} is available for placement (free or used).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b SegmentFsm::SelfInserted}, the {\b TrackElement} can be successfully inserted in a {\b Track} (i.e. without overlap).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b SegmentFsm::SelfMaximumSlack}, nothing can be done to further slacken the {\b TrackElement}, it is at maximum ripup of the last possible state (no more topological modifications are possibles).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b SegmentFsm::OtherRipup}, the {\b TrackElement} can be inserted but it needs the ripup of some others. \par}
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v MissingData\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:MissingData}
{\qr MissingData{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]} , see SegmentFsm::SegmentFsmValue. \par
}\cell }{\row }
{\xe \v EmptyTrackList\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:EmptyTrackList}
{\qr EmptyTrackList{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]} , see SegmentFsm::SegmentFsmValue. \par
}\cell }{\row }
{\xe \v Inserted\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:Inserted}
{\qr Inserted{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]} , the {\b TrackElement} can be inserted in a {\b Track}. \par
}\cell }{\row }
{\xe \v Self\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:Self}
{\qr Self{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]} , the action is related to the processed {\b TrackSegment}. \par
}\cell }{\row }
{\xe \v Other\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:Other}
{\qr Other{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]} , the action is {\b not}  related to the processed {\b TrackSegment}, that is, others are being topologically modificated or riped up. \par
}\cell }{\row }
{\xe \v Ripup\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:Ripup}
{\qr Ripup{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]} , segement, that are not the processed one are being ripped up. \par
}\cell }{\row }
{\xe \v MaximumSlack\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:MaximumSlack}
{\qr MaximumSlack{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Flag]} , the processed segment as reached it's maximum ripup count on the last possible slackening state. \par
}\cell }{\row }
{\xe \v SelfInserted\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:SelfInserted}
{\qr SelfInserted{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Mask]} , see SegmentFsm::SegmentFsmValue. \par
}\cell }{\row }
{\xe \v OtherRipup\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:OtherRipup}
{\qr OtherRipup{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Mask]} , see SegmentFsm::SegmentFsmValue. \par
}\cell }{\row }
{\xe \v SelfMaximumSlack\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:SelfMaximumSlack}
{\qr SelfMaximumSlack{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [Mask]} , see SegmentFsm::SegmentFsmValue. \par
}\cell }{\row }
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SegmentFsm\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:SegmentFsm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SegmentFsm} ({\b RoutingEvent} *  {\i event}, {\b RoutingEventQueue} &  {\i queue}, {\b RoutingEventHistory} &  {\i history})}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i event} \cell }{The {\b RoutingEvent} to be processed. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i queue} \cell }{The {\b RoutingEvent} queue. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i history} \cell }{The complete history of {\b RoutingEvent}.\cell }
{\row }
}
Construct a {\b SegmentFsm} from a {\b RoutingEvent}. The constructor is in charge of computing all the cached values. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v isFullBlocked\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:isFullBlocked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isFullBlocked () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if there are Tracks avalaibles but the constraints are such that none is actually usable. \par
}}
{\xe \v getEvent\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:getEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingEvent} * getEvent () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The currently processed {\b RoutingEvent} ({\i cached} ). \par
}{
Referenced by SegmentFsm::doActions(), SegmentFsm::slackenTopology(), and SegmentFsm::solveFullBlockages().}\par
}
{\xe \v getQueue\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:getQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingEventQueue} & getQueue () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b RoutingEvent} queue ({\i cached} ). \par
}}
{\xe \v getHistory\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:getHistory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingEventHistory} & getHistory () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b RoutingEvent} history ({\i cached} ). \par
}{
Referenced by SegmentFsm::conflictSolveByHistory().}\par
}
{\xe \v getState\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:getState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getState () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The state (SegmentFsm::SegmentFsmValues) which the {\b SegmentFsm} has computed for the {\b RoutingEvent}. This is {\b not}  the state of the {\b DataNegociate} \par
}}
{\xe \v getData\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:getData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DataNegociate} * getData (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b DataNegociate} of the {\b TrackElement} ({\i cached} ). \par
}}
{\xe \v getConstraint\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:getConstraint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} & getConstraint (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The interval into which the segment axis can be set (computed from the topological constraints and the placement constraints on the already placed perpandiculars). \par
}}
{\xe \v getOptimal\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:getOptimal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} & getOptimal (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The interval for an optimal placement of the segment axis. \par
}}
{\xe \v getCosts\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:getCosts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector< TrackCost > & getCosts (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The table of cost for all the candidates Tracks of the segment. The table is sorted in increasing cost order (see TrackCost). \par
}{
Referenced by SegmentFsm::desaturate(), Manipulator::forceOverLocals(), Manipulator::makeDogleg(), and Manipulator::minimize().}\par
}
{\xe \v getCost\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:getCost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TrackCost & getCost (size_t  {\i i}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The cost at index {\f2 i}  in the table. \par
}{
Referenced by SegmentFsm::desaturate(), Manipulator::forceOverLocals(), Manipulator::forceToTrack(), Manipulator::insertInTrack(), Manipulator::minimize(), and SegmentFsm::solveFullBlockages().}\par
}
{\xe \v getTrack\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:getTrack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Track} * getTrack (size_t  {\i i}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b Track} for cost at index {\f2 i}  in the table. \par
}{
Referenced by SegmentFsm::desaturate(), Manipulator::forceOverLocals(), Manipulator::forceToTrack(), Manipulator::insertInTrack(), Manipulator::makeDogleg(), Manipulator::minimize(), and Manipulator::shrinkToTrack().}\par
}
{\xe \v getBegin\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:getBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getBegin (size_t  {\i i}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The overlapping {\i begin}  index in {\b Track} for cost at index {\f2 i}  in the table. \par
}{
Referenced by SegmentFsm::desaturate(), Manipulator::forceOverLocals(), Manipulator::forceToTrack(), Manipulator::insertInTrack(), Manipulator::makeDogleg(), Manipulator::minimize(), and Manipulator::shrinkToTrack().}\par
}
{\xe \v getEnd\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:getEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getEnd (size_t  {\i i}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The overlapping {\i end}  index in {\b Track} for cost at index {\f2 i}  in the table. \par
}{
Referenced by SegmentFsm::desaturate(), Manipulator::forceOverLocals(), Manipulator::forceToTrack(), Manipulator::insertInTrack(), Manipulator::makeDogleg(), Manipulator::minimize(), and Manipulator::shrinkToTrack().}\par
}
{\xe \v getActions\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:getActions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector< {\b SegmentAction} * > & getActions (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The table of {\b SegmentAction}, that is the delayed requests for {\b RoutingEvent} creation. \par
}{
Referenced by Manipulator::shrinkToTrack().}\par
}
{\xe \v setState\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:setState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int setState (unsigned int  {\i state}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  Sets the state of the state... \par
}{
Referenced by SegmentFsm::desaturate(), Manipulator::forceOverLocals(), Manipulator::forceToTrack(), Manipulator::insertInTrack(), and Manipulator::shrinkToTrack().}\par
}
{\xe \v addAction\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:addAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void addAction ({\b TrackElement} *  {\i segment}, unsigned int  {\i type}, {\b DbU::Unit}  {\i axisHint} = {\f2 0}, unsigned int  {\i toState} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Request the creation of a new delayed {\b RoutingEvent}, for the meaning of the parameters, see {\b SegmentAction::SegmentAction}. \par
}{
Referenced by SegmentFsm::desaturate(), Manipulator::forceOverLocals(), Manipulator::forceToTrack(), Manipulator::insertInTrack(), Manipulator::minimize(), Manipulator::relax(), Manipulator::repackPerpandiculars(), Manipulator::ripple(), Manipulator::ripup(), Manipulator::ripupPerpandiculars(), Manipulator::shrinkToTrack(), and SegmentFsm::slackenTopology().}\par
}
{\xe \v doActions\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:doActions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool doActions ()}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Actually generate RoutingEvent(s) from the SegmentAction(s). \par
}}
{\xe \v clearActions\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:clearActions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void clearActions (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear the the table of requested actions, whithout generating them. \par
}{
Referenced by Manipulator::insertInTrack(), and SegmentFsm::slackenTopology().}\par
}
{\xe \v insertInTrack\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:insertInTrack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool insertInTrack (size_t  {\i i})}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Try to insert the {\b TrackElement} in the {\b Track} at index {\f2 i}  (in the cost table). Return {\b true}  if the insertion is possible.\par
The insertion is not done at this stage, but a set of ripup actions is emitted to allow insertion the next time the segment will be processed.\par
Three subsequent trials are done before giving up on inserting the segment:{
\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab {\b Manipulator::insertInTrack()}, try to push asides the neighbors.\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab {\b Manipulator::shrinkToTrack()}, try squeeze the segment in an existing free space.\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
3.\tab {\b Manipulator::forceToTrack()}, perform a complete ripup of all the neighbors and their perpandiculars.\par}
The event keeps track of the insertion attempt step (see {\b RoutingEvent::getInsertState()}). \par
}}
{\xe \v conflictSolveByHistory\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:conflictSolveByHistory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool conflictSolveByHistory ()}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if a suitable dogleg has been created in the segment.\par
Initially, global segments may be very long, and a placement solution in which each one is placed on a track of it's own may not be realisable. In that case, at least one of the global segment must be broken. The figure below illustrate the case: {\b (a)} , {\b (b)} , {\b (c)}  form a first cluster and {\b (d)} , {\b (e)} , {\b (f)}  form a second one. Due to the constraints of the segments the remaining free track cannot be the same in both clusters. The only solution to place {\b (g)}  is to break it into two sub-globals. The whole point of the conflict solve is to correctly detect the cluster and choose the breaking point.\par
 This variant of the conflict solve method try to guess the track span for which there is a conflict by looking at the event history.\par
 {\b Dislodger Definition:} \par
A segment is said to be a dislodger if it matches the two following criterions:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
It's span intersect the to be inserted segment span.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
It has been placed on a track inside the perpandicular span of the to be placed segment.\par}
For the time beeing we limit the search to the last three dislodgers, to not waste too much time looking back the event history. We merge overlapping intervals into one (see the undocumented class {\f2 UnionIntervals}  and {\f2 RipupHistory}  in {\f2 SegmentFsm.cpp} ).\par
For the time beeing we only look on the track into which the to be inserted segment wants to be placed.\par
Then we try to break the to be placed segment, first under the lower bound (source) of the conflicting interval then, in case of failure under the upper bound (target).\par
 \par
}}
{\xe \v conflictSolveByPlaceds\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:conflictSolveByPlaceds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool conflictSolveByPlaceds ()}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if a suitable dogleg has been created in the segment {\i or}  a dislodger has been moved up.\par
This methods achieve the same goal as {\b SegmentFsm::conflictSolveByHistory()} but uses a different strategy.\par
Instead of looking through the history to find dislodgers it analyses the placed segments in all the candidates tracks for the to be placed segment. Unlike it's sibling method, which creates only one dogleg, as it uses the {\b Manipulator::relax()} method, it may creates up to two doglegs.\par
{\b Synthetic Description} \par
{
\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab For each track, find the dislodgers, merge the overlaps into one interval and store the length of the longuest overlap (aka conflict).\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab Sort the tracks according to decreasing longuest overlap/confict.\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
3.\tab For each track in the sorted list, look for a dislodger under the middle of the to be placed segment. If no dislodger is present at this place go to the next track. Otherwise:{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\i The dislodger is local} , then try to relax the to placed segment around the dislodger.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\i The dislodger is global} , try to move it up, if it is not possible, fallback to the relax approach.\par}
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
4.\tab Quit on the first successful move up or relax.\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
5.\tab If there is no candidate tracks, this means the vertical constraints are too tight, in that case, ripup the perpandiculars (fallback plan).\par}
{\b Interval Accounting} \par
Only global conflicting segments are took into account. Local segments may be took into account if they overlap global ones (all part of the same net). All overlapping segments are merged into one big conflict interval. The whole length of a conflict interval is took into account event if it's overlap with the to be placed segment is only partial.\par
{\b {\b Track} Ordering (lexicographic)} \par
{
\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab The longuest (in one interval) conflict length.\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab The longuest cumulative conflict length (all interval summed up).\par}
Interval accounting and {\b Track} ordering is managed through the undocumented {\f2 Cs1Candidate}  class implemented in {\f2 SegmentFsm.cpp} .\par
 \par
}}
{\xe \v desaturate\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:desaturate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool desaturate ()}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Try to create a suitable empty space in a cost {\b Track} by moving up {\b TrackElement} in conflict. \par
}}
{\xe \v slackenTopology\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:slackenTopology}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool slackenTopology (unsigned int  {\i flags} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Modificate the topology of the {\b TrackElement} to slacken it. It is the implementation of the slakening finite state machine. \par
}}
{\xe \v solveFullBlockages\:Kite::SegmentFsm}
{\xe \v Kite::SegmentFsm\:solveFullBlockages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool solveFullBlockages ()}}
\par
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Try to solve a fully blocked configuration. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
SegmentFsm.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
SegmentFsm.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
SegmentFsm.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegmentObserver Class Reference\par \pard\plain 
{\tc\tcl2 \v SegmentObserver}
{\xe \v SegmentObserver}
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Observer on the base AutoSegment. }}\par
Inheritance diagram for SegmentObserver:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKite_1_1SegmentObserver__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b notify} (unsigned int flags)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Observer on the base AutoSegment. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The observer that will be hooked into the observable in the associated canonical AutoSegment. Used to propagate the invalidation/revalidation events from AutoSegment toward {\b TrackSegment}.\par
As a secondary function, it is used by the {\b Session::lookup()} method to quicly retrieve {\b TrackSegment} from {\b Katabatic::AutoSegment}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v notify\:Kite::SegmentObserver}
{\xe \v Kite::SegmentObserver\:notify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void notify (unsigned int  {\i flags}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implement the asymmetric invalidate/revalidate policy described in {\b Kite::Session}. The invalidate is immediatly passed on while the revalidate is ignored. \par
}{
Reimplemented from {\b BaseObserver}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
TrackElement.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
TrackElement.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
TrackElement.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Session Class Reference\par \pard\plain 
{\tc\tcl2 \v Session}
{\xe \v Session}
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Kite} update {\b Session}. }}\par
Inheritance diagram for Session:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKite_1_1Session__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Session} * {\b open} ({\b KiteEngine} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Session} * {\b get} (const char *message=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Katabatic::Session} * {\b base} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b isEmpty} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b KiteEngine} * {\b getKiteEngine} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static Configuration * {\b getConfiguration} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Net} * {\b getBlockageNet} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b NegociateWindow} * {\b getNegociateWindow} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Katabatic::GCell} * {\b getGCellUnder} ({\b DbU::Unit}, {\b DbU::Unit})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b addInsertEvent} ({\b TrackElement} *, {\b Track} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b addRemoveEvent} ({\b TrackElement} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b addMoveEvent} ({\b TrackElement} *, {\b Track} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b addSortEvent} ({\b Track} *, bool forced=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static size_t {\b revalidate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b TrackElement} * {\b lookup} ({\b Segment} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b TrackElement} * {\b lookup} ({\b AutoSegment} *)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Kite} update {\b Session}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Session} extend the Katabatic update session to the {\b Kite} router level. Mainly by managing {\b Track} update.\par
{\b Difference between {\b Kite} & Katabatic sessions:} {
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
In Katabatic, segments are actually moved {\i before}  the revalidation, then {\i during}  the revalidation, contacts and topologies are adjusteds\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
In {\b Kite}, nothing is moved until the revalidation. Requests for segment displacement are queued for the session.\par}
{\b Asymmetry between invalidation & revalidation:} {
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
When a {\b TrackSegment} (or directly an AutoSegment) is invalidated both associated AutoSegment and {\b TrackSegment} are invalidated (through the Observer mechanism).\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
When an AutoSegment is revalidated, the {\b TrackSegment} is {\b not}  immediatly revalidated. See the revalidate algorithm for more details.\par}
{\b Indirect {\b TrackSegment} invalidation:} {
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TrackSegment} invalidation do not result only from direct insertion in {\b Track}. For example, any or all of it's perpandicular can be invalidated trough the {\b Katabatic::Session} update (the perpandicular {\b Katabatic::AutoSegment} is revalidated, generating invalidation on their associated {\b TrackSegment}).\par}
For details on how Katabatic Sessions works, have a look to {\b Katabatic::Session}.\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
The Session Mechanism.
\par}
{\tc\tcl2 \v The Session Mechanism.}
Delayed modification procedure :{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Modifications events are recorded (queued) into the {\b Session}. At this step, no modification are actually done, the data-base retains it's previous state and coherency.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The {\f2 {\b revalidate()}}  procedure is called (or the {\b Session} is closed), then all the modification events are applied. The data-base is in now in it's new state.\par}
\par}
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
The Revalidate Algorithm.
\par}
{\tc\tcl2 \v The Revalidate Algorithm.}
Revalidation steps :{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Process all remove events. detach {\b TrackSegment} from their {\b Track}, but do not remove the pointer from the internal {\f2 vector} .\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Pack all {\b Track} in which removal have took place.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Process all insert events. {\b This is the time {\b TrackSegment} are moved into their new {\b Track} (physical displacement)} . It is at this point that the invalidation of both AutoSegment and {\b TrackSegment} is done.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Call the {\b Katabatic::Session::revalidate()} method which will recompute the correct contact extensions and topologies. {\i After}  this step the Katabatic data-base is up to date, but {\i not}  the {\b Kite} one. AutoSegment are revalidated.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Recompute the canonical position of source and target of all invalidateds {\b TrackSegment} (take account of extention modifications). The set of invalidated {\b TrackSegment} is computed from the revalidated AutoSegment, that is AutoSegment that are canonical.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Perform a sort() on all {\b Track} that have been modifieds.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Now that the size of the segments have been accurately computed, look for revalidateds {\b TrackSegment} that:{
\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab Can be reduced, generate a track remove event.\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab Must be raised, generate a routing event (put into the queue).\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Process the additional track remove events.\par}
{\b Note:}  We cannot use the Observer mechanism to automatically update {\b TrackSegment} from an AutoSegment, because we must wait for all AutoSegments (canonical or not) involved into the {\b TrackSegment} to be up to date before we can update it.\par
{\b Note:}  Have to talk about the special case when new canonical AutoSegment appears after dogleg creation.\par}
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
The Lookup Mechanism
\par}
{\tc\tcl2 \v The Lookup Mechanism}
There are two lookup mechanisms:{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
From a {\b Hurricane::Segment}, we uses the Katabatic segment lookup table (slow, stored in a {\f2 map<>} ).\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
From a {\b Katabatic::AutoSegment}, we uses the Observer, it's owner is the {\b TrackSegment} (fast). \par}
\par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v open\:Kite::Session}
{\xe \v Kite::Session\:open}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Session} * open ({\b KiteEngine} *  {\i kite}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i kite} \cell }{A {\b Kite} ToolEngine on which to work. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A new {\b Kite} update {\b Session}.\par
}Open a new {\b Kite} update {\b Session} on the {\f2 kite}  {\f2 ToolEngine} . At this point only one session can be opened at a time. Attempt to open a second one will result in an exception. \par
}}
{\xe \v get\:Kite::Session}
{\xe \v Kite::Session\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Session} * get (const char *  {\i message} = {\f2 NULL}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The currently opened session, {\f2 NULL}  if no session has been opened. \par
}{
Referenced by NegociateWindow::run().}\par
}
{\xe \v base\:Kite::Session}
{\xe \v Kite::Session\:base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Katabatic::Session} * base (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b Session}, casted as it's base object. \par
}}
{\xe \v isEmpty\:Kite::Session}
{\xe \v Kite::Session\:isEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isEmpty (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ensure that the {\b Session} is empty and can be closed (deleted) safely. \par
}{
Referenced by NegociateWindow::run().}\par
}
{\xe \v getKiteEngine\:Kite::Session}
{\xe \v Kite::Session\:getKiteEngine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b KiteEngine} * getKiteEngine (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b Kite} ToolEngine associated to the current update session (proxy helper). \par
}{
Referenced by Manipulator::canRipup(), SegmentFsm::conflictSolveByHistory(), SegmentFsm::conflictSolveByPlaceds(), NegociateWindow::createTrackSegment(), SegmentAction::doAction(), RoutingEvent::process(), RoutingEvent::revalidate(), Manipulator::ripple(), Manipulator::ripupPerpandiculars(), NegociateWindow::run(), SegmentFsm::SegmentFsm(), and NegociateWindow::setGCells().}\par
}
{\xe \v getConfiguration\:Kite::Session}
{\xe \v Kite::Session\:getConfiguration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Configuration * getConfiguration (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b Kite} Configuration of the Router (proxy helper). \par
}}
{\xe \v getBlockageNet\:Kite::Session}
{\xe \v Kite::Session\:getBlockageNet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Net} * getBlockageNet (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The net used to create blockage components (proxy helper). \par
}{
Referenced by TrackFixedSegment::create().}\par
}
{\xe \v getNegociateWindow\:Kite::Session}
{\xe \v Kite::Session\:getNegociateWindow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NegociateWindow} * getNegociateWindow (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The current {\b NegociateWindow} (proxy helper). \par
}{
Referenced by TrackSegment::_postDoglegs(), and TrackSegment::reschedule().}\par
}
{\xe \v getGCellUnder\:Kite::Session}
{\xe \v Kite::Session\:getGCellUnder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Katabatic::GCell} * getGCellUnder ({\b DbU::Unit}  {\i x}, {\b DbU::Unit}  {\i y}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The GCell under {\f2 } (x,y) (proxy helper, see {\b Katabatic::GCellGrid::getGCell()}). \par
}{
Referenced by SegmentFsm::conflictSolveByHistory().}\par
}
{\xe \v addInsertEvent\:Kite::Session}
{\xe \v Kite::Session\:addInsertEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void addInsertEvent ({\b TrackElement} *  {\i segment}, {\b Track} *  {\i track}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i segment} \cell }{An AutoSegment to insert in a {\b Track}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i track} \cell }{The {\b Track} into which the {\i segment}  will be inserted.\cell }
{\row }
}
Schedule the insertion of {\i segment}  into {\b Track} {\i track} . The {\i segment}  must not already be part of a {\b Track}. \par
}}
{\xe \v addRemoveEvent\:Kite::Session}
{\xe \v Kite::Session\:addRemoveEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void addRemoveEvent ({\b TrackElement} *  {\i segment}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i segment} \cell }{A {\b TrackSegment} to remove from a {\b Track}.\cell }
{\row }
}
Schedule the removal of {\i segment}  from {\b Track} {\i track} . \par
}{
Referenced by SegmentAction::doAction(), and TrackSegment::reschedule().}\par
}
{\xe \v addMoveEvent\:Kite::Session}
{\xe \v Kite::Session\:addMoveEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void addMoveEvent ({\b TrackElement} *  {\i segment}, {\b Track} *  {\i track}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i segment} \cell }{An AutoSegment to move into a new {\b Track}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i track} \cell }{The {\b Track} into which the {\i segment}  will be moved.\cell }
{\row }
}
Schedule the displacement of {\i segment}  into {\b Track} {\i track} . \par
}}
{\xe \v addSortEvent\:Kite::Session}
{\xe \v Kite::Session\:addSortEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void addSortEvent ({\b Track} *  {\i track}, bool  {\i forced} = {\f2 false}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i track} \cell }{The {\b Track} to update. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i forced} \cell }{Force the invalidation of the {\f2 {\b Track}} .\cell }
{\row }
}
Schedule the update of {\b Track} {\i track} . If the {\f2 {\b Track}}  has not been invalidated, no actual sort will takes place. To force a sort (manually invalidating the {\f2 {\b Track}} ), sets {\b forced}  to {\b true} .\par
{\b See also:} \~ Track::pack() & Track::sort(). \par
}{
Referenced by TrackSegment::revalidate().}\par
}
{\xe \v revalidate\:Kite::Session}
{\xe \v Kite::Session\:revalidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void revalidate (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies all the requested modifications, but keeping the session opened. \par
}{
Referenced by RoutingEvent::process(), NegociateWindow::run(), and NegociateWindow::setGCells().}\par
}
{\xe \v lookup\:Kite::Session}
{\xe \v Kite::Session\:lookup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * lookup ({\b Segment} *  {\i segment}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  the {\b TrackElement} associated to {\f2 segment} . \par
}{
Referenced by NegociateWindow::computeWirelength(), TrackSegment::create(), TrackSegment::getCanonical(), TrackSegment::getParent(), TrackSegment::getSourceDogleg(), TrackSegment::getTargetDogleg(), Manipulator::relax(), RoutingEventQueue::repushInvalidateds(), and NegociateWindow::setGCells().}\par
}
{\xe \v lookup\:Kite::Session}
{\xe \v Kite::Session\:lookup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * lookup ({\b AutoSegment} *  {\i segment}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  the {\b TrackElement} associated to {\f2 segment} . \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Session.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Session.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Track Class Reference\par \pard\plain 
{\tc\tcl2 \v Track}
{\xe \v Track}
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure managing one routing track. }}\par
Inheritance diagram for Track:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKite_1_1Track__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b IndexState} \{ {\b BeginIsTrackMin} = 0x00000001, 
{\b BeginIsSegmentMin} = 0x00000002, 
{\b BeginIsSegmentMax} = 0x00000004, 
{\b EndIsTrackMax} = 0x00000008, 
{\b EndIsSegmentMin} = 0x00000010, 
{\b EndIsNextSegmentMin} = 0x00000020, 
{\b EndIsSegmentMax} = 0x00000040, 
{\b BeforeFirstElement} = BeginIsTrackMin |EndIsSegmentMin, 
{\b InsideElement} = BeginIsSegmentMin|EndIsSegmentMax, 
{\b OutsideElement} = BeginIsSegmentMax|EndIsNextSegmentMin, 
{\b AfterLastElement} = BeginIsSegmentMax|EndIsTrackMax, 
{\b EmptyTrack} = BeginIsTrackMin |EndIsTrackMax, 
{\b BeginMask} = BeginIsTrackMin |BeginIsSegmentMin|BeginIsSegmentMax, 
{\b EndMask} = EndIsTrackMax |EndIsSegmentMin |EndIsNextSegmentMin|EndIsSegmentMax
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isHorizontal} () const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isVertical} () const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isLocalAssigned} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RoutingPlane} * {\b getRoutingPlane} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b KiteEngine} * {\b getKiteEngine} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b getDirection} () const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getIndex} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getDepth} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Layer} * {\b getLayer} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Layer} * {\b getBlockageLayer} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getAxis} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getMin} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getMax} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Track} * {\b getNextTrack} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Track} * {\b getPreviousTrack} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getSize} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Point} {\b getPosition} ({\b DbU::Unit} coordinate) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TrackElement} * {\b getSegment} (size_t index) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TrackElement} * {\b getSegment} ({\b DbU::Unit} position) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TrackElement} * {\b getNext} (size_t &index, {\b Net} *) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TrackElement} * {\b getPrevious} (size_t &index, {\b Net} *) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TrackElement} * {\b getNextFixed} (size_t &index) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b find} (const {\b TrackElement} *) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getSourcePosition} (vector< {\b TrackElement} *>::iterator) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getMinimalPosition} (size_t index, unsigned int state) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getMaximalPosition} (size_t index, unsigned int state) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Interval} {\b getFreeInterval} ({\b DbU::Unit} position, {\b Net} *net=NULL) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Interval} {\b getOccupiedInterval} (size_t &begin) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Interval} {\b expandFreeInterval} (size_t &begin, size_t &end, unsigned int state, {\b Net} *) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getBeginIndex} ({\b DbU::Unit} position, size_t &begin, unsigned int &state) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getOverlapBounds} ({\b Interval}, size_t &begin, size_t &end) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TrackCost {\b getOverlapCost} ({\b Interval}, {\b Net} *, size_t begin, size_t end, unsigned int flags) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TrackCost {\b getOverlapCost} ({\b Interval}, {\b Net} *, unsigned int flags) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TrackCost {\b getOverlapCost} ({\b TrackElement} *, unsigned int flags) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getTerminalWeight} ({\b Interval}, {\b Net} *, size_t &count, unsigned int &weight) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getSourcePosition} (size_t index) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b check} (unsigned int &overlaps, const char *message=NULL) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b invalidate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insert} ({\b TrackElement} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insert} ({\b TrackMarker} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSegment} ({\b TrackElement} *, size_t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b doRemoval} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b doReorder} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b npos} = (size_t)-1\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure managing one routing track. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Track Purpose
\par}
{\tc\tcl2 \v Track Purpose}
We use an array of {\i regularly spaced}  {\b Track} as a geometrical fast access structure. It allows to know whether an area is used or not. The whole area may be seen as a set of adjoining tiles of fixed {\i width}  but variable {\i length} .\par
The figure {\b (1.b)}  show, for an horizontal, track the relation between {\f2 y,min,max}  and the occupied area of the plane. {\f2 min}  and {\f2 max}  must take into account segment extensions ({\f2 e} ) and the minimal distance between two rectangles ({\f2 MD} ) of the same layer. We assume that the width of the segment, augmented of all it's contraints is no greater than {\f2 TS}  (in fact it's how {\f2 TS}  must be calculated).\par
For the whole track array, see {\b RoutingPlane}.\par
\par}
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Track Implementation
\par}
{\tc\tcl2 \v Track Implementation}
A {\b Track} is implemented with a sorted vector of {\b TrackElement}. TrackElements from differents nets must not overlap. The sorting order is defined as follow:{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TrackElements are sorted by increasing source ({\i min} ) positions.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
In case of overlap (i.e. belongs to the same net), if they share the same source position, then they are sorted by {\i decreasing}  length. This way, the longest one will be the first encountered when walking through the {\b Track} in increasing index order.\par}
Figure {\b 2.b}  shows the details of the {\b Track} {\b [1]}  of figure {\b 1.a} . Net {\b <d>}  show an exemple of overlapping.\par
 \par
In addition to the TrackSegments, the {\b Track} also manage additionnal informations through a second vector of TrackMarkers. {\b TrackMarker} are currently used only to hints at how strongly a terminal is dependant on that portion of {\b Track} to be accessed.\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Indexes vs. Iterators
\par}
{\tc\tcl3 \v Indexes vs. Iterators}
Numerical indexes have been prefered over iterators because they can be used more easily by objects other the {\b Track} itself for referencing. So internal managment follow the same rule, handling indexes or reference to indexes.\par}
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Update Mechanism
\par}
{\tc\tcl3 \v Update Mechanism}
When a {\b TrackElement} is normaly inserted in a {\b Track}, a two way link is established. The {\b Track} has an entry in it's vector refering to {\b TrackElement}, and conversely, the {\b TrackElement} has it's {\f2 track}  field pointing to it's owning {\b Track}.\par
{\b {\b TrackElement} Removal} \par
To remove a {\b TrackElement} from a {\b Track}, we break one of those two links: the {\b TrackElement} cease to refer to the owning {\b Track}, marking him for removal which will occurs at the next track revalidation ({\b Track::doRemoval()}). In figure {\b 3} , the {\b TrackElement} belonging to net {\b <b>}  is marked for removal.\par
 {\b {\b TrackElement} Insertion} \par
When a {\b TrackElement} is inserted into a {\b Track}, the two way link is immediatly created (but the {\b TrackElement} is not yet at it's final place in the {\b Track}'s vector). Before inserting a {\b TrackElement} we check that it's been already detached ({\f2 track}  field to {\f2 NULL} ).\par
It is at that step that the {\b TrackElement} axis is actually updated through a call to {\b TrackElement::setAxis()}.\par
{\b Revalidation Sequence} \par
After a {\b Track} has been modificated either the {\b Track} element vector or the MarkerElement vector (or both) has been invalidateds. Revalidation take place in three steps:{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Track::doRemoval()}, remove all {\b TrackElement} marked for removal.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Track::insert()}, insert the {\b TrackElement} into their new {\b Track}.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Track::doReorder()}, sort the {\b TrackElement} of the vector, that is, put the newly inserted elements at their right place.\par}
Each step must be done {\i for all Tracks}  before proceeding to the next. This way a {\b TrackElement} {\f2 track}  field doesn't get set {\i before}  it has been actually removed from it's previous {\b Track}.\par}
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Main Operations on Tracks
\par}
{\tc\tcl3 \v Main Operations on Tracks}
{\b Helper Function:}  {\b Track::getBeginIndex()}\par
Return in {\f2 begin}  the index of the {\b TrackElement} whose minimum is immediately below the requested {\f2 position}  on the {\b Track} axis. The second returned parameter {\f2 state}  is a set of flags to tell how the {\f2 begin}  index has to be interpreted.\par
{\b Helper Function:}  {\b Track::getOccupiedInterval()}\par
Returns the complete interval of a set of overlapping {\b TrackElement} from the same net. \par}
\par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v IndexState\:Kite::Track}
{\xe \v Kite::Track\:IndexState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b IndexState}}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Indicates how to compute the bounds of the interval enclosing a given {\f2 position}  on track axis.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid According to {\i position} , the interval can be a free interval or a used interval. \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v BeginIsTrackMin\:Kite::Track}
{\xe \v Kite::Track\:BeginIsTrackMin}
{\qr BeginIsTrackMin{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(implies {\f2 begin=0} ) there is no {\b TrackElement} {\i before}  {\f2 position}  \par
}\cell }{\row }
{\xe \v BeginIsSegmentMin\:Kite::Track}
{\xe \v Kite::Track\:BeginIsSegmentMin}
{\qr BeginIsSegmentMin{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\f2 begin}  segment starts {\i before}  {\f2 position}  and ends {\i after} . \par
}\cell }{\row }
{\xe \v BeginIsSegmentMax\:Kite::Track}
{\xe \v Kite::Track\:BeginIsSegmentMax}
{\qr BeginIsSegmentMax{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\f2 begin}  segment starts and ends {\i before}  {\f2 position} . \par
}\cell }{\row }
{\xe \v EndIsTrackMax\:Kite::Track}
{\xe \v Kite::Track\:EndIsTrackMax}
{\qr EndIsTrackMax{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
There is no {\b TrackElement} {\i after}  {\f2 position} . \par
}\cell }{\row }
{\xe \v EndIsSegmentMin\:Kite::Track}
{\xe \v Kite::Track\:EndIsSegmentMin}
{\qr EndIsSegmentMin{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\f2 begin}  segment starts {\i before}  {\f2 position} . \par
}\cell }{\row }
{\xe \v EndIsNextSegmentMin\:Kite::Track}
{\xe \v Kite::Track\:EndIsNextSegmentMin}
{\qr EndIsNextSegmentMin{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\f2 begin}  segment starts and ends {\i before}  {\f2 position} . So the maximum is given by the {\f2 minimum}  of the {\i next}  {\b TrackElement}. \par
}\cell }{\row }
{\xe \v EndIsSegmentMax\:Kite::Track}
{\xe \v Kite::Track\:EndIsSegmentMax}
{\qr EndIsSegmentMax{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\f2 begin}  segment starts {\i before}  {\f2 position}  and ends {\i after} . \par
}\cell }{\row }
{\xe \v BeforeFirstElement\:Kite::Track}
{\xe \v Kite::Track\:BeforeFirstElement}
{\qr BeforeFirstElement{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the {\f2 position}  is before the first {\b TrackElement}. \par
}\cell }{\row }
{\xe \v InsideElement\:Kite::Track}
{\xe \v Kite::Track\:InsideElement}
{\qr InsideElement{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the {\f2 position}  is inside a {\b TrackElement}. \par
}\cell }{\row }
{\xe \v OutsideElement\:Kite::Track}
{\xe \v Kite::Track\:OutsideElement}
{\qr OutsideElement{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the {\f2 position}  is in free zone between two TrackElements. \par
}\cell }{\row }
{\xe \v AfterLastElement\:Kite::Track}
{\xe \v Kite::Track\:AfterLastElement}
{\qr AfterLastElement{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the position is after the end of the last element. \par
}\cell }{\row }
{\xe \v EmptyTrack\:Kite::Track}
{\xe \v Kite::Track\:EmptyTrack}
{\qr EmptyTrack{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the track is still empty. \par
}\cell }{\row }
{\xe \v BeginMask\:Kite::Track}
{\xe \v Kite::Track\:BeginMask}
{\qr BeginMask{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To extract the {\i begin}  part from a combination of flags. \par
}\cell }{\row }
{\xe \v EndMask\:Kite::Track}
{\xe \v Kite::Track\:EndMask}
{\qr EndMask{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To extract the {\i end}  part from a combination of flags. \par
}\cell }{\row }
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v isHorizontal\:Kite::Track}
{\xe \v Kite::Track\:isHorizontal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isHorizontal () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the {\b Track} in horizontal direction. \par
}{
Implemented in {\b HorizontalTrack} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACZ \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b VerticalTrack} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by TrackFixedSegment::isHorizontal().}\par
}
{\xe \v isVertical\:Kite::Track}
{\xe \v Kite::Track\:isVertical}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isVertical () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the {\b Track} in vertical direction. \par
}{
Implemented in {\b HorizontalTrack} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADB \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b VerticalTrack} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by TrackFixedSegment::isVertical().}\par
}
{\xe \v isLocalAssigned\:Kite::Track}
{\xe \v Kite::Track\:isLocalAssigned}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isLocalAssigned () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  is the {\b Track} should be preferentially used for local routing. \par
}}
{\xe \v getRoutingPlane\:Kite::Track}
{\xe \v Kite::Track\:getRoutingPlane}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingPlane} * getRoutingPlane () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b RoutingPlane} owning this {\b Track}. \par
}{
Referenced by Track::getNextTrack(), and Track::getPreviousTrack().}\par
}
{\xe \v getKiteEngine\:Kite::Track}
{\xe \v Kite::Track\:getKiteEngine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b KiteEngine} * getKiteEngine () const}}
\par
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b KiteEngine} owning this {\b Track}. \par
}}
{\xe \v getDirection\:Kite::Track}
{\xe \v Kite::Track\:getDirection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getDirection () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The direction of the {\b Track}, either Katabatic::KbHorizontal or Katabatic::KbVertical. \par
}{
Implemented in {\b HorizontalTrack} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADD \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b VerticalTrack} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by TrackFixedSegment::getDirection().}\par
}
{\xe \v getIndex\:Kite::Track}
{\xe \v Kite::Track\:getIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RoutingPlane} * getIndex () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The index of this {\b Track} in the {\b RoutingPlane} {\b Track} vector. \par
}{
Referenced by Track::check(), Track::getNextTrack(), and Track::getPreviousTrack().}\par
}
{\xe \v getDepth\:Kite::Track}
{\xe \v Kite::Track\:getDepth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getDepth () const}}
\par
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The depth (as given by the RoutingGauge) of the {\b Track}'s layer. \par
}}
{\xe \v getLayer\:Kite::Track}
{\xe \v Kite::Track\:getLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Layer} * getLayer () const}}
\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\f2 Layer}  of the {\b Track}. \par
}{
Referenced by Track::insert().}\par
}
{\xe \v getBlockageLayer\:Kite::Track}
{\xe \v Kite::Track\:getBlockageLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Layer} * getBlockageLayer () const}}
\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The associated blockage {\f2 Layer}  to the {\b Track}'s layer. \par
}{
Referenced by Track::insert().}\par
}
{\xe \v getAxis\:Kite::Track}
{\xe \v Kite::Track\:getAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getAxis () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The Axis of the {\b Track}. \par
}{
Referenced by Track::check(), NegociateWindow::createTrackSegment(), TrackFixedSegment::getAxis(), VerticalTrack::getPosition(), HorizontalTrack::getPosition(), Track::insert(), RoutingEvent::revalidate(), Manipulator::ripupPerpandiculars(), and SegmentFsm::SegmentFsm().}\par
}
{\xe \v getMin\:Kite::Track}
{\xe \v Kite::Track\:getMin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getMin () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The minimal allowed coordinate of the {\b Track}. \par
}{
Referenced by Manipulator::minimize().}\par
}
{\xe \v getMax\:Kite::Track}
{\xe \v Kite::Track\:getMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getMax () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The maximal allowed coordinate of the {\b Track}. \par
}}
{\xe \v getNextTrack\:Kite::Track}
{\xe \v Kite::Track\:getNextTrack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Track} * getNextTrack () const}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The next {\b Track} in the {\f2 {\b RoutingPlane}}  vector. That is the one with the axis immediatly superior. \par
}{
Referenced by NegociateWindow::createTrackSegment(), RoutingEvent::revalidate(), and Manipulator::ripupPerpandiculars().}\par
}
{\xe \v getPreviousTrack\:Kite::Track}
{\xe \v Kite::Track\:getPreviousTrack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Track} * getPreviousTrack () const}}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The previous {\b Track} in the {\f2 {\b RoutingPlane}}  vector. That is the one with the axis immediatly inferior. \par
}{
Referenced by NegociateWindow::createTrackSegment().}\par
}
{\xe \v getSize\:Kite::Track}
{\xe \v Kite::Track\:getSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getSize () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The total number of {\b TrackSegment} in the {\b Track}. \par
}{
Referenced by Track::getMaximalPosition(), and Track::getSegment().}\par
}
{\xe \v getPosition\:Kite::Track}
{\xe \v Kite::Track\:getPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Point} getPosition ({\b DbU::Unit}  {\i position}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  the point at {\f2 } (position,{\b getAxis()}) for horizontal {\b Track} at or {\f2 } ({\b getAxis()},position) for vertical {\b Track}. \par
}{
Implemented in {\b HorizontalTrack} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADF \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b VerticalTrack} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getSegment\:Kite::Track}
{\xe \v Kite::Track\:getSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackSegment} * getSegment (size_t  {\i index}) const}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{The index of the {\b TrackSegment}. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The {\b TrackSegment} at {\i index} . The result will be {\f2 NULL}  in the follwing cases :{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\i index}  is outside the sorted zone.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\i index}  points to a hole in the {\b Track}.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\i index}  is equal to {\b Track::npos}. \par}
}}{
Referenced by SegmentFsm::conflictSolveByPlaceds(), NegociateWindow::createTrackSegment(), SegmentFsm::desaturate(), Manipulator::forceOverLocals(), Manipulator::forceToTrack(), Track::getSegment(), Manipulator::insertInTrack(), Manipulator::makeDogleg(), Manipulator::minimize(), and Manipulator::shrinkToTrack().}\par
}
{\xe \v getSegment\:Kite::Track}
{\xe \v Kite::Track\:getSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackSegment} * getSegment ({\b DbU::Unit}  {\i position}) const}}
\par
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i position} \cell }{The position where to search. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The {\b TrackSegment} whose starting point is immediatly inferior to {\i position} . \par
}}}
{\xe \v getNext\:Kite::Track}
{\xe \v Kite::Track\:getNext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackSegment} * getNext (size_t &  {\i index}, {\b Net} *  {\i net}) const}}
\par
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{Index of the starting {\b TrackSegment}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i net} \cell }{A {\f2 Net}  to ignore. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The next {\b TrackSegment} ({\f2 NULL}  if not found).\par
}Find, starting from {\b TrackSegment} at {\i index}  the next {\b TrackSegment} ignoring {\b TrackSegment} from {\i net} . {\i index}  is modified to point on the returned {\b TrackSegment}. If there's no next {\b TrackSegment} ({\f2 NULL} ) then index is set to {\b Track::npos}. \par
}{
Referenced by Track::expandFreeInterval(), TrackFixedSegment::getNext(), TrackSegment::getNext(), TrackElement::getNext(), and Track::getNextFixed().}\par
}
{\xe \v getPrevious\:Kite::Track}
{\xe \v Kite::Track\:getPrevious}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackSegment} * getPrevious (size_t &  {\i index}, {\b Net} *  {\i net}) const}}
\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{Index of the starting {\b TrackSegment}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i net} \cell }{A {\f2 Net}  to ignore. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The previous {\b TrackSegment} ({\f2 NULL}  if not found).\par
}find, starting from {\b TrackSegment} at {\i index}  the previous {\b TrackSegment} ignoring {\b TrackSegment} from {\i net} . {\i index}  is modified to point on the returned {\b TrackSegment}. If there's no previous {\b TrackSegment} ({\f2 NULL} ) then index is set to {\b Track::npos}. \par
}{
Referenced by Track::expandFreeInterval(), TrackFixedSegment::getPrevious(), TrackSegment::getPrevious(), and TrackElement::getPrevious().}\par
}
{\xe \v getNextFixed\:Kite::Track}
{\xe \v Kite::Track\:getNextFixed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackSegment} * getNextFixed (size_t &  {\i index}) const}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{Index of the starting {\b TrackSegment}. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The first previous {\i Fixed}  {\b TrackSegment}.\par
}find, starting from {\b TrackSegment} at {\i index}  the first previous with a {\i Fixed}  attribute set. {\i index}  is modified to point on the returned {\b TrackSegment}. If there's no previous {\b TrackSegment} ({\f2 NULL} ) then index is set to {\b Track::npos}. \par
}}
{\xe \v find\:Kite::Track}
{\xe \v Kite::Track\:find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t find (const {\b TrackElement} *  {\i element}) const}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  the {\i index}  of {\i element}  inside the {\b Track}. If the {\i element}  do not belongs to the {\b Track}, return {\b Track::npos}. \par
}}
{\xe \v getSourcePosition\:Kite::Track}
{\xe \v Kite::Track\:getSourcePosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getSourcePosition (vector< {\b TrackElement} *>::iterator  {\i it}) const}}
\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The source position of {\b TrackSegment} pointed by iterator {\i it} . If {\i it}  is equal to {\f2 end()}  , returns zero. \par
}}
{\xe \v getMinimalPosition\:Kite::Track}
{\xe \v Kite::Track\:getMinimalPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getMinimalPosition (size_t  {\i index}, unsigned int  {\i state}) const}}
\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  Extract the minimal position from the interval at {\f2 index}  in accordance to {\f2 state}  hinting.\par
{\b See also:} \~ {\b Track::IndexState}. \par
}}
{\xe \v getMaximalPosition\:Kite::Track}
{\xe \v Kite::Track\:getMaximalPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getMaximalPosition (size_t  {\i index}, unsigned int  {\i state}) const}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  Extract the maximal position from the interval at {\f2 index}  in accordance to {\f2 state}  hinting.\par
{\b See also:} \~ {\b Track::IndexState}. \par
}{
Referenced by Track::expandFreeInterval().}\par
}
{\xe \v getFreeInterval\:Kite::Track}
{\xe \v Kite::Track\:getFreeInterval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getFreeInterval ({\b DbU::Unit}  {\i position}, {\b Net} *  {\i net} = {\f2 NULL}) const}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i position} \cell }{where fo find a free interval. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i net} \cell }{for which net to find the free interval. {\b Returns:}  The longuest free interval enclosing {\i position}  (may be empty). \cell }
{\row }
}
}}
{\xe \v getOccupiedInterval\:Kite::Track}
{\xe \v Kite::Track\:getOccupiedInterval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getOccupiedInterval (size_t &  {\i begin}) const}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i begin} \cell }{index of one of the {\b TrackElement} set. May be modificated. {\b Returns:}  the whole interval used by a set of overlaping {\b TrackSegment}.\cell }
{\row }
}
As {\b TrackElement} from a same net can overlap, the interval of one of them do not give the full extend of the {\b Track} occupation at this point. This function looks for all overlaping segments and returns the merged interval. Additionnaly it sets {\f2 begin}  to the index of the lowest {\b TrackElement} of the set.\par
 \par
}{
Referenced by Track::expandFreeInterval(), Track::getBeginIndex(), and Track::getOverlapBounds().}\par
}
{\xe \v expandFreeInterval\:Kite::Track}
{\xe \v Kite::Track\:expandFreeInterval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} expandFreeInterval (size_t &  {\i begin}, size_t &  {\i end}, unsigned int  {\i state}, {\b Net} *  {\i net}) const}}
\par
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i begin} \cell }{the lowest used {\b TrackSegment}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i end} \cell }{the highest used {\b TrackSegment}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i state} \cell }{tells how to interpret the {\f2 begin}  & {\f2 end}  indexes. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i net} \cell }{the for wich we seek place. {\b Returns:}  The longuest free interval between {\f2 } ]begin,end[ .\cell }
{\row }
}
Starting from the initial {\f2 [begin,end]}  interval, expand the interval to encompass all free space or segments belonging to {\f2 net} . {\f2 state}  may be used to compute the interval bounds from {\f2 begin}  and {\f2 end}  instead of directly using the returned {\f2 interval} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 } ]begin,end[ must define a free interval between two {\b TrackSegment}. \par
}}{
Referenced by Track::getFreeInterval().}\par
}
{\xe \v getBeginIndex\:Kite::Track}
{\xe \v Kite::Track\:getBeginIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void getBeginIndex ({\b DbU::Unit}  {\i position}, size_t &  {\i begin}, unsigned int &  {\i state}) const}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i position} \cell }{The position where to search. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i begin} \cell }{Index of the immediatly inferior {\b TrackElement}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i state} \cell }{how to interpret the returned {\f2 begin} .\cell }
{\row }
}
Return in {\f2 begin}  the index of the {\b TrackElement} whose minimum is immediately below the requested {\f2 position}  on the {\b Track} axis. The second returned parameter {\f2 state}  is a set of flags to tell how the {\f2 begin}  index has to be interpreted.\par
Flags for the {\f2 state}  are:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Track::BeginIsTrackMin} : (implies {\f2 begin=0} ) there is no {\b TrackElement} {\i before}  {\f2 position} .\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Track::EndIsSegmentMin} : The {\f2 begin}  segment starts {\i before}  {\f2 position} .\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Track::BeginIsSegmentMin} : The {\f2 begin}  segment starts {\i before}  {\f2 position}  and ends {\i after} .\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Track::EndIsSegmentMax} : The {\f2 begin}  segment starts {\i before}  {\f2 position}  and ends {\i after} .\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Track::BeginIsSegmentMax} : The {\f2 begin}  segment starts and ends {\i before}  {\f2 position} .\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Track::EndIsNextSegmentMin} : The {\f2 begin}  segment starts and ends {\i before}  {\f2 position} . So the maximum is given by the {\f2 minimum}  of the {\i next}  {\b TrackElement}.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Track::EndIsTrackMax} : There is no {\b TrackElement} {\i after}  {\f2 position} .\par}
Based on the previous flags, we build the {\f2 state}  parameter:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Track::BeforeFirstElement} : the {\f2 position}  is before the first {\b TrackElement}.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Track::InsideElement} : the {\f2 position}  is inside a {\b TrackElement}.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Track::OutsideElement} : the {\f2 position}  is in free zone between two TrackElements.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Track::AfterLastElement} : the position is after the end of the last element.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Track::EmptyTrack} : the track is still empty.\par}
To separate flags relevant to {\i begin}  and {\i end}  informations, two masks are provideds:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Track::BeginMask}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Track::EndMask}\par}
 {\b Reminder for myself:}  The {\b Track::getBeginIndex()} function relies on the {\f2 STL} {\f2 lower_bound()}  function. {\f2 lower_bound()}  finds the {\b TrackElement} immediately {\i superior}  to {\f2 position}  (shown on Figure {\b 3}  by the {\f2 LB}  label in white on black).\par
The relation between the returned {\f2 begin}  index and the position is given through the {\f2 state}  parameter. \par
}{
Referenced by Track::getFreeInterval(), Track::getOverlapBounds(), and Track::getSegment().}\par
}
{\xe \v getOverlapBounds\:Kite::Track}
{\xe \v Kite::Track\:getOverlapBounds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void getOverlapBounds ({\b Interval}  {\i interval}, size_t &  {\i begin}, size_t &  {\i end}) const}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i interval} \cell }{the overlaping interval. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i begin} \cell }{where to store the starting bound. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i end} \cell }{where to store the ending bound.\cell }
{\row }
}
find the range of {\b TrackSegment} intersecting {\i interval} . Note that when the {\i interval}  lower bound crosses a set of overlaping intervals from the same {\f2 Net} , the interval at {\i begin}  will crosses the lower bound but some following of the same {\f2 Net}  may not. \par
}{
Referenced by NegociateWindow::createTrackSegment(), and Track::getOverlapCost().}\par
}
{\xe \v getOverlapCost\:Kite::Track}
{\xe \v Kite::Track\:getOverlapCost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TrackCost getOverlapCost ({\b Interval}  {\i interval}, {\b Net} *  {\i net}, size_t  {\i begin}, size_t  {\i end}, unsigned int  {\i flags}) const}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i interval} \cell }{the overlaping interval. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i net} \cell }{a Net to ignore (null cost). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i begin} \cell }{the starting bound. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i end} \cell }{the ending bound. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i flags} \cell }{passed to the overlap cost function. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The cost of the overlap.\par
}Compute the cost of the overlap of {\i interval}  with the range {\f2 } [begin,end] of {\b TrackSegment}. Any {\b TrackSegment} belonging to {\i net}  will be ignored. \par
}{
Referenced by Track::getOverlapCost().}\par
}
{\xe \v getOverlapCost\:Kite::Track}
{\xe \v Kite::Track\:getOverlapCost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TrackCost getOverlapCost ({\b Interval}  {\i interval}, {\b Net} *  {\i net}, unsigned int  {\i flags}) const}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i interval} \cell }{the overlaping interval. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i net} \cell }{a Net to ignore (null cost). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i flags} \cell }{passed to the overlap cost function.\cell }
{\row }
}
Compute the overlap cost of {\i interval}  with {\b TrackSegment} from the current {\b Track}, ignoring thoses belonging to {\i net} . \par
}}
{\xe \v getOverlapCost\:Kite::Track}
{\xe \v Kite::Track\:getOverlapCost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TrackCost getOverlapCost ({\b TrackElement} *  {\i segment}, unsigned int  {\i flags}) const}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i segment} \cell }{under which to compute overlap cost. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i flags} \cell }{passed to the overlap cost function.\cell }
{\row }
}
Compute the overlap cost of {\f2 segment}  with {\b TrackSegment} from the current {\b Track} (interval and net are deduced from {\f2 segment} ). \par
}}
{\xe \v getTerminalWeight\:Kite::Track}
{\xe \v Kite::Track\:getTerminalWeight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void getTerminalWeight ({\b Interval}  {\i interval}, {\b Net} *  {\i net}, size_t &  {\i count}, unsigned int &  {\i weight}) const}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i interval} \cell }{under which to compute terminal weight. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i net} \cell }{a net to be ignored. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i count} \cell }{incremented of the number of track markers under the {\f2 interval} . \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i weight} \cell }{incremented of the sum of the weight of the track markers under the {\f2 interval} .\cell }
{\row }
}
Compute and return the sum of the weight of the track markers (see {\b TrackMarker}) under {\f2 interval}  ignoring {\f2 net}  (that is, {\i for}  {\f2 net} ).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: The referenced variables {\f2 count}  and {\f2 weight}  are not reset to\par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid zero by this function. It is of the caller's responsability. \par
}}}
{\xe \v getSourcePosition\:Kite::Track}
{\xe \v Kite::Track\:getSourcePosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getSourcePosition (size_t  {\i index}) const}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The source position of {\b TrackSegment} at index {\i index} . If {\i index}  is equal to {\b Track::npos}, returns zero. \par
}}
{\xe \v check\:Kite::Track}
{\xe \v Kite::Track\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool check (unsigned int &  {\i overlaps}, const char *  {\i message} = {\f2 NULL}) const}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i overlaps} \cell }{The number of overlaping segments. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i message} \cell }{An iformative message, only printed if an error occurs. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b true}  if the {\b Track} contains no incoherencies.\par
}Perform a complete {\b Track} check. Looks for the following incoherencies :{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TrackSegment} do not refers this {\b Track}.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TrackSegment} is detached ({\b TrackSegment::getTrack()} is {\f2 NULL} ).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TrackSegment} is hollow, this one is very unlikely as hollow {\b TrackSegment} are only created for the {\f2 lower_bound()} .\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 NULL}  pointers (should never occurs, nevertheless...)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Two consecutive {\b TrackSegment} from different {\f2 Net}  must not overlap.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
For {\b TrackSegment} starting from the same position, the longuest must be first. \par}
}}
{\xe \v invalidate\:Kite::Track}
{\xe \v Kite::Track\:invalidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void invalidate ()}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inconditionnaly invalidate the {\b Track}, regardless if it has been modificated. The {\b Track} will be forced to be revalidated on closure of the current session. \par
}}
{\xe \v insert\:Kite::Track}
{\xe \v Kite::Track\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void insert ({\b TrackElement} *  {\i segment})}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds {\i segment}  to the {\b Track}. Must only be used inside a {\b Session}. They must appears {\i after}  {\b Track::doRemoval()} and {\i before}  {\b Track::doReorder()}.\par
{\b See also:} \~ {\b Kite::Session}. \par
}}
{\xe \v insert\:Kite::Track}
{\xe \v Kite::Track\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void insert ({\b TrackMarker} *  {\i marker})}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds {\i marker}  to the {\b Track}. Must only be used inside a {\b Session}.\par
{\b See also:} \~ {\b Kite::Session}. \par
}}
{\xe \v setSegment\:Kite::Track}
{\xe \v Kite::Track\:setSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setSegment ({\b TrackElement} *  {\i element}, size_t  {\i index})}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Directly affect the {\b Track} entry at position {\f2 index}  to {\f2 element}  (use with great care).\par
{\b See also:} \~ {\b Kite::Session}. \par
}{
Referenced by TrackSegment::swapTrack().}\par
}
{\xe \v doRemoval\:Kite::Track}
{\xe \v Kite::Track\:doRemoval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t doRemoval ()}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The number of removeds {\b TrackSegment}.\par
Suppress all the {\b TrackSegment} that have been withdraw from the {\b Track}. {\b TrackSegment} must be withdraw trough the {\b TrackSegment::detach()} method which sets their owning {\b Track} to {\f2 NULL}  (the removal criterion). It uses the {\f2 STL} {\i remove_if}  algorithm that put all the to be removed elements at the end of the vector.\par
{\b See also:} \~ {\b Kite::Session}. \par
}}
{\xe \v doReorder\:Kite::Track}
{\xe \v Kite::Track\:doReorder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void doReorder ()}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Re)sort the {\b TrackElement} of the vector. Must be called {\i after:}  {
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Track::doRemoval()} so no detached {\b TrackSegment} are presents.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
All calls to {\b Track::insert()}, as the newly inserted elements are put at the back of the vector.\par}
{\b See also:} \~ {\b Kite::Session}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v npos\:Kite::Track}
{\xe \v Kite::Track\:npos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
npos = (size_t)-1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A special index value (greatest integer) meaning that an index is invalid. \par
}{
Referenced by Track::expandFreeInterval(), Track::find(), Track::getNext(), Track::getOccupiedInterval(), Track::getOverlapBounds(), Track::getOverlapCost(), Track::getPrevious(), Track::getSegment(), and Track::getSourcePosition().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Track.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Track.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Track.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TrackElement Class Reference\par \pard\plain 
{\tc\tcl2 \v TrackElement}
{\xe \v TrackElement}
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract Class for all Elements inserted inside a {\b Track}. }}\par
Inheritance diagram for TrackElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKite_1_1TrackElement__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isFixed} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isHorizontal} () const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isVertical} () const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isLocal} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isGlobal} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isBipoint} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isTerminal} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isStrap} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isSlackened} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isDogleg} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isCreated} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInvalidated} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isBlockage} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isLocked} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isRouted} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasSourceDogleg} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasTargetDogleg} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b canRipple} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canDogleg} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canDogleg} ({\b Interval})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canDogleg} ({\b Katabatic::GCell} *, unsigned int flags=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned long {\b getId} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b getDirection} () const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Net} * {\b getNet} () const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const {\b Layer} * {\b getLayer} () const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Track} * {\b getTrack} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getIndex} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned long {\b getFreedomDegree} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual float {\b getMaxUnderDensity} (unsigned int flags=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Box} {\b getBoundingBox} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b TrackElement} * {\b getNext} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b TrackElement} * {\b getPrevious} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b DbU::Unit} {\b getAxis} () const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getSourceU} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getTargetU} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getLength} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Interval} {\b getCanonicalInterval} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Interval} {\b getFreeInterval} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Interval} {\b getSourceConstraints} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Interval} {\b getTargetConstraints} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b DataNegociate} * {\b getDataNegociate} (unsigned int flags={\b KtDataSelf}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b TrackElement} * {\b getCanonical} ({\b Interval} &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual size_t {\b getGCells} (Katabatic::GCellVector &) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b TrackElement} * {\b getParent} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b getDoglegLevel} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b TrackElement} * {\b getSourceDogleg} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b TrackElement} * {\b getTargetDogleg} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual TrackElements {\b getPerpandiculars} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFlags} (unsigned int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b unsetFlags} (unsigned int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b setTrack} ({\b Track} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setIndex} (size_t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateFreedomDegree} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b setDoglegLevel} (unsigned int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b swapTrack} ({\b TrackElement} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b reschedule} (unsigned int level)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b detach} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b invalidate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b revalidate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b incOverlapCost} ({\b Net} *, TrackCost &) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b setAxis} ({\b DbU::Unit}, unsigned int flags=Katabatic::SegAxisSet)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b TrackElement} * {\b makeDogleg} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b makeDogleg} ({\b Katabatic::GCell} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b TrackElement} * {\b makeDogleg} ({\b Interval}, unsigned int &flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b _check} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b SegmentOverlapCostCB} * {\b setOverlapCostCB} ({\b SegmentOverlapCostCB} *)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract Class for all Elements inserted inside a {\b Track}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TrackElement Abstract
\par}
{\tc\tcl2 \v TrackElement Abstract}
The {\b TrackElement} class is abstract and is used as base class for any element that can be inserted in a {\b Track}. It represent the footprint of that element inside the {\b Track} (an interval). Additionnaly it keep a pointer to the {\b Track} and it's index inside it ({\b Track} is implemented with a {\f2 vector<>} ).\par
To avoid some explicit dynamic cast later, it provides a default implementation for almost all the methods that will be present in all the derived classes. All default methods return {\f2 false} , {\f2 NULL}  or {\f2 0}  ({\i zero} ) or whatever is appropriated to tell it is not meaningful.\par
{\b Design Note} \par
{\b TrackElement} has been designed to serve as a base class for {\b TrackSegment} and {\b TrackMarker}. But, in the end, those two classes have been put in separated vectors inside the {\b Track}, thus rendering this design choice less pertinent. We keep it for now because we may introduce other object than {\b TrackSegment} inside a {\b Track}. If the need do not arise, we may merge back {\b TrackElement} and {\b TrackSegment}. \par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v setOverlapCostCB\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:setOverlapCostCB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SegmentOverlapCostCB} * setOverlapCostCB ({\b SegmentOverlapCostCB} *  {\i cb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cb} \cell }{the new overlap cost callback. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the previous overlap cost callback.\par
}sets the overlap callback. \par
}{
Referenced by NegociateWindow::run().}\par
}
{\xe \v isFixed\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:isFixed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isFixed () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b Katabatic::AutoSegment::isFixed()}. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQG \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b TrackFixedSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by SegmentFsm::addAction(), SegmentFsm::conflictSolveByPlaceds(), NegociateWindow::createTrackSegment(), SegmentFsm::desaturate(), SegmentAction::doAction(), Manipulator::forceOverLocals(), Manipulator::forceToTrack(), Manipulator::insertInTrack(), Manipulator::isCaged(), Manipulator::makeDogleg(), Manipulator::minimize(), Manipulator::moveUp(), Manipulator::pivotDown(), Manipulator::pivotUp(), Manipulator::relax(), Manipulator::repackPerpandiculars(), Manipulator::ripup(), Manipulator::shrinkToTrack(), and Manipulator::slacken().}\par
}
{\xe \v isHorizontal\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:isHorizontal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isHorizontal () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b Katabatic::AutoSegment::isHorizontal()}. \par
}{
Implemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b TrackFixedSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by SegmentFsm::conflictSolveByHistory(), and Manipulator::makeDogleg().}\par
}
{\xe \v isVertical\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:isVertical}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isVertical () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b Katabatic::AutoSegment::isVertical()}. \par
}{
Implemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQM \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b TrackFixedSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v isLocal\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:isLocal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isLocal () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ Katabatic::isLocal(). \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by SegmentFsm::conflictSolveByPlaceds(), SegmentFsm::doActions(), Manipulator::insertInTrack(), Manipulator::makeDogleg(), Manipulator::moveUp(), Manipulator::pivotUp(), Manipulator::relax(), Manipulator::ripple(), Manipulator::ripupPerpandiculars(), SegmentFsm::SegmentFsm(), Manipulator::shrinkToTrack(), SegmentFsm::slackenTopology(), and SegmentFsm::solveFullBlockages().}\par
}
{\xe \v isGlobal\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:isGlobal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isGlobal () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b Katabatic::AutoSegment::isGlobal()}. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by SegmentFsm::conflictSolveByPlaceds(), Manipulator::insertInTrack(), Manipulator::relax(), Manipulator::repackPerpandiculars(), and SegmentFsm::SegmentFsm().}\par
}
{\xe \v isBipoint\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:isBipoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isBipoint () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b Katabatic::AutoSegment::isBipoint()}. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by SegmentFsm::desaturate().}\par
}
{\xe \v isTerminal\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:isTerminal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isTerminal () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ Katabatic::AutoSegment::isTerminal(). \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by Manipulator::makeDogleg(), and Manipulator::relax().}\par
}
{\xe \v isStrap\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:isStrap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isStrap () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b Katabatic::AutoSegment::isStrap()}. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by Manipulator::insertInTrack(), Manipulator::pivotDown(), Manipulator::pivotUp(), SegmentFsm::SegmentFsm(), and SegmentFsm::slackenTopology().}\par
}
{\xe \v isSlackened\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:isSlackened}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isSlackened () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b Katabatic::AutoSegment::isSlackened()}. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v isDogleg\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:isDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isDogleg () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ Katabatic::isDogleg(). \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v isCreated\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:isCreated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isCreated () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b Katabatic::AutoSegment::isCreated()}. \par
}}
{\xe \v isInvalidated\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:isInvalidated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isInvalidated () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the segment is invalidated (may be different from the supporting AutoSegment status). \par
}{
Referenced by SegmentObserver::notify().}\par
}
{\xe \v isBlockage\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:isBlockage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isBlockage () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b true}  if the element is a blockage (obstacle). \par
}{
Referenced by SegmentFsm::conflictSolveByPlaceds(), NegociateWindow::createTrackSegment(), Manipulator::insertInTrack(), and Manipulator::isCaged().}\par
}
{\xe \v isLocked\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:isLocked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isLocked () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b true}  if the element is part of a net, but must not be moved by the router, whatever the reason. \par
}}
{\xe \v isRouted\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:isRouted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isRouted () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b true}  if the router has placed it. \par
}{
Referenced by TrackSegment::canDogleg().}\par
}
{\xe \v hasSourceDogleg\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:hasSourceDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool hasSourceDogleg () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method purpose has not been reviewed yet. \par
}{
Referenced by TrackSegment::canDogleg(), TrackSegment::getSourceDogleg(), and TrackSegment::getTargetDogleg().}\par
}
{\xe \v hasTargetDogleg\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:hasTargetDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool hasTargetDogleg () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method purpose has not been reviewed yet. \par
}{
Referenced by TrackSegment::canDogleg().}\par
}
{\xe \v canRipple\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:canRipple}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool canRipple () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method purpose has not been reviewed yet. \par
}{
Referenced by Manipulator::ripple().}\par
}
{\xe \v canDogleg\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:canDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool canDogleg (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b AutoSegment::canDogleg()}. At {\b Kite} level, this variant of the method will apply only on local segments and the segment must not already have a source or target dogleg. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by SegmentFsm::conflictSolveByHistory(), Manipulator::makeDogleg(), and Manipulator::relax().}\par
}
{\xe \v canDogleg\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:canDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool canDogleg ({\b Interval} ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b AutoSegment::canDogleg()}. At {\b Kite} level, this variant of the method will apply only on local segments and the segment must not already have a source or target dogleg. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v canDogleg\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:canDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool canDogleg ({\b Katabatic::GCell} *  {\i doglegGCell}, unsigned int  {\i flags} = {\f2 0}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b AutoSegment::canDogleg()}. At kite level, this variant of the method is mainly targeted to global segment. For local segment it behave like {\b TrackElement::canDogleg(Interval)}. For global segment, make the break in the requested GCell {\f2 doglegGCell} . If it's in the first or last GCell and there is already a dogleg, allow to reuse it if {\f2 flags}  contains {\b Kite::KtAllowDoglegReuse}. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getId\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long getId () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The {\f2 Id}  of the supporting AutoSegment, if there is any. {\i Zero}  otherwise. \par
}}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARR \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b TrackFixedSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by RoutingEvent::process().}\par
}
{\xe \v getDirection\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getDirection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getDirection () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The direction of the supporting element (should match the preferred direction of the {\b Track}). \par
}}{
Implemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARU \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b TrackFixedSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by TrackElement::getBoundingBox(), TrackSegment::getSourceDogleg(), TrackSegment::getTargetDogleg(), Manipulator::makeDogleg(), Manipulator::minimize(), Manipulator::relax(), and Manipulator::ripple().}\par
}
{\xe \v getNet\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getNet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Net} * getNet () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The Net associated to the element (may be {\f2 NULL} ). \par
}{
Implemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARX \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b TrackFixedSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by SegmentFsm::conflictSolveByHistory(), SegmentFsm::conflictSolveByPlaceds(), SegmentFsm::desaturate(), SegmentAction::doAction(), Manipulator::forceOverLocals(), Manipulator::forceToTrack(), TrackElement::getFreeInterval(), TrackElement::getNext(), Track::getOverlapCost(), TrackElement::getPrevious(), TrackElement::incOverlapCost(), Manipulator::insertInTrack(), Manipulator::makeDogleg(), Manipulator::minimize(), RoutingEvent::process(), RoutingEvent::revalidate(), Manipulator::ripple(), Manipulator::ripupPerpandiculars(), SegmentFsm::SegmentFsm(), Manipulator::shrinkToTrack(), SegmentFsm::slackenTopology(), and SegmentFsm::solveFullBlockages().}\par
}
{\xe \v getLayer\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Layer} * getLayer () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The Layer of the element (should match the one of the {\b Track}). \par
}{
Implemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASA \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b TrackFixedSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by SegmentFsm::conflictSolveByHistory(), SegmentFsm::conflictSolveByPlaceds(), Track::insert(), Manipulator::relax(), RoutingEvent::revalidate(), Manipulator::ripple(), Manipulator::ripupPerpandiculars(), and SegmentFsm::SegmentFsm().}\par
}
{\xe \v getTrack\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getTrack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Track} * getTrack () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b Track} into which the element is inserted (may be {\f2 NULL} ). \par
}{
Referenced by RoutingEventQueue::add(), SegmentAction::doAction(), TrackFixedSegment::getAxis(), TrackFixedSegment::getDirection(), DataNegociate::getTrack(), Manipulator::isCaged(), TrackFixedSegment::isHorizontal(), TrackFixedSegment::isVertical(), Manipulator::relax(), and TrackSegment::swapTrack().}\par
}
{\xe \v getIndex\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getIndex () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The index of the element inside the {\b Track}'s vector.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: If the element is not inserted in a Track, it is set to\par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Track::npos}, and obviously must not be used. \par
}}{
Referenced by TrackSegment::swapTrack().}\par
}
{\xe \v getFreedomDegree\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getFreedomDegree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long getFreedomDegree () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The degree of freedom of the element. It is used as a priority value when sorting {\b TrackElement} (in {\b RoutingEvent}).\par
{\b Returns:}  The degree of freedom of the element. It is used as a priority value when sorting {\b TrackElement} (in {\b RoutingEvent}).\par
Currently, it is the {\i slack}  of the {\b Katabatic::AutoSegment}. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by RoutingEvent::process().}\par
}
{\xe \v getMaxUnderDensity\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getMaxUnderDensity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float getMaxUnderDensity (unsigned int  {\i flags} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The maximum density of all the GCells under this element. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getBoundingBox\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getBoundingBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Box} getBoundingBox () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The box that this element uses in the {\b Track}. \par
}}
{\xe \v getNext\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getNext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * getNext () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The next {\b TrackElement}, on the same track and of a {\i different}  net. {\b See also:} \~ {\b Track::getNext()}. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASK \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b TrackFixedSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by Manipulator::isCaged().}\par
}
{\xe \v getPrevious\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getPrevious}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * getPrevious () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The previous {\b TrackElement}, on the same track and of a {\i different}  net. {\b See also:} \~ {\b Track::getPrevious()}. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASN \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b TrackFixedSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by Manipulator::isCaged().}\par
}
{\xe \v getAxis\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getAxis () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The axis position of the element (must be the same as the {\b Track}). \par
}{
Implemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b TrackFixedSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by SegmentFsm::conflictSolveByHistory(), TrackElement::getBoundingBox(), Manipulator::ripple(), and Manipulator::ripupPerpandiculars().}\par
}
{\xe \v getSourceU\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getSourceU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getSourceU () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The minimun of the interval used by the element (cached in an attribute). \par
}{
Referenced by TrackSegment::_check(), SegmentFsm::conflictSolveByHistory(), Track::find(), TrackElement::getBoundingBox(), TrackElement::getCanonicalInterval(), TrackElement::getLength(), Manipulator::insertInTrack(), Manipulator::isCaged(), Manipulator::minimize(), and Manipulator::shrinkToTrack().}\par
}
{\xe \v getTargetU\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getTargetU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getTargetU () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The maximum of the interval used by the element (cached in an attribute). \par
}{
Referenced by TrackSegment::_check(), TrackElement::getBoundingBox(), TrackElement::getCanonicalInterval(), TrackElement::getLength(), Manipulator::insertInTrack(), and Manipulator::isCaged().}\par
}
{\xe \v getLength\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getLength () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The length of the interval used by the element. \par
}{
Referenced by NegociateWindow::computeWirelength(), Manipulator::makeDogleg(), Manipulator::moveUp(), and RoutingEvent::revalidate().}\par
}
{\xe \v getCanonicalInterval\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getCanonicalInterval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getCanonicalInterval () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The interval span used by the element inside the {\b Track}. \par
}{
Referenced by SegmentFsm::conflictSolveByHistory(), SegmentFsm::conflictSolveByPlaceds(), SegmentFsm::desaturate(), Manipulator::forceOverLocals(), Manipulator::forceToTrack(), Track::getOverlapCost(), Manipulator::insertInTrack(), Manipulator::makeDogleg(), Manipulator::minimize(), Manipulator::relax(), Manipulator::ripple(), Manipulator::ripupPerpandiculars(), Manipulator::shrinkToTrack(), and SegmentFsm::solveFullBlockages().}\par
}
{\xe \v getFreeInterval\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getFreeInterval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getFreeInterval () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The greatest free interval enclosing this element. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASX \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b TrackFixedSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getSourceConstraints\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getSourceConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getSourceConstraints () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b Katabatic::AutoSegment::getSourceConstraints()}. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getTargetConstraints\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getTargetConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getTargetConstraints () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b Katabatic::AutoSegment::getTargetConstraints()}. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getDataNegociate\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getDataNegociate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DataNegociate} * getDataNegociate (unsigned int  {\i flags} = {\f2 {\b KtDataSelf}}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The additional data-structure supplied by the routing algorithm. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by NegociateWindow::addRoutingEvent(), SegmentFsm::desaturate(), SegmentAction::doAction(), Manipulator::forceOverLocals(), Manipulator::forceToTrack(), TrackSegment::getDataNegociate(), RoutingEvent::getState(), Manipulator::insertInTrack(), Manipulator::makeDogleg(), RoutingEvent::process(), Manipulator::relax(), Manipulator::repackPerpandiculars(), RoutingEvent::reschedule(), Manipulator::ripple(), SegmentFsm::SegmentFsm(), NegociateWindow::setGCells(), RoutingEvent::setSegment(), RoutingEvent::setState(), and SegmentFsm::slackenTopology().}\par
}
{\xe \v getCanonical\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getCanonical}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * getCanonical ({\b Interval} &  {\i i}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inner working still unclear to myself. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by NegociateWindow::createTrackSegment(), and DataNegociate::update().}\par
}
{\xe \v getGCells\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getGCells}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getGCells (Katabatic::GCellVector &  {\i gcells}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The table of {\b Katabatic::GCell} underneath the element whole span. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by Manipulator::makeDogleg(), and Manipulator::relax().}\par
}
{\xe \v getParent\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getParent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * getParent () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b TrackElement} from which the dogleg has been created, if any. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by RoutingEvent::setAxisHintFromParent().}\par
}
{\xe \v getDoglegLevel\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getDoglegLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getDoglegLevel () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The deepness of the dogleg. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getSourceDogleg\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getSourceDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * getSourceDogleg (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The source part of the segment from which the dogleg has been created. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by Manipulator::relax().}\par
}
{\xe \v getTargetDogleg\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getTargetDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * getTargetDogleg (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The target part of the segment from which the dogleg has been created. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by Manipulator::relax().}\par
}
{\xe \v getPerpandiculars\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:getPerpandiculars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TrackElements getPerpandiculars (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The collection of all element perpandiculars to this one. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by Manipulator::forceToTrack(), and Manipulator::insertInTrack().}\par
}
{\xe \v setFlags\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:setFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setFlags (unsigned int  {\i flags}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set to {\b true}  {\f2 flags}  in the element state array. \par
}{
Referenced by TrackSegment::detach(), TrackSegment::invalidate(), and Manipulator::relax().}\par
}
{\xe \v unsetFlags\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:unsetFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void unsetFlags (unsigned int  {\i flags}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset to {\b false}  {\f2 flags}  in the element state array. \par
}{
Referenced by TrackSegment::revalidate().}\par
}
{\xe \v setTrack\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:setTrack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setTrack ({\b Track} *  {\i track}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Insert the element into {\f2 track} , also used as an insertion marker. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by Track::insert(), and TrackSegment::setTrack().}\par
}
{\xe \v setIndex\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:setIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setIndex (size_t  {\i index}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Cache the element's index in the {\b Track} internal vector. \par
}{
Referenced by TrackSegment::detach(), and TrackSegment::swapTrack().}\par
}
{\xe \v updateFreedomDegree\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:updateFreedomDegree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateFreedomDegree (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update, from the element characteristics, it's degree of freedom. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v setDoglegLevel\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:setDoglegLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setDoglegLevel (unsigned int  {\i level}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the level of dogleg of the element. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v swapTrack\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:swapTrack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void swapTrack ({\b TrackElement} *  {\i other}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Swap the tracks of {\f2 this}  and {\f2 other} . \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v reschedule\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:reschedule}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void reschedule (unsigned int  {\i level}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the {\b TrackElement} has already an event scheduled, change the level of this event, otherwise create a new event.\par
{\b See also:} \~ NegotiateWindow::rescheduleEvent(). \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by TrackSegment::_postDoglegs().}\par
}
{\xe \v detach\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:detach}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void detach (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove the link from the {\b TrackElement} to it's owning {\b Track}, marking it for removal. The removal from the {\b Track}'s vector is managed by the {\b Track} itself during the {\b Session} revalidation stage. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v invalidate\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:invalidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void invalidate (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b AutoSegment::invalidate()}. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by NegociateWindow::createTrackSegment(), and SegmentObserver::notify().}\par
}
{\xe \v revalidate\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:revalidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void revalidate (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Actualize the {\b TrackElement} characteristics from the supporting elements (set of AutoSegment).\par
Must be completed with the event management \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v incOverlapCost\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:incOverlapCost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void incOverlapCost ({\b Net} *  {\i net}, TrackCost &  {\i cost}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ Compute the cost of overlap between this segment and the interval specified in {\f2 cost} . Mainly calls the relevant callback. \par
}}
{\xe \v setAxis\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:setAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setAxis ({\b DbU::Unit} , unsigned int  {\i flags} = {\f2 Katabatic::SegAxisSet}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the axis of the {\b TrackElement}. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by NegociateWindow::createTrackSegment(), SegmentAction::doAction(), Track::insert(), TrackSegment::makeDogleg(), and Manipulator::relax().}\par
}
{\xe \v makeDogleg\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:makeDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * makeDogleg (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a dogleg on the source end of the {\b TrackSegment}. Put the dogleg axis on the source {\b To be further reviewed} .\par
{\b See also:} \~ {\b Dogleg management}.\par
Post-processing done by {\b TrackSegment::_postDoglegs()}. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by SegmentFsm::conflictSolveByHistory(), Manipulator::makeDogleg(), TrackElement::makeDogleg(), and Manipulator::relax().}\par
}
{\xe \v makeDogleg\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:makeDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * makeDogleg ({\b Katabatic::GCell} *  {\i gcell}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b AutoSegment::makeDogleg()}, {\b Dogleg management}.\par
Post-processing done by {\b TrackSegment::_postDoglegs()}. \par
}}
{\xe \v makeDogleg\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:makeDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * makeDogleg ({\b Interval}  {\i interval}, unsigned int &  {\i flags}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b AutoSegment::makeDogleg()}, {\b Dogleg management}, the return flags from this method are returned through the {\f2 flags}  variable.\par
Post-processing done by {\b TrackSegment::_postDoglegs()}. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v _check\:Kite::TrackElement}
{\xe \v Kite::TrackElement\:_check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool _check () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check the coherency of the element. For a {\b TrackSegment}:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The supporting AutoSegment the canonical one of the set.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The cached {\f2 min}  & {\f2 max}  values are identical to the computed ones.\par}
{\b Returns:}  {\b true}  on success. \par
}{
Reimplemented in {\b TrackSegment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
TrackElement.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
TrackElement.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
TrackElement.dox\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
TrackSegment.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TrackFixedSegment Class Reference\par \pard\plain 
{\tc\tcl2 \v TrackFixedSegment}
{\xe \v TrackFixedSegment}
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Track} elements for fixed wires. }}\par
Inheritance diagram for TrackFixedSegment:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKite_1_1TrackFixedSegment__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isHorizontal} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isVertical} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isFixed} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned long {\b getId} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b getDirection} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Net} * {\b getNet} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const {\b Layer} * {\b getLayer} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b TrackElement} * {\b getNext} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b TrackElement} * {\b getPrevious} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b DbU::Unit} {\b getAxis} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Interval} {\b getFreeInterval} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b TrackElement} * {\b create} ({\b Kite::Track} *track, {\b Segment} *segment)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Track} elements for fixed wires. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A {\b TrackFixedSegment} is a segment that cannot be moved from the track. It can be associated to a true blockage Segment (recognised by the fact that their owner net is the {\i blockage}  net), or to a segment from an ordinary net but which is locked into position. In the latter case, the owned net may reuse this portion of the track if it needs it.\par
In all cases, the blockage ratio of the GCells underneath the segment are updated. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v create\:Kite::TrackFixedSegment}
{\xe \v Kite::TrackFixedSegment\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackSegment} * create ({\b Kite::Track} *  {\i track}, {\b Segment} *  {\i segment}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i segment} \cell }{The Hurricane Segment (blockage) to take into account. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i track} \cell }{A {\b Track} into which insert the {\b TrackFixedSegment}. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A {\b TrackFixedSegment} wrapped around a blockage Segment.\par
}Public constructor to insert blockage inside a {\b Track}. \par
}}
{\xe \v isHorizontal\:Kite::TrackFixedSegment}
{\xe \v Kite::TrackFixedSegment\:isHorizontal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isHorizontal () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b Katabatic::AutoSegment::isHorizontal()}. \par
}{
Implements {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v isVertical\:Kite::TrackFixedSegment}
{\xe \v Kite::TrackFixedSegment\:isVertical}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isVertical () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b Katabatic::AutoSegment::isVertical()}. \par
}{
Implements {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v isFixed\:Kite::TrackFixedSegment}
{\xe \v Kite::TrackFixedSegment\:isFixed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isFixed () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b Katabatic::AutoSegment::isFixed()}. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getId\:Kite::TrackFixedSegment}
{\xe \v Kite::TrackFixedSegment\:getId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long getId () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The {\f2 Id}  of the supporting AutoSegment, if there is any. {\i Zero}  otherwise. \par
}}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getDirection\:Kite::TrackFixedSegment}
{\xe \v Kite::TrackFixedSegment\:getDirection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getDirection () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The direction of the supporting element (should match the preferred direction of the {\b Track}). \par
}}{
Implements {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAART \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getNet\:Kite::TrackFixedSegment}
{\xe \v Kite::TrackFixedSegment\:getNet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Net} * getNet () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The Net associated to the element (may be {\f2 NULL} ). \par
}{
Implements {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by TrackFixedSegment::getNext(), and TrackFixedSegment::getPrevious().}\par
}
{\xe \v getLayer\:Kite::TrackFixedSegment}
{\xe \v Kite::TrackFixedSegment\:getLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Layer} * getLayer () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The Layer of the element (should match the one of the {\b Track}). \par
}{
Implements {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getNext\:Kite::TrackFixedSegment}
{\xe \v Kite::TrackFixedSegment\:getNext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * getNext () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The next {\b TrackElement}, on the same track and of a {\i different}  net. {\b See also:} \~ {\b Track::getNext()}. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getPrevious\:Kite::TrackFixedSegment}
{\xe \v Kite::TrackFixedSegment\:getPrevious}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * getPrevious () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The previous {\b TrackElement}, on the same track and of a {\i different}  net. {\b See also:} \~ {\b Track::getPrevious()}. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getAxis\:Kite::TrackFixedSegment}
{\xe \v Kite::TrackFixedSegment\:getAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getAxis () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The axis position of the element (must be the same as the {\b Track}). \par
}{
Implements {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getFreeInterval\:Kite::TrackFixedSegment}
{\xe \v Kite::TrackFixedSegment\:getFreeInterval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getFreeInterval () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The greatest free interval enclosing this element. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
TrackFixedSegment.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
TrackFixedSegment.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
TrackFixedSegment.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TrackMarker Class Reference\par \pard\plain 
{\tc\tcl2 \v TrackMarker}
{\xe \v TrackMarker}
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tag part of {\b Track} with a weight. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Net} * {\b getNet} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getSourceU} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DbU::Unit} {\b getTargetU} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Track} * {\b getTrack} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getWeight} (const {\b Track} *) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTrack} ({\b Track} *)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b TrackMarker} * {\b create} ({\b RoutingPad} *, size_t depth)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tag part of {\b Track} with a weight. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TrackMarkers are used to assign a cost on a span of {\b Track} telling how strongly a terminal is dependant on that {\b Track} to be accessed. The more {\b Track} a terminal crosses, the less the weight is.\par
The weight is expressed in hundreth (can also be understood as percentage) of dependency over the {\b Track}. As example, if a terminal can only be accessed trough one {\b Track} is weight on it will be {\f2 100} . \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v create\:Kite::TrackMarker}
{\xe \v Kite::TrackMarker\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
create ({\b RoutingPad} *  {\i rp}, size_t  {\i depth}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rp} \cell }{The RoutingPad to be accessed. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i depth} \cell }{Select the layer depth by which we want to access the RoutingPad. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The newly created {\b TrackMarker}.\par
}This constructor automatically take care of inserting the {\b TrackMarker} in the relevant Tracks, so it must be called during a {\b Session}. \par
}}
{\xe \v getNet\:Kite::TrackMarker}
{\xe \v Kite::TrackMarker\:getNet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Net} * getNet () const}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The net of the RoutingPad. \par
}}
{\xe \v getSourceU\:Kite::TrackMarker}
{\xe \v Kite::TrackMarker\:getSourceU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getSourceU () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The span minimum bound. \par
}}
{\xe \v getTargetU\:Kite::TrackMarker}
{\xe \v Kite::TrackMarker\:getTargetU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getTargetU () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The span maximum bound. \par
}}
{\xe \v getTrack\:Kite::TrackMarker}
{\xe \v Kite::TrackMarker\:getTrack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Track} * getTrack () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b Track} into which the marker is inserted. \par
}}
{\xe \v getWeight\:Kite::TrackMarker}
{\xe \v Kite::TrackMarker\:getWeight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getWeight (const {\b Track} *  {\i track}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The associated weight, for now the {\b Track} argument is ignored. \par
}}
{\xe \v setTrack\:Kite::TrackMarker}
{\xe \v Kite::TrackMarker\:setTrack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setTrack ({\b Track} *  {\i track}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the owning {\b Track}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
TrackMarker.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
TrackMarker.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
TrackMarker.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TrackSegment Class Reference\par \pard\plain 
{\tc\tcl2 \v TrackSegment}
{\xe \v TrackSegment}
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Derived {\b Katabatic::AutoSegment} for the router. }}\par
Inheritance diagram for TrackSegment:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKite_1_1TrackSegment__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isFixed} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isHorizontal} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isVertical} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isLocal} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isGlobal} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isBipoint} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isTerminal} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isStrap} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isSlackened} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isDogleg} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canDogleg} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canDogleg} ({\b Interval})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canDogleg} ({\b Katabatic::GCell} *, unsigned int flags=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual float {\b getMaxUnderDensity} (unsigned int flags) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned long {\b getId} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b getDirection} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Net} * {\b getNet} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const {\b Layer} * {\b getLayer} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned long {\b getFreedomDegree} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b getDoglegLevel} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b TrackElement} * {\b getNext} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b TrackElement} * {\b getPrevious} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b TrackElement} * {\b getParent} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b DbU::Unit} {\b getAxis} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Interval} {\b getFreeInterval} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Interval} {\b getSourceConstraints} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Interval} {\b getTargetConstraints} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b DataNegociate} * {\b getDataNegociate} (unsigned int flags={\b KtDataSelf}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b TrackElement} * {\b getCanonical} ({\b Interval} &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual size_t {\b getGCells} (Katabatic::GCellVector &) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b TrackElement} * {\b getSourceDogleg} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b TrackElement} * {\b getTargetDogleg} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual TrackElements {\b getPerpandiculars} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b setTrack} ({\b Track} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateFreedomDegree} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b setDoglegLevel} (unsigned int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b swapTrack} ({\b TrackElement} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b reschedule} (unsigned int level)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b detach} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b invalidate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b revalidate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b setAxis} ({\b DbU::Unit}, unsigned int flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b TrackElement} * {\b makeDogleg} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b TrackElement} * {\b makeDogleg} ({\b Interval}, unsigned int &flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b _postDoglegs} ({\b TrackElement} *&perpandicular, {\b TrackElement} *&parallel)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b _check} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b TrackElement} * {\b create} ({\b AutoSegment} *, {\b Track} *, bool &created)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Derived {\b Katabatic::AutoSegment} for the router. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
 We create one {\b TrackSegment} per aligned {\b Katabatic::AutoSegment} set, the {\b TrackSegment} is associated to the canonical one of the set.\par
To provide some speedup, the full extention of the aligned segment set is computed once and stored in the {\b TrackSegment} itself. The drawback beeing that whenever one segment from the aligned set has it's extention modified, the full extention must be recomputed.\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lazy Revalidate
\par}
{\tc\tcl2 \v Lazy Revalidate}
When the {\b TrackSegment::revalidate()} method is called, it only update the cached size of the segment (from the AutoSegment set of aligneds) and the track into which it may be inserted.\par
The associated {\b DataNegociate} and {\b RoutingEvent} are {\b not}  updated.{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The {\b RoutingEvent} will be updated when it's key is updated, typically during a requeueing operation {\b and}  in the {\b SegmentFsm} constructor. This should be optimized in the future.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The {\b DataNegociate} is updated {\i only}  in the {\b SegmentFsm} constructor. This is the most costly of the two updates as it perform a perpandicular & parallel connexity exploration.\par}
\par}
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Dogleg Management
\par}
{\tc\tcl2 \v Dogleg Management}
The basic {\b AutoSegment::canDogleg()} method is declined in three more dedicated methods in this class:{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TrackSegment::canDogleg()}, for locals only, check if a break is possible, never break a segment more than once (to avoid fragmentation).\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TrackSegment::canDogleg(Katabatic::GCell*,unsigned int flags)} for globals, check that the segment is breakable in the desired GCell. Never break twice in the first/last GCell (fragmentation limitation), but may {\i reuse}  an already existing dogleg.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TrackSegment::canDogleg(Interval)}, for locals only, direct proxy for the AutoSegment method. Never allow more than one break.\par}
{\b Relationship between AutoSegment and {\b TrackSegment}} \par
Figure 2 below, shows an example of dogleg creation:{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
At the Katabatic level, AutoSegment {\f2 id:12}  is broken. Thus the creation of AutoSegments {\f2 id:20}  and {\f2 id:21} . The orignal {\b TrackSegment} (canonical AutoSegment {\f2 id:10} ) remains on the right side (target) of the break.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
But, because the canonical of the former aligned AutoSegment set {\f2 } (10,11,12,13,14) was on the {\i right}  side of the break, the new parallel {\b TrackSegment} will be created on the {\f2 left}  side, associated to the newly promoted canonical AutoSegment {\f2 id:12} .\par}
 The {\b TrackSegment::_postDoglegs()} method called by all flavors of {\b TrackSegment::makeDogleg()} methods is responsible for creating new TrackSegments for the new doglegs (there may be more than one), it also update the dogleg level and source/target dogleg flags.\par
{\b This section is not finished.}  I need to review the parent and doglevel numbering management. There seems to be a risk of infinite fragmentation as the numbering of the original segment is not increased, we should create a {\i break}  counter separate from deepness.\par}
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Global, Weak Global and Local Segments
\par}
{\tc\tcl2 \v Global, Weak Global and Local Segments}
There's a slight semantic change between Katabatic and {\b Kite} about what is local and what is local. This is due to how we consider the intermediate status of {\i WeakGlobal} .\par
A {\f2 WeakGlobal}  segment is a local segment which is aligned with a global (though a VTee or an HTee contact).\par
In Katabatic a local segment is one that is not {\f2 Global} , a local segment can be both {\f2 Local}  and {\f2 WeakGlobal} .\par
In {\b Kite} a local segment is one that is neither {\f2 Global}  or {\f2 WeakGlobal} . The {\f2 WeakGlobal}  sides with {\f2 Global}  unlike in Katabatic. \par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v create\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b TrackSegment} * create ({\b AutoSegment} *  {\i segment}, {\b Track} *  {\i track}, bool &  {\i created}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i segment} \cell }{The Katabatic AutoSegment to decorate. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i track} \cell }{A {\b Track} into which insert the {\b TrackSegment} (may be {\f2 NULL} ). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i created} \cell }{This flag is sets is a new {\b TrackSegment} has be created. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A {\b TrackSegment} wrapped around an AutoSegment.\par
}Constructor mainly used at loading time to decorate the Katabatic data-base with the router attributes. \par
}{
Referenced by NegociateWindow::createTrackSegment().}\par
}
{\xe \v isFixed\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:isFixed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isFixed () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b Katabatic::AutoSegment::isFixed()}. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by TrackSegment::canDogleg().}\par
}
{\xe \v isHorizontal\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:isHorizontal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isHorizontal () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b Katabatic::AutoSegment::isHorizontal()}. \par
}{
Implements {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by TrackSegment::getGCells().}\par
}
{\xe \v isVertical\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:isVertical}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isVertical () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b Katabatic::AutoSegment::isVertical()}. \par
}{
Implements {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v isLocal\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:isLocal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isLocal () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ Katabatic::isLocal(). \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by TrackSegment::_postDoglegs(), and TrackSegment::canDogleg().}\par
}
{\xe \v isGlobal\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:isGlobal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isGlobal () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b Katabatic::AutoSegment::isGlobal()}. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v isBipoint\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:isBipoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isBipoint () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b Katabatic::AutoSegment::isBipoint()}. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v isTerminal\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:isTerminal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isTerminal () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ Katabatic::AutoSegment::isTerminal(). \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v isStrap\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:isStrap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isStrap () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b Katabatic::AutoSegment::isStrap()}. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v isSlackened\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:isSlackened}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isSlackened () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b Katabatic::AutoSegment::isSlackened()}. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by TrackSegment::canDogleg().}\par
}
{\xe \v isDogleg\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:isDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isDogleg () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ Katabatic::isDogleg(). \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v canDogleg\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:canDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool canDogleg (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b AutoSegment::canDogleg()}. At {\b Kite} level, this variant of the method will apply only on local segments and the segment must not already have a source or target dogleg. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v canDogleg\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:canDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool canDogleg ({\b Interval} ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b AutoSegment::canDogleg()}. At {\b Kite} level, this variant of the method will apply only on local segments and the segment must not already have a source or target dogleg. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v canDogleg\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:canDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool canDogleg ({\b Katabatic::GCell} *  {\i doglegGCell}, unsigned int  {\i flags} = {\f2 0}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b AutoSegment::canDogleg()}. At kite level, this variant of the method is mainly targeted to global segment. For local segment it behave like {\b TrackElement::canDogleg(Interval)}. For global segment, make the break in the requested GCell {\f2 doglegGCell} . If it's in the first or last GCell and there is already a dogleg, allow to reuse it if {\f2 flags}  contains {\b Kite::KtAllowDoglegReuse}. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getMaxUnderDensity\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:getMaxUnderDensity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float getMaxUnderDensity (unsigned int  {\i flags}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The maximum density of all the GCells under this element. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getId\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:getId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long getId () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The {\f2 Id}  of the supporting AutoSegment, if there is any. {\i Zero}  otherwise. \par
}}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by TrackSegment::detach().}\par
}
{\xe \v getDirection\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:getDirection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getDirection () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The direction of the supporting element (should match the preferred direction of the {\b Track}). \par
}}{
Implements {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAART \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by TrackSegment::getSourceDogleg(), and TrackSegment::getTargetDogleg().}\par
}
{\xe \v getNet\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:getNet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Net} * getNet () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The Net associated to the element (may be {\f2 NULL} ). \par
}{
Implements {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by TrackSegment::getFreeInterval(), TrackSegment::getNext(), and TrackSegment::getPrevious().}\par
}
{\xe \v getLayer\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:getLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Layer} * getLayer () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The Layer of the element (should match the one of the {\b Track}). \par
}{
Implements {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getFreedomDegree\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:getFreedomDegree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long getFreedomDegree () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The degree of freedom of the element. It is used as a priority value when sorting {\b TrackElement} (in {\b RoutingEvent}).\par
{\b Returns:}  The degree of freedom of the element. It is used as a priority value when sorting {\b TrackElement} (in {\b RoutingEvent}).\par
Currently, it is the {\i slack}  of the {\b Katabatic::AutoSegment}. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getDoglegLevel\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:getDoglegLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getDoglegLevel () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The deepness of the dogleg. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by TrackSegment::canDogleg().}\par
}
{\xe \v getNext\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:getNext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * getNext () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The next {\b TrackElement}, on the same track and of a {\i different}  net. {\b See also:} \~ {\b Track::getNext()}. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getPrevious\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:getPrevious}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * getPrevious () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The previous {\b TrackElement}, on the same track and of a {\i different}  net. {\b See also:} \~ {\b Track::getPrevious()}. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getParent\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:getParent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * getParent () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The {\b TrackElement} from which the dogleg has been created, if any. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by TrackSegment::getDataNegociate().}\par
}
{\xe \v getAxis\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:getAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DbU::Unit} getAxis () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The axis position of the element (must be the same as the {\b Track}). \par
}{
Implements {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getFreeInterval\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:getFreeInterval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getFreeInterval () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The greatest free interval enclosing this element. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getSourceConstraints\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:getSourceConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getSourceConstraints () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b Katabatic::AutoSegment::getSourceConstraints()}. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getTargetConstraints\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:getTargetConstraints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interval} getTargetConstraints () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b Katabatic::AutoSegment::getTargetConstraints()}. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getDataNegociate\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:getDataNegociate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DataNegociate} * getDataNegociate (unsigned int  {\i flags} = {\f2 {\b KtDataSelf}}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The additional data-structure supplied by the routing algorithm. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by TrackSegment::_postDoglegs(), and TrackSegment::swapTrack().}\par
}
{\xe \v getCanonical\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:getCanonical}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * getCanonical ({\b Interval} &  {\i i}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inner working still unclear to myself. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getGCells\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:getGCells}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t getGCells (Katabatic::GCellVector &  {\i gcells}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The table of {\b Katabatic::GCell} underneath the element whole span. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by TrackSegment::canDogleg().}\par
}
{\xe \v getSourceDogleg\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:getSourceDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * getSourceDogleg (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The source part of the segment from which the dogleg has been created. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getTargetDogleg\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:getTargetDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * getTargetDogleg (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The target part of the segment from which the dogleg has been created. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getPerpandiculars\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:getPerpandiculars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TrackElements getPerpandiculars (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  The collection of all element perpandiculars to this one. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v setTrack\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:setTrack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setTrack ({\b Track} *  {\i track}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Insert the element into {\f2 track} , also used as an insertion marker. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by TrackSegment::detach(), and TrackSegment::swapTrack().}\par
}
{\xe \v updateFreedomDegree\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:updateFreedomDegree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void updateFreedomDegree (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update, from the element characteristics, it's degree of freedom. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v setDoglegLevel\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:setDoglegLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setDoglegLevel (unsigned int  {\i level}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the level of dogleg of the element. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v swapTrack\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:swapTrack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void swapTrack ({\b TrackElement} *  {\i other}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Swap the tracks of {\f2 this}  and {\f2 other} . \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v reschedule\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:reschedule}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void reschedule (unsigned int  {\i level}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the {\b TrackElement} has already an event scheduled, change the level of this event, otherwise create a new event.\par
{\b See also:} \~ NegotiateWindow::rescheduleEvent(). \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by TrackSegment::_postDoglegs().}\par
}
{\xe \v detach\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:detach}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void detach (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove the link from the {\b TrackElement} to it's owning {\b Track}, marking it for removal. The removal from the {\b Track}'s vector is managed by the {\b Track} itself during the {\b Session} revalidation stage. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v invalidate\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:invalidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void invalidate (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b AutoSegment::invalidate()}. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by TrackSegment::create(), and TrackSegment::setAxis().}\par
}
{\xe \v revalidate\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:revalidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void revalidate (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Actualize the {\b TrackSegment} characteristics from the supporting elements (set of AutoSegment).\par
This method do not update the {\b DataNegociate} or the {\b RoutingEvent}. This is a lazy update delayed until the constructor of {\b SegmentFsm} is called. (see {\b Lazy Revalidate}). \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v setAxis\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:setAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setAxis ({\b DbU::Unit} , unsigned int  {\i flags}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the axis of the {\b TrackElement}. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v makeDogleg\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:makeDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * makeDogleg (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a dogleg on the source end of the {\b TrackSegment}. Put the dogleg axis on the source {\b To be further reviewed} .\par
{\b See also:} \~ {\b Dogleg management}.\par
Post-processing done by {\b TrackSegment::_postDoglegs()}. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v makeDogleg\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:makeDogleg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackElement} * makeDogleg ({\b Interval}  {\i interval}, unsigned int &  {\i flags}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b See also:} \~ {\b AutoSegment::makeDogleg()}, {\b Dogleg management}, the return flags from this method are returned through the {\f2 flags}  variable.\par
Post-processing done by {\b TrackSegment::_postDoglegs()}. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v _postDoglegs\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:_postDoglegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TrackSegment} * _postDoglegs ({\b TrackElement} *&  {\i perpandicular}, {\b TrackElement} *&  {\i parallel}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Post-process to be called inside the various dogleg creation or slacken methods. Iterate through the newly created AutoSegments to create, for the {\i perpandicular}  and the {\i new parallel}  associateds TrackSegments. Also sets the dogleg levels and flags of the newly created elements.\par
The session dogleg reset is called at the end of this method. The {\f2 perpandicular}  and {\f2 parallel}  references to pointers contains the newly created segments for the {\b last}  dogleg. If more than one was created, you cannot access them (the need has not arised yet). \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by TrackSegment::makeDogleg().}\par
}
{\xe \v _check\:Kite::TrackSegment}
{\xe \v Kite::TrackSegment\:_check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool _check () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check the coherency of the element. For a {\b TrackSegment}:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The supporting AutoSegment the canonical one of the set.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The cached {\f2 min}  & {\f2 max}  values are identical to the computed ones.\par}
{\b Returns:}  {\b true}  on success. \par
}{
Reimplemented from {\b TrackElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
TrackSegment.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
TrackSegment.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
TrackSegment.dox\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
VerticalTrack Class Reference\par \pard\plain 
{\tc\tcl2 \v VerticalTrack}
{\xe \v VerticalTrack}
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vertical track managment. }}\par
Inheritance diagram for VerticalTrack:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classKite_1_1VerticalTrack__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isHorizontal} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isVertical} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b getDirection} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Point} {\b getPosition} ({\b DbU::Unit} coordinate) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vertical track managment. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v isHorizontal\:Kite::VerticalTrack}
{\xe \v Kite::VerticalTrack\:isHorizontal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isHorizontal () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b true}  if the {\b Track} in horizontal direction. \par
}{
Implements {\b Track} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v isVertical\:Kite::VerticalTrack}
{\xe \v Kite::VerticalTrack\:isVertical}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isVertical () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  {\b false} .\par
{\b Returns:}  {\b true} . \par
}{
Implements {\b Track} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getDirection\:Kite::VerticalTrack}
{\xe \v Kite::VerticalTrack\:getDirection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int getDirection () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  Katabatic::KbVertical. \par
}{
Implements {\b Track} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getPosition\:Kite::VerticalTrack}
{\xe \v Kite::VerticalTrack\:getPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Point} getPosition ({\b DbU::Unit}  {\i position}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Returns:}  the point at {\f2 } ({\b getAxis()},position). \par
}{
Implements {\b Track} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
VerticalTrack.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
VerticalTrack.cpp\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
VerticalTrack.dox\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
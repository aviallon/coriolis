<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.0//EN'>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>Hurricane Documentation</title>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link   href="SoC.css" rel="stylesheet" type="text/css">
    <link   href="custom_tabs.css" rel="stylesheet" type="text/css">
  </head>
    <h1 id="pagetop" class="header">Hurricane VLSI Database</h1>
    <!--
    <center class="header">
      <table class="header">
        <tr>
          <td><a href="customSummary.html">Summary</a></td>
          <td><a href="namespaces.html">Namespaces</a></td>
          <td><a href="customHierarchy.html">Class Hierarchy</a></td>
          <td><a href="annotated.html">Classes</a></td>
          <td><a href="functions.html">Member Index</a></td>
        </tr>
      </table>
    </center>
    -->
    <br>
  <body onload="javascript:toggleLevel(1)">
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">JSON Support</div>  </div>
</div><!--header-->
<div class="contents">

<p>JSON Import/Export of the <a class="el" href="classHurricane_1_1DataBase.html" title="The whole DataBase (API).">DataBase</a>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1JsonObject.html">Hurricane::JsonObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for JSON export.  <a href="classHurricane_1_1JsonObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1JsonStack.html">Hurricane::JsonStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">JSON Parser Stack.  <a href="classHurricane_1_1JsonStack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>JSON Import/Export of the <a class="el" href="classHurricane_1_1DataBase.html" title="The whole DataBase (API).">DataBase</a>. </p>
<h1><a class="anchor" id="secJsonSupportIntro"></a>
Introduction</h1>
<p>One key feature of the <a class="el" href="namespaceHurricane.html" title="Contains Almost Everything.">Hurricane</a> <a class="el" href="classHurricane_1_1DataBase.html" title="The whole DataBase (API).">DataBase</a> is it's hierarchical managment. But unfortunatly the simple approach of saving a design <a class="el" href="classHurricane_1_1Cell.html" title="The model (API).">Cell</a> by <a class="el" href="classHurricane_1_1Cell.html" title="The model (API).">Cell</a>, hierarchical level by hierarchical level makes it very difficult to save the trans-hierarchical informations (mainly is the occurrences)</p>
<p>One solution is to save the design and all it's levels, down and including the standard cells. With all the levels saved, we then can add the occurrences and all the attached trans-hierarchical informations. We call that comprehensive saving of a design, a <em>design blob</em>.</p>
<p>Instead of creating one more ad-hoc format, we just dump the <a class="el" href="classHurricane_1_1DataBase.html" title="The whole DataBase (API).">DataBase</a> objects in a mirror like way in JSON format.</p>
<p>As it is a textual format, the generated files are larges. So the files are compressed through <code>gzip</code>.</p>
<h1><a class="anchor" id="secJsonSemantic"></a>
JSON Additional Semantic</h1>
<p>To ease the work of the parser, some semantic has been added to the JSON objects representing a <a class="el" href="namespaceHurricane.html" title="Contains Almost Everything.">Hurricane</a> <a class="el" href="classHurricane_1_1DataBase.html" title="The whole DataBase (API).">DataBase</a>.</p><ol type="1">
<li>The first key/value pair must have the key <code>"@typename"</code> and give the kind of <a class="el" href="classHurricane_1_1JsonObject.html" title="Support for JSON export.">JsonObject</a> associated. The value is the string returned by <code><a class="el" href="classHurricane_1_1JsonObject.html#a947e1c3f8dbae63bb2d086b5b827a2a5">JsonObject::getTypeName()</a></code>.</li>
<li>Attributes keys must start by a <code>'_'</code> character. (yes, I know, the C++ convention has changed and it should be put at the end).</li>
<li>Collections or containers must be put <em>after</em> all the scalar attributes and their keys must start by a <code>'+'</code> character.</li>
</ol>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;@typename&quot;: &quot;Cell&quot;,</div>
<div class="line">  &quot;_id&quot;: 3,</div>
<div class="line">  &quot;_library&quot;: &quot;RootLibrary.AllianceFramework.sxlib&quot;,</div>
<div class="line">  &quot;_name&quot;: &quot;o3_x2&quot;,</div>
<div class="line">  &quot;_abutmentBox&quot;: {</div>
<div class="line">    &quot;@typename&quot;: &quot;Box&quot;,</div>
<div class="line">    &quot;_xMin&quot;: 0,</div>
<div class="line">    &quot;_yMin&quot;: 0,</div>
<div class="line">    &quot;_xMax&quot;: 72000,</div>
<div class="line">    &quot;_yMax&quot;: 120000</div>
<div class="line">  },</div>
<div class="line">  &quot;+instanceMap&quot;: [],</div>
<div class="line">  &quot;+netMap&quot;: [</div>
<div class="line">  ],</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="secJsonDriver"></a>
JSON Driver Support</h1>
<p>The driver is implemented through overloads (template and non-template) of the <code>jsonWriter()</code> function. For the template overload to work, even for non-Hurricane classes, it is defined outside the <a class="el" href="namespaceHurricane.html" title="Contains Almost Everything.">Hurricane</a> namespace.</p>
<p>For POD types, four overloads of <code>jsonWriter()</code> are defined:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span>  jsonWrite ( JsonWriter* w, <span class="keyword">const</span> <span class="keywordtype">int</span>* v );</div>
<div class="line"><span class="keywordtype">void</span>  jsonWrite ( JsonWriter* w,       <span class="keywordtype">int</span>  v );</div>
<div class="line"><span class="keywordtype">void</span>  jsonWrite ( JsonWriter* w, <span class="keyword">const</span> std::string&amp; key, <span class="keyword">const</span> <span class="keywordtype">int</span>* value )</div>
<div class="line"><span class="keywordtype">void</span>  jsonWrite ( JsonWriter* w, <span class="keyword">const</span> std::string&amp; key,       <span class="keywordtype">int</span>  value )</div>
</div><!-- fragment --><p>The first two writes the object (here: <code>int</code>) "as is" while the two later writes a pair key/object.</p>
<p>For other class/object that needs to be writen in the JSON file, they must provide a <code>toJson()</code> function. It doesn't even need to be virtual. For <a class="el" href="classHurricane_1_1Point.html" title="Point description (API)">Point</a>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span>  Point::toJson ( JsonWriter* w )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  w-&gt;startObject();</div>
<div class="line">  jsonWrite( w, <span class="stringliteral">&quot;@typename&quot;</span>, <span class="stringliteral">&quot;Point&quot;</span> );</div>
<div class="line">  jsonWrite( w, <span class="stringliteral">&quot;_x&quot;</span>, getX() );</div>
<div class="line">  jsonWrite( w, <span class="stringliteral">&quot;_y&quot;</span>, getY() );</div>
<div class="line">  w-&gt;endObject();</div>
<div class="line">}</div>
</div><!-- fragment --><p>This function allows three templates of <code>jsonWrite()</code> to be used with an object of class <a class="el" href="classHurricane_1_1Point.html" title="Point description (API)">Point</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</div>
<div class="line"><span class="keywordtype">void</span>  jsonWrite ( JsonWriter* w, <span class="keyword">const</span> C* <span class="keywordtype">object</span> );</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</div>
<div class="line"><span class="keywordtype">void</span>  jsonWrite ( JsonWriter* w, <span class="keyword">const</span> std::string&amp; key, C* <span class="keywordtype">object</span> );</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</div>
<div class="line"><span class="keywordtype">void</span>  jsonWrite ( JsonWriter* w, <span class="keyword">const</span> std::string&amp; key, <span class="keyword">const</span> C* <span class="keywordtype">object</span> );</div>
</div><!-- fragment --><p>Note that through those three overloads we only provides support for pointers to object. The driving mechanism is designed in such a way that passing arguments by value is not supported for non-POD types. Trying to do so will result in an unsupported message inside the generated JSON file.</p>
<h2><a class="anchor" id="secJsonDriverDBo"></a>
DBos Special Case</h2>
<p>For <a class="el" href="classHurricane_1_1DBo.html" title="DataBase object root class (API).">DBo</a> objects, a complete parallel hierarchy of JsonObjects mimicking the one of DBos has been implemented. The <code>toJson()</code> function is implemented in the <a class="el" href="classHurricane_1_1DBo.html" title="DataBase object root class (API).">DBo</a> base object, and the derived classes must implement the following virtual functions:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>DBo {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span>  _toJson            ( JsonWriter* ) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span>  _toJsonCollections ( JsonWriter* ) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span>  _toJsonSignature   ( JsonWriter* ) <span class="keyword">const</span>;</div>
<div class="line">            <span class="keywordtype">void</span>  toJson             ( JsonWriter* ) <span class="keyword">const</span>;</div>
<div class="line">            <span class="keywordtype">void</span>  toJsonSignature    ( JsonWriter* ) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>The JSON driver functions is splitted in two parts:</p><ul>
<li><code>_toJson()</code> must drive the scalar attributes.</li>
<li><code>_toJsonCollections()</code> must drive the various collections or containers. This is to ensure that all the scalars attributes are put before the collections, event through inheritance.</li>
</ul>
<p>The additionnal <code>toJsonSignature()</code> method provide the signature for an <a class="el" href="classHurricane_1_1Entity.html" title="Occurrenceable objects root class (API).">Entity</a> which is used by an occurrence. The signature of an occurrence is needed when we create a JSON for a <a class="el" href="classHurricane_1_1Cell.html" title="The model (API).">Cell</a> only. In that case we cannot directly save the transhierarchical informations, so we need a way to characterize the deep <a class="el" href="classHurricane_1_1Entity.html" title="Occurrenceable objects root class (API).">Entity</a> (which is not part of the saved <a class="el" href="classHurricane_1_1Cell.html" title="The model (API).">Cell</a>). Most of the time, the signature is the scalar attributes of the occurrenced object, it is far from foolproof, but it will do for now.</p>
<h1><a class="anchor" id="secJsonParser"></a>
JSON Parser Support</h1>
<p>To enable JSON parsing support for an object, say <a class="el" href="classHurricane_1_1Point.html" title="Point description (API)">Point</a>, an associated <code>JsonPoint</code> class must be created. This class must be derived (directly or not) from <a class="el" href="classHurricane_1_1JsonObject.html" title="Support for JSON export.">JsonObject</a>. It must implement one static functions and four methods, as shown below.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>JsonPoint : <span class="keyword">public</span> JsonObject {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span>  <span class="keywordtype">void</span>       initialize ();</div>
<div class="line">                       JsonPoint  (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">string</span>     getTypeName() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keyword">virtual</span> JsonPoint* clone      (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span>       toData     (JsonStack&amp;);</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>initialize()</code> static function must be present in concrete class only. It is used to register the Json object into the parser during the static initialization of the program.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;hurricane/Initializer.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;hurricane/Point.h&quot;</span></div>
<div class="line"> </div>
<div class="line">Initializer&lt;JsonPoint&gt;  jsonPointInit ( 0 );</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span>  JsonPoint::initialize ()</div>
<div class="line">{ JsonTypes::registerType( <span class="keyword">new</span> JsonPoint (JsonWriter::RegisterMode) ); }</div>
</div><!-- fragment --><p>The constructor has to declare requirements, attributes, and collections needed to build the <a class="el" href="classHurricane_1_1DataBase.html" title="The whole DataBase (API).">DataBase</a> object. Note the the requirements are not part of the objects but only needed to build it.</p>
<div class="fragment"><div class="line">JsonPoint::JsonPoint ( <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags )</div>
<div class="line">  : JsonObject(flags)</div>
<div class="line">{</div>
<div class="line">  add( <span class="stringliteral">&quot;_x&quot;</span>, <span class="keyword">typeid</span>(int64_t) );</div>
<div class="line">  add( <span class="stringliteral">&quot;_y&quot;</span>, <span class="keyword">typeid</span>(int64_t) );</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>getTypeName()</code> virtual function must return the typename used for the <code>"@typename"</code> key in the JSON file. Most of the time it's the same name as the object itself, but not always.</p>
<div class="fragment"><div class="line"><span class="keywordtype">string</span> JsonPoint::getTypeName ()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;Point&quot;</span>; }</div>
</div><!-- fragment --><p>The <code>clone()</code> virtual function must return a brand new Json object of the same type. The datas of the orignal object <b>must</b> not be copied. The cloning is about the class type, not the contents.</p>
<div class="fragment"><div class="line">JsonPoint* JsonPoint::clone ( <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> JsonPoint ( flags ); }</div>
</div><!-- fragment --><p>The <code>toData()</code> virtual function actually gather the attributes to recreate the <a class="el" href="classHurricane_1_1DataBase.html" title="The whole DataBase (API).">DataBase</a> object. It needs the parser stack to pull the attributes and to push the created object.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> JsonPoint::toData ( JsonStack&amp; stack )</div>
<div class="line">{</div>
<div class="line">  check( stack, <span class="stringliteral">&quot;JsonPoint::toData&quot;</span> );</div>
<div class="line">  Point point ( <a class="code" href="classHurricane_1_1DbU.html#aec69d65ec1651c2feea24c5931f4580b">DbU::fromDb</a>(get&lt;int64_t&gt;(stack,<span class="stringliteral">&quot;_x&quot;</span>))</div>
<div class="line">              , <a class="code" href="classHurricane_1_1DbU.html#aec69d65ec1651c2feea24c5931f4580b">DbU::fromDb</a>(get&lt;int64_t&gt;(stack,<span class="stringliteral">&quot;_y&quot;</span>)) );</div>
<div class="line">  update( stack, point );</div>
<div class="line">}</div>
<div class="ttc" id="aclassHurricane_1_1DbU_html_aec69d65ec1651c2feea24c5931f4580b"><div class="ttname"><a href="classHurricane_1_1DbU.html#aec69d65ec1651c2feea24c5931f4580b">Hurricane::DbU::fromDb</a></div><div class="ttdeci">static Unit fromDb(Unit value)</div><div class="ttdef"><b>Definition:</b> DbU.h:163</div></div>
</div><!-- fragment --><h2><a class="anchor" id="secJsonArray"></a>
JSON Array</h2>
<p>JSON array are not translated into containers of any kind. They are simply ignored (from the stack point of view). Objects in array comes from a great variety of containers including <a class="el" href="classHurricane_1_1Collection.html" title="Collection description (API)">Hurricane::Collection</a>, in almost all cases, their very constructors are responsibles for inserting the object in the relevant container/collection. So there is no need to build a mechanism to keep track of all the objects in an array through a temporary container.</p>
<p>The corollary is that an object in an array must be able to extract the relevant context information from the stack. Say, if we are in an array of components, they must belong to a <a class="el" href="classHurricane_1_1Net.html" title="Net description (API)">Net</a>, which must be present in the stack with a key ".Net".</p>
<h2><a class="anchor" id="secJsonStack"></a>
Parser Stack</h2>
<p>While performing the parsing, the parser maintain a stack (<a class="el" href="classHurricane_1_1JsonStack.html" title="JSON Parser Stack.">JsonStack</a>) containing:</p><ul>
<li>The stack of attributes translateds, but not consumeds by the parser and the objects currently openeds (that is, which parsing is not completed). This stack contains POD or <a class="el" href="namespaceHurricane.html" title="Contains Almost Everything.">Hurricane</a> objects (value or pointer). It is a vector of pair <code></code>(key,value) where the <em>key</em> is either the attribute name (<code>_boundingBox</code>, <code>_xMin</code>, <code>_masterCell</code>, ...) or the class name (<code></code>.<a class="el" href="classHurricane_1_1Net.html" title="Net description (API)">Net</a>, <code></code>.<a class="el" href="classHurricane_1_1Cell.html" title="The model (API).">Cell</a>, ...).</li>
<li>The stack of JSON objects currently openeds, thoses objects are all derived classes of <a class="el" href="classHurricane_1_1JsonObject.html" title="Support for JSON export.">JsonObject</a>.</li>
<li>A stack of currently opened DBo*. This stack is somewhat redundant with the first, but is needed because <code>boost::any_cast&lt;&gt;</code> is not able to perform dynamic conversions. You have to know the exact for the conversion to work. Here, everything is DBo*, so the problem do not arises.</li>
</ul>
<h2><a class="anchor" id="secJsonCycle"></a>
JsonObject Life Cycle</h2>
<div class="fragment"><div class="line">{                          # JsonDummy()  (1).</div>
<div class="line">  &quot;_typename&quot;: &quot;Net&quot;,      # JsonNet()  CTOR (2).</div>
<div class="line">  &quot;_id&quot;: 14622,</div>
<div class="line">  &quot;_name&quot;: &quot;saccu(0)&quot;,</div>
<div class="line">  &quot;_isGlobal&quot;: false,</div>
<div class="line">  &quot;_isExternal&quot;: false,</div>
<div class="line">  &quot;_isAutomatic&quot;: false,</div>
<div class="line">  &quot;_type&quot;: &quot;LOGICAL&quot;,</div>
<div class="line">  &quot;_direction&quot;: &quot;---- (UNDEFINED)&quot;,</div>
<div class="line">  &quot;+aliases&quot;: [],          # JsonNet::toData()  (3).</div>
<div class="line">  &quot;+componentSet&quot;: [</div>
<div class="line">    {</div>
<div class="line">      &quot;@typename&quot;: &quot;RoutingPad&quot;,</div>
<div class="line">      &quot;_id&quot;: 27410,</div>
<div class="line">      &quot;_bodyHook&quot;: &quot;Contact::AnchorHook.46566&quot;,</div>
<div class="line">      &quot;_occurrence&quot;: {</div>
<div class="line">        &quot;@typename&quot;: &quot;Occurrence&quot;,</div>
<div class="line">        &quot;_path&quot;: &quot;14720.14976&quot;,</div>
<div class="line">        &quot;_entity&quot;: 3888</div>
<div class="line">      },</div>
<div class="line">      &quot;+propertySet&quot;: []</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      &quot;@typename&quot;: &quot;RoutingPad&quot;,</div>
<div class="line">      &quot;_id&quot;: 27409,</div>
<div class="line">      &quot;_bodyHook&quot;: &quot;Contact::AnchorHook.46574&quot;,</div>
<div class="line">      &quot;_occurrence&quot;: {</div>
<div class="line">        &quot;@typename&quot;: &quot;Occurrence&quot;,</div>
<div class="line">        &quot;_path&quot;: &quot;14654.18564&quot;,</div>
<div class="line">        &quot;_entity&quot;: 4529</div>
<div class="line">      },</div>
<div class="line">      &quot;+propertySet&quot;: []</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}                          # ~JsonNet()  DTOR (4). </div>
</div><!-- fragment --><p>At <code></code>(1) , before <code>_typename</code> is encountered, we know that a new object is about to be created, but do not know what is type will be. So we push on top of the stack a <code>JsonDummy</code>.</p>
<p>At <code></code>(2) , the <code>_typename</code> allows us to create the right kind of <a class="el" href="classHurricane_1_1JsonObject.html" title="Support for JSON export.">JsonObject</a>, which will <em>replace</em> the <code>JsonDummy</code> on top of the stack.</p>
<p>At <code></code>(3) , a first non-POD attribute of JsonNet is encountered. This triggers the call to <code><a class="el" href="classHurricane_1_1JsonObject.html#a57a845ca64ac8912b35c4dbf75723af6">JsonObject::toData()</a></code>, which creates the <a class="el" href="namespaceHurricane.html" title="Contains Almost Everything.">Hurricane</a> object <a class="el" href="classHurricane_1_1Net.html" title="Net description (API)">Net</a>, and put it back on the attribute stack with the key <code>".Net"</code> (because it is <em>not</em> an attribute).</p>
<p>At <code></code>(4) , the Json parser knows that the current <a class="el" href="classHurricane_1_1JsonObject.html" title="Support for JSON export.">JsonObject</a> is finished, so it removes JsonNet from the stack and destroy it.</p>
<p>So, if you need to perform specific post-processing that can only take place <code>after</code> the object and all it's sub-objects has been fully parsed, you may do it in the destructor of the <a class="el" href="classHurricane_1_1JsonObject.html" title="Support for JSON export.">JsonObject</a>. For example, this technique is used to rebuild the rings of a <a class="el" href="classHurricane_1_1Net.html" title="Net description (API)">Net</a>. </p>
</div><!-- contents -->
    <br>
    <hr>
    <table class="footer1">
      <tr>
        <td class="LFooter"><small>Generated by doxygen 1.9.1 on Tue Dec 5 2023</small></td>
        <td class="RFooter"><a href='#pagetop'><small>Return to top of page</small></a></td>
      </tr>
    </table>
    <table class="footer2">
      <tr>
        <td class="LFooter">Hurricane VLSI Database</td>
        <td class="RFooter"><small>Copyright &#169; 2000-2020 Bull S.A. All rights reserved</small></td>
      </tr>
    </table>
  </body>
</html>

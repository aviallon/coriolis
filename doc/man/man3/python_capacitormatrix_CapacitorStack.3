.TH "CapacitorStack" 3 "Tue Jan 30 2024" "Version 0.0.0a1" "Oroshi - Analog Devices Layout" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CapacitorStack \- Draws the layout of a compact capacitor or a matrix of adjacent identical capacitors\&.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBCapacitorUnit\fP\&.
.PP
Inherited by \fBVerticalRoutingTracks\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "def \fB__init__\fP (self, device, capacitance, capacitorType, abutmentBoxPosition, nets, unitCap=0, matrixDim=[1, 1], matchingMode=False, matchingScheme=[], dummyRing=False, dummyElement=False)"
.br
.RI "This is the class constructor\&. "
.ti -1c
.RI "def \fBsetRules\fP (self)"
.br
.RI "Selects technological rules according to the capacitor type\&. "
.ti -1c
.RI "def \fB__isUnitCap__\fP (self)"
.br
.ti -1c
.RI "def \fB__isMatchingSchemeOK__\fP (self)"
.br
.ti -1c
.RI "def \fBcapacitorIdOccurence\fP (self, capacitorIdentifier)"
.br
.ti -1c
.RI "def \fBcreate\fP (self, bbMode=False)"
.br
.RI "Draw the compact or matrix of capacitors\&. "
.ti -1c
.RI "def \fBcapacitorLine\fP (self, dy, abutmentBox_spacing, matchingSchemeRowIndex=0)"
.br
.RI "Iteratively draws a horizontal or vertical line of capacitors according to the \fCdirection\fP parameter\&. "
.ti -1c
.RI "def \fBcapacitorMatrix\fP (self, abutmentBox_spacing=0)"
.br
.RI "Draws a matrix of identical capacitors\&. "
.ti -1c
.RI "def \fBdrawAbutmentBox\fP (self, abutmentBox_spacing=0)"
.br
.RI "Draws the abutment box of the matrix or campact capacitor\&. "
.ti -1c
.RI "def \fBdrawBottomPlatesRLayers\fP (self, bottomPlateRLayer, drawnCapacitor)"
.br
.RI "Draws the routing layers connecting the bottom plate in the matrix of capacitors\&. "
.ti -1c
.RI "def \fBdrawTopPlatesRLayers\fP (self, topPlateRLayer, drawnCapacitor)"
.br
.RI "Draws the routing layers connecting the top plates in the matrix of capacitors\&. "
.ti -1c
.RI "def \fBgetVerticalRoutingTrack_width\fP (self)"
.br
.ti -1c
.RI "def \fBgetMatrixDim\fP (self)"
.br
.ti -1c
.RI "def \fBgetMatchingScheme\fP (self)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Draws the layout of a compact capacitor or a matrix of adjacent identical capacitors\&. 

The matrix can be composed of one type of capacitors, either Poly-Poly or Metal-Metal in 350 nm AMS CMOS technology\&. When matching mode is off, every adjacent plates of any consecutive elementary capacitors are connected to each other using vertical routing layers\&. Otherwise, when matching mode is on, any of elementary capacitors can belong to, $ C_1 $ or $ C_2 $ according to the entered matching scheme\&. Thus, routing is not done in this class\&. In both modes, the complete routing process is done using the \fCRoutCapacitor\fP class\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "def __init__ ( self,  device,  capacitance,  capacitorType,  abutmentBoxPosition,  nets,  unitCap = \fC0\fP,  matrixDim = \fC[1,1]\fP,  matchingMode = \fCFalse\fP,  matchingScheme = \fC[]\fP,  dummyRing = \fCFalse\fP,  dummyElement = \fCFalse\fP)"

.PP
This is the class constructor\&. Basically, the class there are three categories of attributes\&. There are the ones related to the capacitor caracteristics, its type, dimensions\&. Also, there are attributes to parametrize the class into matching mode or not and there are other attributes realted to the layout varibales\&. The class has defaut input values, thus, in this constructor, there are two 'sub-constructors' according to the entered input parameters\&. The class attributes are :
.PP
\fBParameters\fP
.RS 4
\fIdevice\fP The \fBHurricane\fP AMS device into which the layout is drawn\&. 
.br
\fIcapacitance\fP The value of the capacitor, expressed in femto Farad (fF)\&. 
.br
\fIcapacitorType\fP Can be MIM or PIP type capacitor\&. 
.br
\fIabutmentPosition\fP Refers to the abscissa (XMin) of the bottom left corner of the abutment Box\&. 
.br
\fIabutmentBoxYMin\fP Refers to the ordinate (YMin) of the bottom left corner of the abutment Box\&.
.RE
.PP
Except the two last arguments, all the parameters are common with the CapacitorUnit class because the \fC\fBCapacitorStack\fP\fP constructor calls the mother class constructor to create either a compact capacitor of \fCcapacitance\fP value or \fCrowNumber*\fP \fCcolumnNumber\fP unity capacitors\&.
.PP
\fBParameters\fP
.RS 4
\fIrowNumber\fP Number of rows in the matrix of capacitors\&. 
.br
\fIcolumnNumber\fP Number of columns in the matrix of capacitors\&. 
.RE
.PP

.PP
References CapacitorStack\&.__areInputDataOK__(), CapacitorUnit\&.__computeCapDim__(), CapacitorStack\&.__initGivenNonZeroUnitCap__(), CapacitorStack\&.__initGivenNonZeroUnitCapInMatchingMode__(), CapacitorStack\&.__initGivenZeroUnitCap__(), CapacitorStack\&.__initGivenZeroUnitCapInMatchingMode__(), CapacitorStack\&.abutmentBox, CapacitorUnit\&.abutmentBox, VerticalRoutingTracks\&.abutmentBox, CapacitorStack\&.abutmentBox_spacing, RoutMatchedCapacitor\&.abutmentBox_spacing, VerticalRoutingTracks\&.abutmentBox_spacing, CapacitorStack\&.abutmentBoxPosition, CapacitorStack\&.capacitorsNumber, VerticalRoutingTracks\&.capacitorsNumber, CapacitorStack\&.capacitorType, RoutMatchedCapacitor\&.capacitorType, CapacitorUnit\&.capacitorType, VerticalRoutingTracks\&.capacitorType, CapacitorStack\&.compactCapDim, CapacitorStack\&.device, CapacitorUnit\&.device, VerticalRoutingTracks\&.device, Stack\&.device, CapacitorStack\&.doMatrix, CapacitorStack\&.dummyElement, RoutMatchedCapacitor\&.dummyElement, VerticalRoutingTracks\&.dummyElement, CapacitorStack\&.dummyRing, RoutMatchedCapacitor\&.dummyRing, VerticalRoutingTracks\&.dummyRing, CapacitorStack\&.dummyRingPosition, CapacitorStack\&.matchingMode, CapacitorStack\&.matchingScheme, VerticalRoutingTracks\&.matchingScheme, CapacitorStack\&.matrixDim, VerticalRoutingTracks\&.matrixDim, CapacitorStack\&.nets, VerticalRoutingTracks\&.nets, CapacitorStack\&.unitCapDim, CapacitorStack\&.vRoutingTrack_width, and VerticalRoutingTracks\&.vRoutingTrack_width\&.
.SH "Member Function Documentation"
.PP 
.SS "def setRules ( self)"

.PP
Selects technological rules according to the capacitor type\&. 
.PP
\fBReturns\fP
.RS 4
a dictionary with rules labels as keys and rules as values\&. Example of technology rules are :
.IP "\(bu" 2
minimum spacing between cuts or metals,
.IP "\(bu" 2
minimum width of a plate, a cut or a routing metal\&.
.IP "\(bu" 2
etc\&. Every rule takes two possible value according to the capacitor type (MIM or PIP)\&. Therefore, dictionary keys are generic and its values are specific to the capacitor type\&. 
.PP
.RE
.PP
\fBRemark:\fP
.RS 4
An exception is raised if the entered capacitor type is unknown\&. 
.RE
.PP

.PP
Reimplemented from \fBCapacitorUnit\fP\&.
.PP
Reimplemented in \fBVerticalRoutingTracks\fP, and \fBRoutMatchedCapacitor\fP\&.
.PP
References CapacitorUnit\&.__computeCapDim__(), CapacitorStack\&.__initMatrixMode__(), CapacitorUnit\&.__isCapacitorUnitOK__(), CapacitorStack\&.abutmentBox_spacing, RoutMatchedCapacitor\&.abutmentBox_spacing, VerticalRoutingTracks\&.abutmentBox_spacing, CapacitorStack\&.capacitance, CapacitorStack\&.capacitorIdOccurence(), CapacitorStack\&.capacitorsNumber, VerticalRoutingTracks\&.capacitorsNumber, CapacitorStack\&.capacitorType, RoutMatchedCapacitor\&.capacitorType, CapacitorUnit\&.capacitorType, VerticalRoutingTracks\&.capacitorType, CapacitorStack\&.compactCapDim, CapacitorStack\&.computeUnitCap(), CapacitorStack\&.doMatrix, CapacitorStack\&.evaluateUnitCap(), CapacitorStack\&.matchingScheme, VerticalRoutingTracks\&.matchingScheme, CapacitorStack\&.matrixDim, VerticalRoutingTracks\&.matrixDim, CapacitorStack\&.minEnclosure_hRoutingLayer_topPlate_cut, RoutMatchedCapacitor\&.minEnclosure_hRoutingLayer_topPlate_cut, CapacitorStack\&.minEnclosure_vRoutingTrackCut, CapacitorStack\&.minSpacing_vRoutingTrack, CapacitorStack\&.minSpacing_vRoutingTrackCut, RoutMatchedCapacitor\&.minSpacing_vRoutingTrackCut, CapacitorStack\&.minWidth_hRoutingLayer_topPlate_cut, RoutMatchedCapacitor\&.minWidth_hRoutingLayer_topPlate_cut, CapacitorStack\&.minWidth_vRoutingTrack, CapacitorStack\&.minWidth_vRoutingTrackCut, CapacitorStack\&.unitCapacitance, CapacitorStack\&.unitCapDim, CapacitorStack\&.vRoutingTrack_width, and VerticalRoutingTracks\&.vRoutingTrack_width\&.
.PP
Referenced by CapacitorStack\&.create(), CapacitorUnit\&.create(), RoutMatchedCapacitor\&.route(), and VerticalRoutingTracks\&.setRules()\&.
.SS "def __isUnitCap__ ( self)"

.PP
\fBReturns\fP
.RS 4
True if the drawn capacitor is a compact one\&. This function is useful when an instance is called in another class\&. \fBExample\fP : when the matrix or the compact capacitors are to be fully routed\&. 
.RE
.PP

.PP
Referenced by RoutMatchedCapacitor\&.route()\&.
.SS "def __isMatchingSchemeOK__ ( self)"

.PP
\fBReturns\fP
.RS 4
\fCTrue\fP if the matching scheme specifications are correct\&. Specifications are :
.IP "\(bu" 2
Similar number of elements as total number of elementary capacitor in the matrix\&.
.IP "\(bu" 2
Equal number of affected capacitors to C1 as to C2\&.
.IP "\(bu" 2
Capacitor identifiers equal to '1' or '2' only\&.
.IP "\(bu" 2
Otherwise, the function returns \fCFalse\fP\&. 
.PP
.RE
.PP

.PP
References CapacitorStack\&.matchingScheme, VerticalRoutingTracks\&.matchingScheme, CapacitorStack\&.matrixDim, and VerticalRoutingTracks\&.matrixDim\&.
.PP
Referenced by CapacitorStack\&.capacitorIdOccurence()\&.
.SS "def capacitorIdOccurence ( self,  capacitorIdentifier)"

.PP
\fBReturns\fP
.RS 4
occurence of capacitor identifier in the entered matching scheme\&. This is useful to verify that \fCself\&.matchingScheme\fP is correct\&. 
.RE
.PP

.PP
References CapacitorStack\&.__areMatrixDimOK__(), CapacitorStack\&.__isMatchingSchemeOK__(), CapacitorStack\&.capacitorsNumber, VerticalRoutingTracks\&.capacitorsNumber, CapacitorStack\&.dummyElement, RoutMatchedCapacitor\&.dummyElement, VerticalRoutingTracks\&.dummyElement, CapacitorStack\&.dummyRing, RoutMatchedCapacitor\&.dummyRing, VerticalRoutingTracks\&.dummyRing, CapacitorStack\&.matchingMode, CapacitorStack\&.matchingScheme, VerticalRoutingTracks\&.matchingScheme, CapacitorStack\&.matrixDim, VerticalRoutingTracks\&.matrixDim, CapacitorStack\&.nets, and VerticalRoutingTracks\&.nets\&.
.PP
Referenced by CapacitorStack\&.setRules()\&.
.SS "def create ( self,  bbMode = \fCFalse\fP)"

.PP
Draw the compact or matrix of capacitors\&. First, \&. Second, \&. Finally, \&. 
.PP
References CapacitorStack\&.__initMatchingMode__(), CapacitorStack\&.abutmentBox_spacing, RoutMatchedCapacitor\&.abutmentBox_spacing, VerticalRoutingTracks\&.abutmentBox_spacing, CapacitorStack\&.abutmentBoxPosition, CapacitorStack\&.capacitance, CapacitorStack\&.capacitorMatrix(), CapacitorStack\&.capacitorType, RoutMatchedCapacitor\&.capacitorType, CapacitorUnit\&.capacitorType, VerticalRoutingTracks\&.capacitorType, CapacitorStack\&.computeBondingBoxDimensions(), CapacitorStack\&.device, CapacitorUnit\&.device, VerticalRoutingTracks\&.device, Stack\&.device, CapacitorStack\&.doMatrix, CapacitorUnit\&.drawAbutmentBox(), CapacitorStack\&.drawAbutmentBox(), CapacitorStack\&.drawBottomPlatesRLayers(), CapacitorStack\&.drawCapacitorStack(), CapacitorStack\&.drawTopPlatesRLayers(), CapacitorStack\&.dummyRing, RoutMatchedCapacitor\&.dummyRing, VerticalRoutingTracks\&.dummyRing, CapacitorStack\&.matchingMode, CapacitorStack\&.matrixDim, VerticalRoutingTracks\&.matrixDim, CapacitorStack\&.nets, VerticalRoutingTracks\&.nets, CapacitorStack\&.setRules(), RoutMatchedCapacitor\&.setRules(), CapacitorUnit\&.setRules(), and VerticalRoutingTracks\&.setRules()\&.
.PP
Referenced by CapacitorStack\&.capacitorLine(), and CapacitorStack\&.capacitorMatrix()\&.
.SS "def capacitorLine ( self,  dy,  abutmentBox_spacing,  matchingSchemeRowIndex = \fC0\fP)"

.PP
Iteratively draws a horizontal or vertical line of capacitors according to the \fCdirection\fP parameter\&. An exception is raised if the specified direction is different from \fC{'horizontal'\fP,'vertical'}\&. At every iteration, an instance of the CapacitorUnit class is created and its layout is drawn\&. 
.PP
\fBReturns\fP
.RS 4
a list containing the drawn capacitors\&. 
.RE
.PP
\fBParameters\fP
.RS 4
\fIdy\fP the vertical position of the first cut in cut line\&. 
.RE
.PP
\fBRemarks\fP
.RS 4
An exception is raised if the specified direction is different from \fC{'horizontal'\fP,'vertical'} 
.RE
.PP

.PP
References CapacitorStack\&.abutmentBoxPosition, CapacitorStack\&.capacitorType, RoutMatchedCapacitor\&.capacitorType, CapacitorUnit\&.capacitorType, VerticalRoutingTracks\&.capacitorType, CapacitorStack\&.create(), CapacitorStack\&.createElementInCapacitorLine(), CapacitorStack\&.device, CapacitorUnit\&.device, VerticalRoutingTracks\&.device, Stack\&.device, CapacitorStack\&.dummyRing, RoutMatchedCapacitor\&.dummyRing, VerticalRoutingTracks\&.dummyRing, CapacitorStack\&.matchingMode, CapacitorStack\&.matchingScheme, VerticalRoutingTracks\&.matchingScheme, CapacitorStack\&.matrixDim, VerticalRoutingTracks\&.matrixDim, CapacitorStack\&.nets, VerticalRoutingTracks\&.nets, and CapacitorStack\&.unitCapacitance\&.
.PP
Referenced by CapacitorStack\&.capacitorMatrix()\&.
.SS "def capacitorMatrix ( self,  abutmentBox_spacing = \fC0\fP)"

.PP
Draws a matrix of identical capacitors\&. The matrix is iterativelly constructed\&. At every iteration, a new horizontal line of capacitors is drawn\&. 
.PP
\fBReturns\fP
.RS 4
a nested list of elementary capacitors\&. 
.RE
.PP

.PP
References CapacitorStack\&.abutmentBox_spacing, RoutMatchedCapacitor\&.abutmentBox_spacing, VerticalRoutingTracks\&.abutmentBox_spacing, CapacitorStack\&.abutmentBoxPosition, CapacitorStack\&.capacitorLine(), CapacitorStack\&.capacitorType, RoutMatchedCapacitor\&.capacitorType, CapacitorUnit\&.capacitorType, VerticalRoutingTracks\&.capacitorType, CapacitorStack\&.create(), CapacitorStack\&.device, CapacitorUnit\&.device, VerticalRoutingTracks\&.device, Stack\&.device, CapacitorStack\&.dummyRing, RoutMatchedCapacitor\&.dummyRing, VerticalRoutingTracks\&.dummyRing, CapacitorStack\&.getCapDim(), CapacitorStack\&.matrixDim, VerticalRoutingTracks\&.matrixDim, CapacitorStack\&.nets, VerticalRoutingTracks\&.nets, and CapacitorStack\&.unitCapacitance\&.
.PP
Referenced by CapacitorStack\&.create()\&.
.SS "def drawAbutmentBox ( self,  abutmentBox_spacing = \fC0\fP)"

.PP
Draws the abutment box of the matrix or campact capacitor\&. 
.PP
References CapacitorStack\&.abutmentBox, CapacitorUnit\&.abutmentBox, VerticalRoutingTracks\&.abutmentBox, CapacitorStack\&.abutmentBox_spacing, RoutMatchedCapacitor\&.abutmentBox_spacing, VerticalRoutingTracks\&.abutmentBox_spacing, CapacitorStack\&.abutmentBoxPosition, CapacitorStack\&.computeAbutmentBoxDimensions(), CapacitorUnit\&.computeAbutmentBoxDimensions(), CapacitorStack\&.device, CapacitorUnit\&.device, VerticalRoutingTracks\&.device, and Stack\&.device\&.
.PP
Referenced by CapacitorStack\&.create(), and CapacitorUnit\&.create()\&.
.SS "def drawBottomPlatesRLayers ( self,  bottomPlateRLayer,  drawnCapacitor)"

.PP
Draws the routing layers connecting the bottom plate in the matrix of capacitors\&. First, the relative positions of the routing layer is of the is extracted from the elementary capacitor instance\&. Then, its width is computed in a way to connect adjacent plates\&. Then, the routing layers are iterativelly drawn\&. The two borders are \&. 
.PP
References CapacitorUnit\&.getBotPlateLeftRLayerXMax(), CapacitorUnit\&.getBotPlateRLayerWidth(), CapacitorUnit\&.getBotPlateRLayerYMax(), CapacitorUnit\&.getBottomPlateLeftCutXMin(), CapacitorUnit\&.getBottomPlateRightCutXMin(), CapacitorStack\&.matrixDim, VerticalRoutingTracks\&.matrixDim, CapacitorStack\&.nets, and VerticalRoutingTracks\&.nets\&.
.PP
Referenced by CapacitorStack\&.create()\&.
.SS "def drawTopPlatesRLayers ( self,  topPlateRLayer,  drawnCapacitor)"

.PP
Draws the routing layers connecting the top plates in the matrix of capacitors\&. First, the relative positions of the routing layers is of the is extracted from the elementary capacitor instance\&. Then, its width is computed in a way to connect adjacent plates\&. Then, the routing layers are iterativelly drawn\&. The two borders are \&. 
.PP
\fBRemarks\fP
.RS 4
An exception is raised if the number of rows in the matrix is lower than 2\&. 
.RE
.PP

.PP
References CapacitorUnit\&.getTopPlateRLayerWidth(), CapacitorUnit\&.getTopPlateRLayerXCenter(), CapacitorUnit\&.getTopPlateRLayerYMax(), CapacitorUnit\&.getTopPlateRLayerYMin(), CapacitorStack\&.matrixDim, VerticalRoutingTracks\&.matrixDim, CapacitorStack\&.nets, and VerticalRoutingTracks\&.nets\&.
.PP
Referenced by CapacitorStack\&.create()\&.
.SS "def getVerticalRoutingTrack_width ( self)"

.PP
\fBReturns\fP
.RS 4
The width of the vertical routing tracks in matching mode\&. 
.RE
.PP
\fBRemark:\fP
.RS 4
This function is useful in matching mode, ie\&., in \fCRoutCapacitor\fP class, when routing the two capacitors\&. 
.RE
.PP

.SS "def getMatrixDim ( self)"

.PP
\fBReturns\fP
.RS 4
A dictionary contaning capacitor matrix's dimensions 
.RE
.PP

.PP
References CapacitorStack\&.compactCapDim, and CapacitorStack\&.doMatrix\&.
.SS "def getMatchingScheme ( self)"

.PP
\fBReturns\fP
.RS 4
the matching scheme\&. The function is useful in \fCRoutMatchedCapacitor\fP class to load \fCself\&.matchingScheme\fP attribute\&. 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Oroshi - Analog Devices Layout from the source code\&.

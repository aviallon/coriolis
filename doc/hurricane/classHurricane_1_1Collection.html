<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.0//EN'>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>Hurricane Documentation</title>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link   href="SoC.css" rel="stylesheet" type="text/css">
    <link   href="tabs.css" rel="stylesheet" type="text/css">
  </head>
    <h1 id="pagetop" class="header">Hurricane VLSI Database</h1>
    <!--
    <center class="header">
      <table class="header">
        <tr>
          <td><a href="customSummary.html">Summary</a></td>
          <td><a href="namespaces.html">Namespaces</a></td>
          <td><a href="customHierarchy.html">Class Hierarchy</a></td>
          <td><a href="annotated.html">Classes</a></td>
          <td><a href="functions.html">Member Index</a></td>
        </tr>
      </table>
    </center>
    -->
    <br>
  <body onload="javascript:toggleLevel(1)">
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceHurricane.html">Hurricane</a></li><li class="navelem"><a class="el" href="classHurricane_1_1Collection.html">Collection</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classHurricane_1_1Collection-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Hurricane::Collection&lt; Type &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classHurricane_1_1Collection.html" title="Collection description (API)">Collection</a> description (<b>API</b>)  
 <a href="classHurricane_1_1Collection.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Hurricane::Collection&lt; Type &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classHurricane_1_1Collection__inherit__graph.png" border="0" usemap="#aHurricane_1_1Collection_3_01Type_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aHurricane_1_1Collection_3_01Type_01_4_inherit__map" id="aHurricane_1_1Collection_3_01Type_01_4_inherit__map">
<area shape="rect" title="Collection description (API)" alt="" coords="145,5,303,47"/>
<area shape="rect" href="classHurricane_1_1GenericCollection.html" title="Generic Collection auto&#45;pointer." alt="" coords="5,95,213,136"/>
<area shape="rect" href="classHurricane_1_1SubSetCollection.html" title="Applies a Filter to a Collection." alt="" coords="237,95,440,136"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aafcf8e05658e245b2a762baa7a59f281"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Collection.html#aafcf8e05658e245b2a762baa7a59f281">~Collection</a> ()</td></tr>
<tr class="separator:aafcf8e05658e245b2a762baa7a59f281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75b91d3952b36e14f21174958523924"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classHurricane_1_1Collection.html">Collection</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Collection.html#ac75b91d3952b36e14f21174958523924">getClone</a> () const =0</td></tr>
<tr class="separator:ac75b91d3952b36e14f21174958523924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fd1a0a2b6d2530a87e22ba65aa3152"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classHurricane_1_1Locator.html">Locator</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Collection.html#a48fd1a0a2b6d2530a87e22ba65aa3152">getLocator</a> () const =0</td></tr>
<tr class="separator:a48fd1a0a2b6d2530a87e22ba65aa3152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1292aabe88c9aadfdfe21dabddb62c19"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Collection.html#a1292aabe88c9aadfdfe21dabddb62c19">getSize</a> () const</td></tr>
<tr class="separator:a1292aabe88c9aadfdfe21dabddb62c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846a042646e02a0f77d2ce0f6190288a"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Collection.html#a846a042646e02a0f77d2ce0f6190288a">getFirst</a> () const</td></tr>
<tr class="separator:a846a042646e02a0f77d2ce0f6190288a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32ea7249d57ee05e3c71dcde8106832"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHurricane_1_1GenericCollection.html">GenericCollection</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Collection.html#aa32ea7249d57ee05e3c71dcde8106832">getSubSet</a> (const <a class="el" href="classHurricane_1_1Filter.html">Filter</a>&lt; Type &gt; &amp;filter) const</td></tr>
<tr class="separator:aa32ea7249d57ee05e3c71dcde8106832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d986e21395d4021d927e06f204ab6c"><td class="memTemplParams" colspan="2">template&lt;class SubType &gt; </td></tr>
<tr class="memitem:a91d986e21395d4021d927e06f204ab6c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classHurricane_1_1GenericCollection.html">GenericCollection</a>&lt; SubType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Collection.html#a91d986e21395d4021d927e06f204ab6c">getSubSet</a> () const</td></tr>
<tr class="separator:a91d986e21395d4021d927e06f204ab6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673afd14782da82ad03a68366ae1f09b"><td class="memTemplParams" colspan="2">template&lt;class SubType &gt; </td></tr>
<tr class="memitem:a673afd14782da82ad03a68366ae1f09b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classHurricane_1_1GenericCollection.html">GenericCollection</a>&lt; SubType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Collection.html#a673afd14782da82ad03a68366ae1f09b">getSubSet</a> (const <a class="el" href="classHurricane_1_1Filter.html">Filter</a>&lt; SubType &gt; &amp;filter) const</td></tr>
<tr class="separator:a673afd14782da82ad03a68366ae1f09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Type&gt;<br />
class Hurricane::Collection&lt; Type &gt;</h3>

<p><a class="el" href="classHurricane_1_1Collection.html" title="Collection description (API)">Collection</a> description (<b>API</b>) </p>
<h1><a class="anchor" id="secCollectionIntro"></a>
Introduction</h1>
<p>Collections introduce the concept of set of elements.</p>
<p>Strictly speaking collections are not containers (in the STL way) but indeed set descriptors. For example, the set of instances called by a cell, which are located within a given rectangular area, will be a subtype of <a class="el" href="classHurricane_1_1Collection.html" title="Collection description (API)">Collection</a>&lt;Instance*&gt; whose first attribute will be a pointer to the cell and a second attribute the rectangular area.</p>
<p>Main characteristics of Collections: </p><ul>
<li>
Collections <b>do not own</b> their elements (they remains when the <a class="el" href="classHurricane_1_1Collection.html" title="Collection description (API)">Collection</a> is deleted). </li>
<li>
They can only be iterated <em>forward</em>. Once an element is consumed you cannot go back to it. You must restart the collection walktrough instead. </li>
<li>
Collections are very light objects which are built, copied or destroyed very rapidly. </li>
</ul>
<h1><a class="anchor" id="secIterator"></a>
STL Iterator Support</h1>
<p>The Collections now provides a basic iterator support to allow the C++11 <code>for</code> contruct: </p><div class="fragment"><div class="line">Cell* cell = ...; <span class="comment">// Get a Cell from somewhere.</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>( Net* inet : cell-&gt;getNets() ) {</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;This is &quot;</span> &lt;&lt; inet;</div>
<div class="line">  <span class="keywordflow">if</span> (inet-&gt;isExternal())</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot; [external net].&quot;</span>;</div>
<div class="line">  cout &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Although the <code>forEach</code> macro is still retained for backward compatibility, it is advisable to use the C++11 way.</p>
<h1><a class="anchor" id="secForEachMacro"></a>
The forEach Macro (obsoleted)</h1>
<p>Collections are to be used in conjunction with the <code>forEach</code> macro which allows to easily iterate over the elements. Iteration is done through a simplistic iterator which have overload for the <code>operator*()</code> and <code>operator-&gt;()</code></p>
<p>The <code>forEach</code> macro takes three arguments: </p><center> <table class="doxtable">
<tr>
<th colspan="2"><code>forEach(type,iterator,collection)</code> </th></tr>
<tr>
<td><code>type</code> </td><td>Element's type of the collection. </td></tr>
<tr>
<td><code>iterator</code> </td><td><a class="el" href="classHurricane_1_1Name.html" title="Name description (API)">Name</a> of the iterator's variable. </td></tr>
<tr>
<td><code>collection</code> </td><td>An appropriate collection to iterate over, that is, built over <code>type</code> elements. </td></tr>
</table>
</center><p>To use the forEach macro outside the <a class="el" href="namespaceHurricane.html" title="Contains Almost Everything.">Hurricane</a> namespace, the following statement is necessary: </p><div class="fragment"><div class="line"><span class="keyword">using</span> Hurricane::ForEachIterator</div>
</div><!-- fragment --><p> Here is a small example of a loop: </p><div class="fragment"><div class="line"><span class="keyword">using</span> Hurricane::ForEachIterator;</div>
<div class="line"> </div>
<div class="line">Cell* cell = ...; <span class="comment">// Get a Cell from somewhere.</span></div>
<div class="line"> </div>
<div class="line">forEach( Net*, inet, cell-&gt;getNets() ) {</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;This is &quot;</span> &lt;&lt; (*inet);</div>
<div class="line">  <span class="keywordflow">if</span> (inet-&gt;isExternal())</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot; [external net].&quot;</span>;</div>
<div class="line">  cout &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="secGenericgetCollection"></a>
The Generic getCollection</h1>
<p>The collections provide the generic <code>getCollection()</code> function which allows to convert its argument into a generic collection. It has no specific interest for <a class="el" href="namespaceHurricane.html" title="Contains Almost Everything.">Hurricane</a> collections, but this function is overloaded for STL containers.</p>
<p>This allows to handle a STL containers like a normal collection as shown in the following example: </p><div class="fragment"><div class="line">set&lt;Instance*&gt; instanceSet;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// here we fill the set with the desired instances... </span></div>
<div class="line"> </div>
<div class="line">forEach(Instance*, iinstance, getCollection(instanceSet)) {</div>
<div class="line">   <span class="comment">// process here each instance of the set</span></div>
<div class="line">   <span class="comment">// (the elements are visited according to the set ordering)</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>This approach is a little bit less efficient than the use of STL iterators, not much indeed, but has the advantage to be homogeneous with the remaining code (recall: the created collection doesn't make a copy of the STL container and its creation time is negligible).</dd></dl>
<dl class="section user"><dt>Caution: The returned collection is valid whenever the STL container </dt><dd>is valid. Then you should not do the following: <div class="fragment"><div class="line">GenericCollection&lt;Instance*&gt; getInstances(...)</div>
<div class="line">{</div>
<div class="line">   set&lt;Instance*&gt; instanceSet;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// we fill the container with the appropriate instances</span></div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">return</span> getCollection(instanceSet); <span class="comment">// instanceSet deleted after return</span></div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<p>The same will occur anyway if you do: </p><div class="fragment"><div class="line">Cell* cell = ...; <span class="comment">// we get the cell</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceHurricane.html#a3404a8b17130a1824f4a281704b04df7">Nets</a> nets = cell-&gt;getNets();</div>
<div class="line"> </div>
<div class="line">cell-&gt;destroy();</div>
<div class="line"> </div>
<div class="line">forEach(Net*, inet, nets) {</div>
<div class="line">   ...</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceHurricane_html_a3404a8b17130a1824f4a281704b04df7"><div class="ttname"><a href="namespaceHurricane.html#a3404a8b17130a1824f4a281704b04df7">Hurricane::Nets</a></div><div class="ttdeci">GenericCollection&lt; Net * &gt; Nets</div><div class="ttdef"><b>Definition:</b> Nets.h:27</div></div>
</div><!-- fragment --><h1><a class="anchor" id="secCollectionLocators"></a>
Locators</h1>
<p>Each type of collection provides an associated <a class="el" href="classHurricane_1_1Locator.html" title="Locator description (API)">Locator</a> for tracing through the corresponding set of elements.</p>
<p>Each locator moves efficiently through the data structure without building (in the form of a list or any other container type) the set of elements defined by the collection (it may however use a stack (or something else) to manage recursive traces).</p>
<p>The elements are therefore visited in the order with which they are internally stored. No assumptions must be made about this ordering. However, collections representing an STL container are visited in the same order than the container's one.</p>
<p>If you need to visit the objects in a given order, you must first fill a STL container: either a vector to be sorted accordingly or a set with the given sort criteria (see the Fill method below). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aafcf8e05658e245b2a762baa7a59f281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafcf8e05658e245b2a762baa7a59f281">&#9670;&nbsp;</a></span>~Collection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHurricane_1_1Collection.html">Hurricane::Collection</a>&lt; Type &gt;::~<a class="el" href="classHurricane_1_1Collection.html">Collection</a>&lt; Type &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroys the collection but doesn't acts on elements refered by this collection. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac75b91d3952b36e14f21174958523924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75b91d3952b36e14f21174958523924">&#9670;&nbsp;</a></span>getClone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHurricane_1_1Collection.html">Collection</a>&lt; Type &gt; * <a class="el" href="classHurricane_1_1Collection.html">Hurricane::Collection</a>&lt; Type &gt;::getClone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates and returns a clone (copy) of the collection (whatever be its type).</p>
<dl class="section remark"><dt>Remarks</dt><dd>In principle there is no need to use this function. However, if you do so, don't forget to delete the clone after use. It is indeed much easier to use generic collections which do that for you, as we will see later. </dd></dl>

</div>
</div>
<a id="a48fd1a0a2b6d2530a87e22ba65aa3152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fd1a0a2b6d2530a87e22ba65aa3152">&#9670;&nbsp;</a></span>getLocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHurricane_1_1Locator.html">Locator</a>&lt; Type &gt; * <a class="el" href="classHurricane_1_1Collection.html">Hurricane::Collection</a>&lt; Type &gt;::getLocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates and returns a locator adapted to visit the elements of the collection.</p>
<dl class="section remark"><dt>Remarks</dt><dd>In principle there is no need to use this function. Use preferably the macro <b>for_each</b> described below. However, if you do so, don't forget to delete this locator after use, else use generic locators, which do that for you, as we will see later. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classHurricane_1_1Collection.html#a846a042646e02a0f77d2ce0f6190288a">Hurricane::Collection&lt; Type &gt;::getFirst()</a>, and <a class="el" href="classHurricane_1_1Collection.html#a1292aabe88c9aadfdfe21dabddb62c19">Hurricane::Collection&lt; Type &gt;::getSize()</a>.</p>

</div>
</div>
<a id="a1292aabe88c9aadfdfe21dabddb62c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1292aabe88c9aadfdfe21dabddb62c19">&#9670;&nbsp;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classHurricane_1_1Collection.html">Hurricane::Collection</a>&lt; Type &gt;::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Returns:</b> the number of objects identified within the collection.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Very fast in some cases, but may need to visit the collection in most ones. </dd></dl>

<p class="reference">References <a class="el" href="classHurricane_1_1Collection.html#a48fd1a0a2b6d2530a87e22ba65aa3152">Hurricane::Collection&lt; Type &gt;::getLocator()</a>.</p>

</div>
</div>
<a id="a846a042646e02a0f77d2ce0f6190288a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a846a042646e02a0f77d2ce0f6190288a">&#9670;&nbsp;</a></span>getFirst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="classHurricane_1_1Collection.html">Hurricane::Collection</a>&lt; Type &gt;::getFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Returns:</b> the first element of the collection.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The result is meaningful only when the collection is non empty. </dd></dl>

<p class="reference">References <a class="el" href="classHurricane_1_1Collection.html#a48fd1a0a2b6d2530a87e22ba65aa3152">Hurricane::Collection&lt; Type &gt;::getLocator()</a>.</p>

</div>
</div>
<a id="aa32ea7249d57ee05e3c71dcde8106832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32ea7249d57ee05e3c71dcde8106832">&#9670;&nbsp;</a></span>getSubSet() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHurricane_1_1GenericCollection.html">GenericCollection</a>&lt; Type &gt; <a class="el" href="classHurricane_1_1Collection.html">Hurricane::Collection</a>&lt; Type &gt;::getSubSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHurricane_1_1Filter.html">Filter</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Returns:</b> the collection representing the subset of elements accepted by the filter. </p><div class="fragment"><div class="line"><a class="code" href="namespaceHurricane.html#a3404a8b17130a1824f4a281704b04df7">Nets</a> <a class="code" href="classHurricane_1_1Cell.html#aa80f3345db8c1395fa04a50737208793">Cell::getExternalNets</a>()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">   <span class="keywordflow">return</span> getNets().<a class="code" href="classHurricane_1_1Collection.html#aa32ea7249d57ee05e3c71dcde8106832">getSubSet</a>(<a class="code" href="classHurricane_1_1Net.html#a3af91a80e219e37e70229e61dfd385da">Net::getIsExternalFilter</a>());</div>
<div class="line">}</div>
<div class="ttc" id="aclassHurricane_1_1Cell_html_aa80f3345db8c1395fa04a50737208793"><div class="ttname"><a href="classHurricane_1_1Cell.html#aa80f3345db8c1395fa04a50737208793">Hurricane::Cell::getExternalNets</a></div><div class="ttdeci">Nets getExternalNets() const</div></div>
<div class="ttc" id="aclassHurricane_1_1Collection_html_aa32ea7249d57ee05e3c71dcde8106832"><div class="ttname"><a href="classHurricane_1_1Collection.html#aa32ea7249d57ee05e3c71dcde8106832">Hurricane::Collection::getSubSet</a></div><div class="ttdeci">GenericCollection&lt; Type &gt; getSubSet(const Filter&lt; Type &gt; &amp;filter) const</div><div class="ttdef"><b>Definition:</b> Collection.h:98</div></div>
<div class="ttc" id="aclassHurricane_1_1Net_html_a3af91a80e219e37e70229e61dfd385da"><div class="ttname"><a href="classHurricane_1_1Net.html#a3af91a80e219e37e70229e61dfd385da">Hurricane::Net::getIsExternalFilter</a></div><div class="ttdeci">static NetFilter getIsExternalFilter()</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a91d986e21395d4021d927e06f204ab6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d986e21395d4021d927e06f204ab6c">&#9670;&nbsp;</a></span>getSubSet() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<div class="memtemplate">
template&lt;class SubType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHurricane_1_1GenericCollection.html">GenericCollection</a>&lt; SubType &gt; <a class="el" href="classHurricane_1_1Collection.html">Hurricane::Collection</a>&lt; Type &gt;::getSubSet&lt; SubType &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Returns:</b> the collection corresponding to the subset of elements of type <code>&lt;SubType&gt;</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The returned collection is a collection of objects of type <b>SubType</b> and not of type <b>Type</b>.</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="namespaceHurricane.html#a1e6a8ab09f688509bd727b3fee02d0d2">Contacts</a> <a class="code" href="classHurricane_1_1Net.html#a9c397596fe9ecbf674712c72e0b9010c">Net::getContacts</a>()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">   <span class="keywordflow">return</span> getComponents().<a class="code" href="classHurricane_1_1Collection.html#aa32ea7249d57ee05e3c71dcde8106832">getSubSet</a>&lt;Contact*&gt;();</div>
<div class="line">}</div>
<div class="ttc" id="aclassHurricane_1_1Net_html_a9c397596fe9ecbf674712c72e0b9010c"><div class="ttname"><a href="classHurricane_1_1Net.html#a9c397596fe9ecbf674712c72e0b9010c">Hurricane::Net::getContacts</a></div><div class="ttdeci">Contacts getContacts() const</div></div>
<div class="ttc" id="anamespaceHurricane_html_a1e6a8ab09f688509bd727b3fee02d0d2"><div class="ttname"><a href="namespaceHurricane.html#a1e6a8ab09f688509bd727b3fee02d0d2">Hurricane::Contacts</a></div><div class="ttdeci">GenericCollection&lt; Contact * &gt; Contacts</div><div class="ttdef"><b>Definition:</b> Contacts.h:27</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a673afd14782da82ad03a68366ae1f09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673afd14782da82ad03a68366ae1f09b">&#9670;&nbsp;</a></span>getSubSet() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<div class="memtemplate">
template&lt;class SubType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHurricane_1_1GenericCollection.html">GenericCollection</a>&lt; SubType &gt; <a class="el" href="classHurricane_1_1Collection.html">Hurricane::Collection</a>&lt; Type &gt;::getSubSet&lt; SubType &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHurricane_1_1Filter.html">Filter</a>&lt; SubType &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Returns:</b> the collection representing the subset of elements of type <code>&lt;SubType&gt;</code> accepted by the filter.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The returned collection is a collection of elements of type <b>SubType</b> and not of type <b>Type</b> and the filter must be a filter of elements of type <b>SubType</b>.</dd></dl>
<dl class="section user"><dt>Sample:</dt><dd><a class="el" href="classHurricane_1_1Filter.html" title="Filter description (API)">Filter</a> <a class="el" href="classHurricane_1_1Segment.html" title="Segment description (API)">Hurricane::Segment</a> according to their <a class="el" href="classHurricane_1_1Layer.html" title="Layer description (API)">Layer</a>. <div class="fragment"><div class="line"><span class="keyword">class </span>IsOnLayer : <span class="keyword">public</span> Filter&lt;Segment*&gt; {</div>
<div class="line">   <span class="keyword">public</span>:</div>
<div class="line">      Layer* _layer;</div>
<div class="line">   <span class="keyword">public</span>:</div>
<div class="line">      IsOnLayer(Layer* layer)</div>
<div class="line">        : _layer(layer)</div>
<div class="line">      {</div>
<div class="line">         <span class="keywordflow">if</span> (!_layer) <span class="keywordflow">throw</span> Error(<span class="stringliteral">&quot;Can&#39;t create IsOnLayer filter : null layer&quot;</span>);</div>
<div class="line">      };</div>
<div class="line"> </div>
<div class="line">      IsOnLayer(<span class="keyword">const</span> IsOnLayer&amp; isOnLayer)</div>
<div class="line">        : _layer(isOnLayer._layer)</div>
<div class="line">      { };</div>
<div class="line"> </div>
<div class="line">      IsOnLayer&amp; operator=(<span class="keyword">const</span> IsOnLayer&amp; isOnLayer)</div>
<div class="line">      {</div>
<div class="line">         _layer = isOnLayer._layer;</div>
<div class="line">         <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">      };</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> Filter&lt;Net*&gt;* <a class="code" href="classHurricane_1_1Collection.html#ac75b91d3952b36e14f21174958523924">getClone</a>()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">      </span>{</div>
<div class="line">         <span class="keywordflow">return</span> <span class="keyword">new</span> IsOnLayer(*<span class="keyword">this</span>);</div>
<div class="line">      };</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">bool</span> Accept(Segment* segment)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">      </span>{</div>
<div class="line">         <span class="keywordflow">return</span> (segmentgetLayer() == _layer);</div>
<div class="line">      };</div>
<div class="line">};</div>
<div class="ttc" id="aclassHurricane_1_1Collection_html_ac75b91d3952b36e14f21174958523924"><div class="ttname"><a href="classHurricane_1_1Collection.html#ac75b91d3952b36e14f21174958523924">Hurricane::Collection::getClone</a></div><div class="ttdeci">virtual Collection&lt; Type &gt; * getClone() const =0</div></div>
</div><!-- fragment --></dd></dl>
<p>And somewher later: </p><div class="fragment"><div class="line">Layer* metal = getDataBase()-&gt;getTechnology()-&gt;getLayer(<span class="stringliteral">&quot;metal&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceHurricane.html#a30748fa53a81cb597d4a13d651238716">Segments</a> segments = net-&gt;getComponents()-&gt;getSubSet&lt;Segment*&gt;(IsOnLayer(metal));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// segments represents here the subset of net components</span></div>
<div class="line"><span class="comment">// which are of type Segment and located on layer metal</span></div>
<div class="ttc" id="anamespaceHurricane_html_a30748fa53a81cb597d4a13d651238716"><div class="ttname"><a href="namespaceHurricane.html#a30748fa53a81cb597d4a13d651238716">Hurricane::Segments</a></div><div class="ttdeci">GenericCollection&lt; Segment * &gt; Segments</div><div class="ttdef"><b>Definition:</b> Segments.h:27</div></div>
</div><!-- fragment --> 
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Collection_8h_source.html">Collection.h</a></li>
<li>Collection.dox</li>
</ul>
</div><!-- contents -->
    <br>
    <hr>
    <table class="footer1">
      <tr>
        <td class="LFooter"><small>Generated by doxygen 1.9.1 on Sat Nov 18 2023</small></td>
        <td class="RFooter"><a href='#pagetop'><small>Return to top of page</small></a></td>
      </tr>
    </table>
    <table class="footer2">
      <tr>
        <td class="LFooter">Hurricane VLSI Database</td>
        <td class="RFooter"><small>Copyright &#169; 2000-2020 Bull S.A. All rights reserved</small></td>
      </tr>
    </table>
  </body>
</html>

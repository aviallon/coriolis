<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.0//EN'>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>Hurricane Documentation</title>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link   href="SoC.css" rel="stylesheet" type="text/css">
    <link   href="custom_tabs.css" rel="stylesheet" type="text/css">
  </head>
    <h1 id="pagetop" class="header">Hurricane VLSI Database</h1>
    <!--
    <center class="header">
      <table class="header">
        <tr>
          <td><a href="customSummary.html">Summary</a></td>
          <td><a href="namespaces.html">Namespaces</a></td>
          <td><a href="customHierarchy.html">Class Hierarchy</a></td>
          <td><a href="annotated.html">Classes</a></td>
          <td><a href="functions.html">Member Index</a></td>
        </tr>
      </table>
    </center>
    -->
    <br>
  <body onload="javascript:toggleLevel(1)">
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceHurricane.html">Hurricane</a></li><li class="navelem"><a class="el" href="classHurricane_1_1Property.html">Property</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classHurricane_1_1Property-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Hurricane::Property Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classHurricane_1_1Property.html" title="Property description (API)">Property</a> description (<b>API</b>)  
 <a href="classHurricane_1_1Property.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Hurricane::Property:</div>
<div class="dyncontent">
<div class="center"><img src="classHurricane_1_1Property__inherit__graph.png" border="0" usemap="#aHurricane_1_1Property_inherit__map" alt="Inheritance graph"/></div>
<map name="aHurricane_1_1Property_inherit__map" id="aHurricane_1_1Property_inherit__map">
<area shape="rect" title="Property description (API)" alt="" coords="5,126,153,153"/>
<area shape="rect" href="classHurricane_1_1PrivateProperty.html" title="PrivateProperty description (API)" alt="" coords="201,71,396,98"/>
<area shape="rect" href="classHurricane_1_1SharedProperty.html" title="SharedProperty description (API)" alt="" coords="202,151,395,178"/>
<area shape="rect" href="classHurricane_1_1StandardPrivateProperty.html" title="StandardPrivateProperty description (API)" alt="" coords="444,5,656,47"/>
<area shape="rect" href="classIsobar_1_1PyHolderProperty.html" title="A Property to contain PyAttributesHolder." alt="" coords="458,71,642,98"/>
<area shape="rect" href="classHurricane_1_1Relation.html" title="Relation description (API)" alt="" coords="477,122,623,149"/>
<area shape="rect" href="classHurricane_1_1StandardSharedProperty.html" title="StandardSharedProperty description (API)" alt="" coords="452,173,648,215"/>
<area shape="rect" href="classHurricane_1_1UpdateSession.html" title="UpdateSession description (API)" alt="" coords="455,239,645,266"/>
<area shape="rect" href="classHurricane_1_1StandardRelation.html" title="StandardRelation description (API)" alt="" coords="704,122,909,149"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2759e2003c15d417b925092bc253ddd1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classHurricane_1_1Name.html">Name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Property.html#a2759e2003c15d417b925092bc253ddd1">getName</a> () const =0</td></tr>
<tr class="separator:a2759e2003c15d417b925092bc253ddd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b936414d9d85bb6509100b5dd6a667"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Property.html#ac7b936414d9d85bb6509100b5dd6a667">onCapturedBy</a> (<a class="el" href="classHurricane_1_1DBo.html">DBo</a> *owner)=0</td></tr>
<tr class="separator:ac7b936414d9d85bb6509100b5dd6a667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea7ee2089f1463c0c16e30313b54083"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Property.html#a0ea7ee2089f1463c0c16e30313b54083">onReleasedBy</a> (<a class="el" href="classHurricane_1_1DBo.html">DBo</a> *owner)=0</td></tr>
<tr class="separator:a0ea7ee2089f1463c0c16e30313b54083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Property Collection</div></td></tr>
<tr class="memitem:ab60362699e6c6ea35ace45dbd1075a2f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Property.html#ab60362699e6c6ea35ace45dbd1075a2f">destroy</a> ()</td></tr>
<tr class="separator:ab60362699e6c6ea35ace45dbd1075a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classHurricane_1_1Property.html" title="Property description (API)">Property</a> description (<b>API</b>) </p>
<h1><a class="anchor" id="secPropertyIntro"></a>
Introduction</h1>
<p>Properties can be attached to the data base objects. Those properties must have a name in order to access them unambiguously. Of course only one property of a given name can be attached to an object.</p>
<p>In a first step we define two great categories of properties : the private properties which can be attached to only one object and the shared properties which can be attached to a large number of objects.</p>
<p>We will detail separately their respective behaviour, but we ensure that the management of each of those two property categories is absolutely secure. That is, on one side you can destroy explicitely a property (and the objects will be notified) and on the other side the properties will be automatically destroyed when no more object reference them.</p>
<dl class="section remark"><dt>Remarks</dt><dd>By overloading some messages, as we will see later, it is possible to set up different behaviours (like avoid the automatic delete).</dd></dl>
<h1><a class="anchor" id="secPropertyTheQuarks"></a>
The Quarks</h1>
<p>As we shall see, the occurences are very simple objects which are used to designate some entity of the virtually unfolded hierarchy. Indeed, those occurences, which are built and deleted very quickly, are very volatile objects to which obvioulsy we can't attach properties directly.</p>
<p>But the interest of occurences is precisely to be able to attach them properties. In order to be able to do that, properties must be stored in a secure place where we could find them when needed. The quarks are here for that purpose : they are subtypes of data base object and therefore can store the properties attached to occurences.</p>
<dl class="section user"><dt>Important:</dt><dd>only one quark is attached to all occurences which refer the same entity of the virtually unfolded hierarchy. This means that a property placed on an occurence can be read by any other occurence which refers the same entity of the virtually unfolded hierarchy.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those quarks are also volatile objects because their only reason to exist is that at least one property is attached to them.</dd></dl>
<h1><a class="anchor" id="secPropertyHowThatWorks"></a>
How that works</h1>
<p>We will detail the way properties are managed by analysing more precisely what happens at the level of property access functions both for data base objects and for occurences.</p>
<p><b>Accessing a property by its name</b> </p><div class="fragment"><div class="line">Property* <a class="code" href="classHurricane_1_1DBo.html#a599f61978df51d1d4c351f6cbd02488d">DBo::getProperty</a>(<span class="keyword">const</span> Name&amp; name) <span class="keyword">const</span>;</div>
<div class="ttc" id="aclassHurricane_1_1DBo_html_a599f61978df51d1d4c351f6cbd02488d"><div class="ttname"><a href="classHurricane_1_1DBo.html#a599f61978df51d1d4c351f6cbd02488d">Hurricane::DBo::getProperty</a></div><div class="ttdeci">Property * getProperty(const Name &amp;) const</div></div>
</div><!-- fragment --><p> This member function returns the property of name <code>&lt;name&gt;</code> if there is one attached to the object, else NULL. </p><div class="fragment"><div class="line">Property* <a class="code" href="classHurricane_1_1Occurrence.html#ab2b36b219037a2310f6527a35a9a266f">Occurrence::getProperty</a>(<span class="keyword">const</span> Name&amp; name) <span class="keyword">const</span>;</div>
<div class="ttc" id="aclassHurricane_1_1Occurrence_html_ab2b36b219037a2310f6527a35a9a266f"><div class="ttname"><a href="classHurricane_1_1Occurrence.html#ab2b36b219037a2310f6527a35a9a266f">Hurricane::Occurrence::getProperty</a></div><div class="ttdeci">Property * getProperty(const Name &amp;name) const</div></div>
</div><!-- fragment --><p> This function searches in a first time the quark representing the occurence.</p>
<p>If the quark doesn't exist, this means there is no property attached to that occurence, then the function returns NULL.</p>
<p>If the quark does exist, the function returns the property of name <code>&lt;name&gt;</code> attached to the quark, if any, by calling the previous function (because quarks are data base objects).</p>
<p><b>Accessing the set of all properties</b> </p><div class="fragment"><div class="line"><a class="code" href="namespaceHurricane.html#afd7bca6dad4be54b7c03b0463e6c0004">Properties</a>  <a class="code" href="classHurricane_1_1DBo.html#aec46894a10e83abb54c495dc4d90f2d3">DBo::getProperties</a>() <span class="keyword">const</span>;</div>
<div class="ttc" id="aclassHurricane_1_1DBo_html_aec46894a10e83abb54c495dc4d90f2d3"><div class="ttname"><a href="classHurricane_1_1DBo.html#aec46894a10e83abb54c495dc4d90f2d3">Hurricane::DBo::getProperties</a></div><div class="ttdeci">Properties getProperties() const</div></div>
<div class="ttc" id="anamespaceHurricane_html_afd7bca6dad4be54b7c03b0463e6c0004"><div class="ttname"><a href="namespaceHurricane.html#afd7bca6dad4be54b7c03b0463e6c0004">Hurricane::Properties</a></div><div class="ttdeci">GenericCollection&lt; Property * &gt; Properties</div><div class="ttdef"><b>Definition:</b> Properties.h:27</div></div>
</div><!-- fragment --><p> Return the collection of properties attached to the object (possibly empty). </p><div class="fragment"><div class="line"><a class="code" href="namespaceHurricane.html#afd7bca6dad4be54b7c03b0463e6c0004">Properties</a>  <a class="code" href="classHurricane_1_1Occurrence.html#acbf59d6c01804e01f66d076c149abb49">Occurrence::getProperties</a>() <span class="keyword">const</span>;</div>
<div class="ttc" id="aclassHurricane_1_1Occurrence_html_acbf59d6c01804e01f66d076c149abb49"><div class="ttname"><a href="classHurricane_1_1Occurrence.html#acbf59d6c01804e01f66d076c149abb49">Hurricane::Occurrence::getProperties</a></div><div class="ttdeci">Properties getProperties() const</div></div>
</div><!-- fragment --><p> This function searches in a first time the quark representing the occurence.</p>
<p>If the quark doesn't exist, this means there is no property attached to that occurence, then the function returns an empty property collection.</p>
<p>If the quark does exist, the function returns the property collection attached to the quark, by calling the previous function (the returned collection is inevitably non empty, else the quark would not exist).</p>
<p><b>Does the object have properties ?</b> </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classHurricane_1_1DBo.html#a1563f094565030c77592ed82f9a9989b">DBo::hasProperty</a>() <span class="keyword">const</span>;</div>
<div class="ttc" id="aclassHurricane_1_1DBo_html_a1563f094565030c77592ed82f9a9989b"><div class="ttname"><a href="classHurricane_1_1DBo.html#a1563f094565030c77592ed82f9a9989b">Hurricane::DBo::hasProperty</a></div><div class="ttdeci">bool hasProperty() const</div><div class="ttdef"><b>Definition:</b> DBo.h:109</div></div>
</div><!-- fragment --><p> Return <b>true</b> if the object owns at least a property, else <b>false</b>. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classHurricane_1_1Occurrence.html#a0c1c6cfdf47f33166d108e2311d74e48">Occurrence::hasProperty</a>() <span class="keyword">const</span>;</div>
<div class="ttc" id="aclassHurricane_1_1Occurrence_html_a0c1c6cfdf47f33166d108e2311d74e48"><div class="ttname"><a href="classHurricane_1_1Occurrence.html#a0c1c6cfdf47f33166d108e2311d74e48">Hurricane::Occurrence::hasProperty</a></div><div class="ttdeci">bool hasProperty() const</div></div>
</div><!-- fragment --><p> This function searches the quark representing the occurence.</p>
<p>If the quark does exist it means there is at least a property assigned to it and the function returns <b>true</b>, else it returns <b>false</b>.</p>
<p><b>Adding a property : things becomes a little harder</b> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classHurricane_1_1DBo.html#a8979674f11507cb4c7c5251b41ed72d5">DBo::put</a>(Property* property);</div>
<div class="ttc" id="aclassHurricane_1_1DBo_html_a8979674f11507cb4c7c5251b41ed72d5"><div class="ttname"><a href="classHurricane_1_1DBo.html#a8979674f11507cb4c7c5251b41ed72d5">Hurricane::DBo::put</a></div><div class="ttdeci">void put(Property *)</div></div>
</div><!-- fragment --><p> Adds the property <code>&lt;property&gt;</code> to the set of properties of the object. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classHurricane_1_1Occurrence.html#aaea0bdc4f5bb4012eb52f3abe20525be">Occurrence::put</a>(Property* property);</div>
<div class="ttc" id="aclassHurricane_1_1Occurrence_html_aaea0bdc4f5bb4012eb52f3abe20525be"><div class="ttname"><a href="classHurricane_1_1Occurrence.html#aaea0bdc4f5bb4012eb52f3abe20525be">Hurricane::Occurrence::put</a></div><div class="ttdeci">void put(Property *property)</div></div>
</div><!-- fragment --><p> This function searches the quark representing the occurence.</p>
<p>If the quark doesn't exist it is automatically created in order to attach this first property.</p>
<p>once the quark has been got or created, we can add the property with the previous function.</p>
<p>Two important things might happen then : The property is already owned by an other object (may be a quark) and that property is not a shared one <b>and/or</b> the object owns already a property with the same name.</p>
<p>Therefore it may happen, within this step, that adding a property to an object leads to the deletion of an other property on that object <b>(name unicity)</b> or on an other object <b>(unicity of owner for a private property)</b>.</p>
<p>Which behaviour should we have in such conditions ? Shall we destroy the property which has been detached ? There is no unique behaviour which matches all needs. In order to solve this problem the properties must answer to two specific messages which are : <b><a class="el" href="classHurricane_1_1Property.html#ac7b936414d9d85bb6509100b5dd6a667">onCapturedBy(DBo* dbo)</a></b> when the property is attached to an object and <b>onReleasedBy(DBo* dbo)</b> when it is detached from the object. It is within that last message that the decision about the future of the property must be taken.</p>
<dl class="section remark"><dt>Remarks</dt><dd>We will detail below those messages for both private and shared properties.</dd></dl>
<p><b>Removing a property</b> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classHurricane_1_1DBo.html#a7833a1f0b8c704930bdc00861e63cf5e">DBo::remove</a>(Property* property);</div>
<div class="ttc" id="aclassHurricane_1_1DBo_html_a7833a1f0b8c704930bdc00861e63cf5e"><div class="ttname"><a href="classHurricane_1_1DBo.html#a7833a1f0b8c704930bdc00861e63cf5e">Hurricane::DBo::remove</a></div><div class="ttdeci">void remove(Property *)</div></div>
</div><!-- fragment --><p> Removes the property <code>&lt;property&gt;</code> from the set of properties of the object. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classHurricane_1_1Occurrence.html#a774404aa5eb01371f64cf5fda3f3ffbf">Occurrence::remove</a>(Property* property);</div>
<div class="ttc" id="aclassHurricane_1_1Occurrence_html_a774404aa5eb01371f64cf5fda3f3ffbf"><div class="ttname"><a href="classHurricane_1_1Occurrence.html#a774404aa5eb01371f64cf5fda3f3ffbf">Hurricane::Occurrence::remove</a></div><div class="ttdeci">void remove(Property *property)</div></div>
</div><!-- fragment --><p> The function searches for the quark associated to the occurence.</p>
<p>If the quark doesn't exist, there is nothing to do, the occurence has no properties.</p>
<p>Else the property is removed from the set of quark properties by calling the previous function. Furthermore if this removed property is the last one, the quark is automatically deleted.</p>
<dl class="section user"><dt>Important:</dt><dd>The message <b>onReleasedBy</b> is called upon as explained above. This call will decide of the future of the removed property.</dd></dl>
<p><b>Clearing all properties</b> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classHurricane_1_1DBo.html#a3e02f3d665cb0b2120df2fdfe9c3df4f">DBo::clearProperties</a>();</div>
<div class="ttc" id="aclassHurricane_1_1DBo_html_a3e02f3d665cb0b2120df2fdfe9c3df4f"><div class="ttname"><a href="classHurricane_1_1DBo.html#a3e02f3d665cb0b2120df2fdfe9c3df4f">Hurricane::DBo::clearProperties</a></div><div class="ttdeci">void clearProperties()</div></div>
</div><!-- fragment --><p> Removes all properties attached to the object. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classHurricane_1_1Occurrence.html#ae9b269d39f3f68645d6d396d7ab5d8b7">Occurrence::clearProperties</a>();</div>
<div class="ttc" id="aclassHurricane_1_1Occurrence_html_ae9b269d39f3f68645d6d396d7ab5d8b7"><div class="ttname"><a href="classHurricane_1_1Occurrence.html#ae9b269d39f3f68645d6d396d7ab5d8b7">Hurricane::Occurrence::clearProperties</a></div><div class="ttdeci">void clearProperties()</div></div>
</div><!-- fragment --><p> First searches for the quark associated to the occurence.</p>
<p>If the quark exist it is simply destroyed after removing all its private properties and detaching it from all its shared properties (wich may lead to their removal). Without quark the occurence looses all its properties.</p>
<dl class="section user"><dt>Important:</dt><dd>Here again the message <b>onReleasedBy</b> is called upon for each removed property.</dd></dl>
<h1><a class="anchor" id="secPropertyCreationProcess"></a>
Creation process</h1>
<p>The creation process is similar to the data base objects creation one. Therefore a property must be created by the special function <b>Create</b> and not by the usual new (which is not available).</p>
<h1><a class="anchor" id="secPropertyDeletionProcess"></a>
Deletion process</h1>
<p><b><a class="el" href="classHurricane_1_1Property.html#ab60362699e6c6ea35ace45dbd1075a2f">Hurricane::Property::destroy</a></b></p>
<h1><a class="anchor" id="secPropertyNaming"></a>
Naming Conventions</h1>
<p>Properties being named and the their management being based on that name, it could occur conflicts between <a class="el" href="namespaceHurricane.html" title="Contains Almost Everything.">Hurricane</a> which use some properties and the different tools which will be plugged above, or between different tools themselves.</p>
<p>In order to avoid that you must take some precautions in the choice of the property names.</p>
<p>So <a class="el" href="namespaceHurricane.html" title="Contains Almost Everything.">Hurricane</a> uses properties prefixed by the string "Hurricane::",like for instance "Hurricane::Selector" for the property of type Selector.</p>
<p>So I suggest that different tools use a similar namming strategy which would keep confident all the community of <b><em>hurricaners</em></b></p>
<dl class="section remark"><dt>Remarks</dt><dd>Using names like "ZenTek::TimingNode" for the TimingNode type property managed by tools from the ZenTek society decreases name conflicts, unless with other tools from the same society. A property name "SocietyName::ToolName::PropertyName" would be more secure.</dd></dl>
<p>Furthermore, if the community adopts this convention it will be possible to simplify some parts of the code by avoiding for example calls to the macro <b>is_a</b> to check that the collected property is of the expected type, as shown in the following example : </p><div class="fragment"><div class="line">Property* <span class="keyword">property</span> = occurence.getProperty(<span class="stringliteral">&quot;Hurricane::Selector&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (property &amp;&amp; is_a&lt;Selector*&gt;(property)) {</div>
<div class="line">  Selector* selector = (Selector*)property;</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> Which could become : </p><div class="fragment"><div class="line">Selector* selector = (Selector*)occurence.getProperty(<span class="stringliteral">&quot;Hurricane::Selector&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (selector) {</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="secPropertyRemarks"></a>
Remarks</h1>
<p>The name of properties being of type <a class="el" href="classHurricane_1_1Name.html" title="Name description (API)">Name</a> and not of type string, the comparison between two names operates on their pointers and not on their character strings. The length of the name doesn't affect the comparison performance.</p>
<p>on the other hand, the time to create a property name depends obviously of its length and of the number of names (which fortunately are managed by efficient map containers).</p>
<p>Therefore in order to avoid building names at each property access, you must provide a specific function which returns a <a class="el" href="classHurricane_1_1Name.html" title="Name description (API)">Name</a> object allocated once and once only.</p>
<p>As a matter of fact if you write, like in the previous example : </p><div class="fragment"><div class="line">Property* <span class="keyword">property</span> = occurence.getProperty(<span class="stringliteral">&quot;Hurricane::Selector&quot;</span>);</div>
</div><!-- fragment --><p> Each time the name is built and this will degrade performance.</p>
<p>on the other hand if the following static member function is provided : </p><div class="fragment"><div class="line"><span class="keyword">const</span> Name&amp; Selector::getPropertyName ()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> Name NAME = <span class="stringliteral">&quot;Hurricane::Selector&quot;</span>;</div>
<div class="line">  <span class="keywordflow">return</span> NAME;</div>
<div class="line">}</div>
</div><!-- fragment --><p> You could write later : </p><div class="fragment"><div class="line">Property* <span class="keyword">property</span> = occurence.getProperty(Selector::getPropertyName());</div>
</div><!-- fragment --><p> This approach is much more efficient and presents an other interest : you don't need to know the name of the property being handled. This allows to change property names without affecting existing code.</p>
<p>Therefore I propose, for every new instanciable property (whose name depends of the property type), that a static member function be systematically provided.</p>
<p>Furthermore, both <a class="el" href="classHurricane_1_1StandardPrivateProperty.html" title="StandardPrivateProperty description (API)">StandardPrivateProperty</a> and <a class="el" href="classHurricane_1_1StandardSharedProperty.html" title="StandardSharedProperty description (API)">StandardSharedProperty</a> have, as we shall see later, an attribute giving their name. Here again, for accessing the propety, a name must be created.</p>
<p>So I propose also that a global function (which can't be a static member function) be defined for each new property name.</p>
<p>That way, by defining (i.e. for the property ObjectId) the function : </p><div class="fragment"><div class="line"><span class="keyword">const</span> Name&amp; getObjectIdPropertyName ()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> Name NAME = <span class="stringliteral">&quot;Hurricane::ObjectId&quot;</span>;</div>
<div class="line">  <span class="keywordflow">return</span> NAME;</div>
<div class="line">}</div>
</div><!-- fragment --><p> You can write later : </p><div class="fragment"><div class="line">Property* <span class="keyword">property</span> = occurence.getProperty(getObjectIdPropertyName());</div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab60362699e6c6ea35ace45dbd1075a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab60362699e6c6ea35ace45dbd1075a2f">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Hurricane::Property::destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like the data base objects, properties can be destroyed by calling upon this function and not the standard C++ destructor (which is not available). </p>

</div>
</div>
<a id="a2759e2003c15d417b925092bc253ddd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2759e2003c15d417b925092bc253ddd1">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHurricane_1_1Name.html">Name</a> Hurricane::Property::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Returns:</b> the name of the property : this method must absolutely be overloaded for all new property classes, because the property name is not a "wired in" attribute. A property being a real object, this name derives naturally from the property type name (so don't loose room uselessly to store it in a record slot). </p>

</div>
</div>
<a id="ac7b936414d9d85bb6509100b5dd6a667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b936414d9d85bb6509100b5dd6a667">&#9670;&nbsp;</a></span>onCapturedBy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Hurricane::Property::onCapturedBy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHurricane_1_1DBo.html">DBo</a> *&#160;</td>
          <td class="paramname"><em>dbo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This message is called upon when the property is added to the properties of <code>&lt;dbo&gt;</code>.</p>
<p>By default this function does nothing particular, but it must be overloaded for all property sub-classes. We will detail later the reaction to this message as taken by the private and shared property classes.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This message being already overloaded for private and shared property classes there is no need to overload it again when specializing any of those two classes. </dd></dl>

</div>
</div>
<a id="a0ea7ee2089f1463c0c16e30313b54083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea7ee2089f1463c0c16e30313b54083">&#9670;&nbsp;</a></span>onReleasedBy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Hurricane::Property::onReleasedBy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHurricane_1_1DBo.html">DBo</a> *&#160;</td>
          <td class="paramname"><em>dbo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This message is called upon when the property is removed from the <code>&lt;dbo&gt;</code> properties.</p>
<dl class="section user"><dt>Important:</dt><dd>The argument <code>&lt;dbo&gt;</code> is not (or no more) necessarily the owner of the property which receives the message. The processing to be done in reaction to this message often depends on this observation. We will better understand this subtlety when studying private properties.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This message being already overloaded for private and shared property classes there is no need to overload it again when specializing any of those two classes. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Property_8h_source.html">Property.h</a></li>
<li>Property.dox</li>
</ul>
</div><!-- contents -->
    <br>
    <hr>
    <table class="footer1">
      <tr>
        <td class="LFooter"><small>Generated by doxygen 1.9.1 on Tue Jan 16 2024</small></td>
        <td class="RFooter"><a href='#pagetop'><small>Return to top of page</small></a></td>
      </tr>
    </table>
    <table class="footer2">
      <tr>
        <td class="LFooter">Hurricane VLSI Database</td>
        <td class="RFooter"><small>Copyright &#169; 2000-2020 Bull S.A. All rights reserved</small></td>
      </tr>
    </table>
  </body>
</html>

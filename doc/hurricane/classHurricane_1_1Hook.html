<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.0//EN'>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>Hurricane Documentation</title>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link   href="SoC.css" rel="stylesheet" type="text/css">
    <link   href="custom_tabs.css" rel="stylesheet" type="text/css">
  </head>
    <h1 id="pagetop" class="header">Hurricane VLSI Database</h1>
    <!--
    <center class="header">
      <table class="header">
        <tr>
          <td><a href="customSummary.html">Summary</a></td>
          <td><a href="namespaces.html">Namespaces</a></td>
          <td><a href="customHierarchy.html">Class Hierarchy</a></td>
          <td><a href="annotated.html">Classes</a></td>
          <td><a href="functions.html">Member Index</a></td>
        </tr>
      </table>
    </center>
    -->
    <br>
  <body onload="javascript:toggleLevel(1)">
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceHurricane.html">Hurricane</a></li><li class="navelem"><a class="el" href="classHurricane_1_1Hook.html">Hook</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classHurricane_1_1Hook-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Hurricane::Hook Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classHurricane_1_1Hook.html" title="Hook description (API)">Hook</a> description (<b>API</b>)  
 <a href="classHurricane_1_1Hook.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Hurricane::Hook:</div>
<div class="dyncontent">
<div class="center"><img src="classHurricane_1_1Hook__inherit__graph.png" border="0" usemap="#aHurricane_1_1Hook_inherit__map" alt="Inheritance graph"/></div>
<map name="aHurricane_1_1Hook_inherit__map" id="aHurricane_1_1Hook_inherit__map">
<area shape="rect" title="Hook description (API)" alt="" coords="5,111,132,138"/>
<area shape="rect" href="classHurricane_1_1Component_1_1BodyHook.html" title=" " alt="" coords="180,5,348,47"/>
<area shape="rect" href="classHurricane_1_1Contact_1_1AnchorHook.html" title=" " alt="" coords="193,71,335,112"/>
<area shape="rect" href="classHurricane_1_1Segment_1_1SourceHook.html" title=" " alt="" coords="189,136,339,177"/>
<area shape="rect" href="classHurricane_1_1Segment_1_1TargetHook.html" title=" " alt="" coords="189,201,339,243"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab420305aa59b8ff10d59678363de2511"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classHurricane_1_1Component.html">Component</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Hook.html#ab420305aa59b8ff10d59678363de2511">getComponent</a> () const =0</td></tr>
<tr class="separator:ab420305aa59b8ff10d59678363de2511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03044fa995d6d784d6c441927ca8af04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHurricane_1_1Hook.html">Hook</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Hook.html#a03044fa995d6d784d6c441927ca8af04">getNextHook</a> () const</td></tr>
<tr class="separator:a03044fa995d6d784d6c441927ca8af04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69ebbbf3d64343aca23ca435f24c624"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHurricane_1_1Hook.html">Hook</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Hook.html#ad69ebbbf3d64343aca23ca435f24c624">getPreviousHook</a> () const</td></tr>
<tr class="separator:ad69ebbbf3d64343aca23ca435f24c624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18e0531df4ed14b64cf058b780aee46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHurricane_1_1Hook.html">Hook</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Hook.html#af18e0531df4ed14b64cf058b780aee46">getMasterHook</a> () const</td></tr>
<tr class="separator:af18e0531df4ed14b64cf058b780aee46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0923a5a2d0a7ee0458876eed72008e46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHurricane_1_1Hook.html">Hook</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Hook.html#a0923a5a2d0a7ee0458876eed72008e46">getNextMasterHook</a> () const</td></tr>
<tr class="separator:a0923a5a2d0a7ee0458876eed72008e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bf5cdd4e81952064f1be94fe10188f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHurricane_1_1Hook.html">Hook</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Hook.html#a80bf5cdd4e81952064f1be94fe10188f">getPreviousMasterHook</a> () const</td></tr>
<tr class="separator:a80bf5cdd4e81952064f1be94fe10188f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2def96fbcd444bebc16e589357c2a779"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceHurricane.html#a9dcd9b74dc5e2b51bec7a13c25807e02">Hooks</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Hook.html#a2def96fbcd444bebc16e589357c2a779">getHooks</a> () const</td></tr>
<tr class="separator:a2def96fbcd444bebc16e589357c2a779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c977e4f253a18cf24dfe4a6fd24cb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceHurricane.html#a9dcd9b74dc5e2b51bec7a13c25807e02">Hooks</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Hook.html#ad3c977e4f253a18cf24dfe4a6fd24cb1">getSlaveHooks</a> () const</td></tr>
<tr class="separator:ad3c977e4f253a18cf24dfe4a6fd24cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0940eb0761f05df0b82c4198e22a01c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Hook.html#af0940eb0761f05df0b82c4198e22a01c">isMaster</a> () const =0</td></tr>
<tr class="separator:af0940eb0761f05df0b82c4198e22a01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd62c7de2c023a1013d5a728159d068d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Hook.html#acd62c7de2c023a1013d5a728159d068d">isAttached</a> () const</td></tr>
<tr class="separator:acd62c7de2c023a1013d5a728159d068d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f5beb5092e97947d24bd18adb33db1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHurricane_1_1Hook.html">Hook</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Hook.html#a83f5beb5092e97947d24bd18adb33db1">detach</a> ()</td></tr>
<tr class="separator:a83f5beb5092e97947d24bd18adb33db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc4dacd0d128b35fd15546bc6dde3c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHurricane_1_1Hook.html">Hook</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Hook.html#aacc4dacd0d128b35fd15546bc6dde3c3">attach</a> (<a class="el" href="classHurricane_1_1Hook.html">Hook</a> *hook)</td></tr>
<tr class="separator:aacc4dacd0d128b35fd15546bc6dde3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b98f0796a9080495472d574a23bcca0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHurricane_1_1Hook.html">Hook</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHurricane_1_1Hook.html#a7b98f0796a9080495472d574a23bcca0">merge</a> (<a class="el" href="classHurricane_1_1Hook.html">Hook</a> *hook)</td></tr>
<tr class="separator:a7b98f0796a9080495472d574a23bcca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classHurricane_1_1Hook.html" title="Hook description (API)">Hook</a> description (<b>API</b>) </p>
<h1><a class="anchor" id="secHookIntro"></a>
Introduction</h1>
<p>The hook is an object which is nested inside a component and which represents some specific part of this component (like its body, its origin or its extremity ...).</p>
<p>The <a class="el" href="classHurricane_1_1Hook.html" title="Hook description (API)">Hook</a> class is an abstract one, that means that for any new type of <b>part</b> a new hook subclass must be derived. Each hook specialization will be described altogether with the component which includes it.</p>
<p>The <a class="el" href="classHurricane_1_1Component.html" title="Component description (API)">Component</a> for instance introduces the concept of <b>BodyHook</b> representing the body of the component (which can be assimilated to the component itself).</p>
<h1><a class="anchor" id="secHookRings"></a>
Rings</h1>
<p>Hooks are assembled into a <b>ring</b> (circular link) thanks to a special field pointing to the next hook within the ring.</p>
<p>This field is never NULL, by default it points to itself, generating a minimal ring.</p>
<h1><a class="anchor" id="secHookMasterAndSlaveHookTypes"></a>
Master and Slave hook types</h1>
<p>There are two kinds of hooks : the <b>masters</b> and the <b>slaves</b>.</p>
<p>Rings are organized such that all slave hooks of a master hook are placed in the ring immediately before it (the ordering of slaves is not significant).</p>
<p>Therefore, to find the master of a given slave, it's enough to follow the ring pointers, starting from the slave, until a master is found.</p>
<h1><a class="anchor" id="secHookExplicitConnections"></a>
Explicit connections</h1>
<p>This dependency between a slave and its master means that the part of the component represented by the slave is anchored on the part of the component represented by the master.</p>
<p>This dependence relationship is indeed an explicit connection.</p>
<h1><a class="anchor" id="secHookImplicitConnections"></a>
Implicit connections</h1>
<p>Within a ring many relationships master-slaves can cohabit.</p>
<p>This cohabitation has a specific meaning for the different masters of the ring. In fact, the ring must be considered as a connection request between the different masters of the ring.</p>
<p>In other words, this means that the different masters remains to be connected together, or more generaly stated, that the different connected subsets of components associated to those masters remains to be connected together.</p>
<p>The ordering of masters within a ring has no particular signification.</p>
<h1><a class="anchor" id="secHookConceptsOfHyperhooksAndHyperrings"></a>
Concepts of HyperHooks and HyperRings</h1>
<p>We can imagine the master-slaves relation as a kind of hyper-hook representing the associated sub-ring, and the ring containing multiple master-slaves relations as an hyper-ring made up of hyper-hooks needing to be connected.</p>
<p>Therefore there will be two different levels of ring processing functions depending on wether we handle hooks stricktly speaking or we handle hyper-hooks representing multiple master hooks.</p>
<h1><a class="anchor" id="secHookConstructorAndDestructor"></a>
Constructor and Destructor</h1>
<p>There is no <a class="el" href="classHurricane_1_1Hook.html" title="Hook description (API)">Hook</a> constructor available because they are created by the components themselves.</p>
<p>On the same way, hooks disapear automatically with their owner. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab420305aa59b8ff10d59678363de2511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab420305aa59b8ff10d59678363de2511">&#9670;&nbsp;</a></span>getComponent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHurricane_1_1Component.html">Component</a> * Hurricane::Hook::getComponent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Returns:</b> the component whose hook represents a part.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The result is never NULL because hooks are byforce nested objects in their component. </dd></dl>

</div>
</div>
<a id="a03044fa995d6d784d6c441927ca8af04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03044fa995d6d784d6c441927ca8af04">&#9670;&nbsp;</a></span>getNextHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHurricane_1_1Hook.html">Hook</a> * Hurricane::Hook::getNextHook </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Returns:</b> the next hook within the ring.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The result is never NULL because every hook has by construction its next one (which may be itself is the ring is empty). </dd></dl>

</div>
</div>
<a id="ad69ebbbf3d64343aca23ca435f24c624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69ebbbf3d64343aca23ca435f24c624">&#9670;&nbsp;</a></span>getPreviousHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHurricane_1_1Hook.html">Hook</a> * Hurricane::Hook::getPreviousHook </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Returns:</b> the previous hook within the ring.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Less efficient than getNextHook because it requires a complete ring loop. </dd></dl>

</div>
</div>
<a id="af18e0531df4ed14b64cf058b780aee46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18e0531df4ed14b64cf058b780aee46">&#9670;&nbsp;</a></span>getMasterHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHurricane_1_1Hook.html">Hook</a> * Hurricane::Hook::getMasterHook </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Returns:</b> the master of the relation master-slaves identified by the hook.</p>
<dl class="section remark"><dt>Remarks</dt><dd>May return itself if the hook is a master and return NULL if the hook is a slave and has no associated master. </dd></dl>

</div>
</div>
<a id="a0923a5a2d0a7ee0458876eed72008e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0923a5a2d0a7ee0458876eed72008e46">&#9670;&nbsp;</a></span>getNextMasterHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHurricane_1_1Hook.html">Hook</a> * Hurricane::Hook::getNextMasterHook </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Returns:</b> the first master found when starting the search immediately after the given hook.</p>
<dl class="section remark"><dt>Remarks</dt><dd>May return NULL if there is no master within the ring or return the hook itself if it is a master and the only one in the ring. </dd></dl>

</div>
</div>
<a id="a80bf5cdd4e81952064f1be94fe10188f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80bf5cdd4e81952064f1be94fe10188f">&#9670;&nbsp;</a></span>getPreviousMasterHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHurricane_1_1Hook.html">Hook</a> * Hurricane::Hook::getPreviousMasterHook </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Returns:</b> the first master found when starting a backwards search immediately before the given hook.</p>
<dl class="section remark"><dt>Remarks</dt><dd>May return NULL if there is no master within the ring or return the hook itself if it is a master and the only one in the ring.</dd>
<dd>
Of course the search is done in the natural forward direction (else it would be trully inefficient). </dd></dl>

</div>
</div>
<a id="a2def96fbcd444bebc16e589357c2a779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2def96fbcd444bebc16e589357c2a779">&#9670;&nbsp;</a></span>getHooks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceHurricane.html#a9dcd9b74dc5e2b51bec7a13c25807e02">Hooks</a> Hurricane::Hook::getHooks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Returns:</b> the collection of hooks of the ring containing the given hook.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Hooks are always visited in the natural order starting from the hook itself. </dd></dl>

</div>
</div>
<a id="ad3c977e4f253a18cf24dfe4a6fd24cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c977e4f253a18cf24dfe4a6fd24cb1">&#9670;&nbsp;</a></span>getSlaveHooks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceHurricane.html#a9dcd9b74dc5e2b51bec7a13c25807e02">Hooks</a> Hurricane::Hook::getSlaveHooks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Returns:</b> the hook collection which are slaves of the given hook.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This collection will be empty if the given hook is not a master or if it has no attached slaves.</dd></dl>
<p>When visiting the slaves of a master, those are accessed in the assembly order : the first one is the oldest inserted (they are accessed starting from the first slave found when starting a ring loop from the master itself).</p>
<p>The master is not included in this collection. </p>

</div>
</div>
<a id="af0940eb0761f05df0b82c4198e22a01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0940eb0761f05df0b82c4198e22a01c">&#9670;&nbsp;</a></span>isMaster()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Hurricane::Hook::isMaster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Returns:</b> <b>true</b> if the hook must be considered as a master, else <b>false</b>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>For any new kind of hook this predicate must be overloaded. </dd></dl>

</div>
</div>
<a id="acd62c7de2c023a1013d5a728159d068d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd62c7de2c023a1013d5a728159d068d">&#9670;&nbsp;</a></span>isAttached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Hurricane::Hook::isAttached </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the hook is a slave :</p>
<p><b>Returns:</b> <b>true</b> if the hook has an associated master, else <b>false</b>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>You can't find two slaves in the same ring without at least a master.</dd></dl>
<p>If the hook is a master :</p>
<p>Let us consider the hyper-ring made upon hyper-hooks. Then the function returns <b>true</b> if the ring contains at least an other master else <b>false</b>.</p>
<dl class="section user"><dt>Caution: The meaning here is very different than for a slave hook! </dt><dd></dd></dl>

</div>
</div>
<a id="a83f5beb5092e97947d24bd18adb33db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f5beb5092e97947d24bd18adb33db1">&#9670;&nbsp;</a></span>detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHurricane_1_1Hook.html">Hook</a> * Hurricane::Hook::detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the hook is a slave :</p>
<p>detaches the hook from its ring and returns its old predecessor.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Will return NULL if the hook is the only one in the ring.</dd></dl>
<p>If the hook is a master :</p>
<p>Let us consider the hyper-ring made upon hyper-hooks. Then, the function detaches the hyper-hook (the sub-ring made up of the master and its slaves, if any) from the hyper-ring and returns the old predecessor of the hyper-hook.</p>
<p>Within the detached hyper-hook, the relationship master hook</p><ul>
<li>slave hooks remains unaltered and forms a new ring.</li>
</ul>
<dl class="section remark"><dt>Remarks</dt><dd>May return NULL if the hook is the only master of the ring.</dd></dl>
<p>The returned hook, if not NULL, is byforce a master. </p>

</div>
</div>
<a id="aacc4dacd0d128b35fd15546bc6dde3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc4dacd0d128b35fd15546bc6dde3c3">&#9670;&nbsp;</a></span>attach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHurricane_1_1Hook.html">Hook</a> * Hurricane::Hook::attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHurricane_1_1Hook.html">Hook</a> *&#160;</td>
          <td class="paramname"><em>masterHook</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the hook (this) is a slave :</p>
<p>The function inserts the hook immediately before <code>&lt;masterHook&gt;</code> and returns this masterHook.</p>
<dl class="section user"><dt>Caution: Might throw an exception if the hook already has a master or </dt><dd>if <code>&lt;masterHook&gt;</code> is not a master hook.</dd></dl>
<p>If the hook (this) is a master :</p>
<p>Let us consider the hyper-ring made upon hyper-hooks. Then, the function attaches the the hyper-hook (the sub-ring made up of this master hook and its slaves, if any) before the <code>&lt;masterHook&gt;</code> and returns this masterHook.</p>
<dl class="section user"><dt>Caution: Might throw an exception if the hyper-hook is already </dt><dd>attached within a ring including an other master or if <code>&lt;masterHook&gt;</code> is not a master hook. </dd></dl>

</div>
</div>
<a id="a7b98f0796a9080495472d574a23bcca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b98f0796a9080495472d574a23bcca0">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHurricane_1_1Hook.html">Hook</a> * Hurricane::Hook::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHurricane_1_1Hook.html">Hook</a> *&#160;</td>
          <td class="paramname"><em>masterHook</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>merges the rings represented by the two hooks which both must be masters, returns <code>&lt;masterHook&gt;</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Throws an exception if both hooks are not masters.</dd></dl>
<p>This function doesn't change the two relatioships master-slaves but modifies the connection request between corresponding hyper-hooks. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Hook_8h_source.html">Hook.h</a></li>
<li>Hook.dox</li>
</ul>
</div><!-- contents -->
    <br>
    <hr>
    <table class="footer1">
      <tr>
        <td class="LFooter"><small>Generated by doxygen 1.9.1 on Wed Jan 17 2024</small></td>
        <td class="RFooter"><a href='#pagetop'><small>Return to top of page</small></a></td>
      </tr>
    </table>
    <table class="footer2">
      <tr>
        <td class="LFooter">Hurricane VLSI Database</td>
        <td class="RFooter"><small>Copyright &#169; 2000-2020 Bull S.A. All rights reserved</small></td>
      </tr>
    </table>
  </body>
</html>
